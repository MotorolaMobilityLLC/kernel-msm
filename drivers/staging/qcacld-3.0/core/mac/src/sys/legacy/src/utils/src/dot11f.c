/*
 * Copyright (c) 2012-2021 The Linux Foundation. All rights reserved.
 *
 * Permission to use, copy, modify, and/or distribute this software for
 * any purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * \file dot11f.c
 *
 * \brief Structures, functions & definitions for
 * working with 802.11 Frames
 *
 *
 * This file was automatically generated by 'framesc'
 * Wed Sep 29 13:23:21 2021 from the following file(s):
 *
 * dot11f.frms
 *
 * PLEASE DON'T EDIT THIS FILE BY HAND!
 *
 */

#if !defined  ANI_OS_TYPE_OSX && !defined ANI_OS_TYPE_LINUX && !defined ANI_OS_TYPE_ANDROID
#include <memory.h> /* For memcpy */
#include <stdio.h>  /* For _vsnprintf */
#include <stddef.h> /* For offsetof */
#endif

#include <ani_global.h>
#include <utils_api.h>
#include "dot11fdefs.h"
#include "dot11f.h"

#if defined(_MSC_VER)
#pragma warning (disable:4244)
#pragma warning (disable:4505)
#pragma warning (disable:4702)
#pragma warning (disable:4996)/* ... was declared deprecated */
#endif /* Microsoft C/C++ */

typedef unsigned char tFRAMES_BOOL;
typedef void (*pfnGeneric_t)(void);

typedef struct sFFDefn {
	const char  *name;
	uint32_t offset;
	uint16_t sig;
	uint8_t  size;
} tFFDefn;

typedef struct sIEDefn {
	uint32_t  offset;
	uint32_t  presenceOffset;
	uint32_t  countOffset;
	const char   *name;
	uint16_t  arraybound;
	uint16_t  minSize;
	uint16_t  maxSize;
	uint16_t  sig;
	unsigned char oui[5];
	unsigned char noui;
	uint8_t   eid;
	uint8_t   extn_eid;
	tFRAMES_BOOL  fMandatory;
} tIEDefn;

#if !defined(countof)
#define countof(x) (sizeof((x)) / sizeof((x)[0]))
#endif

#if !defined(DOT11F_MEMCPY)
#define DOT11F_MEMCPY(ctx, dst, src, len) \
	memcpy((dst), (src), (len))
#endif

#if !defined(DOT11F_MEMCMP)
#define DOT11F_MEMCMP(ctx, lhs, rhs, len) \
	memcmp((lhs), (rhs), (len))
#endif

#ifndef DOT11F_HAVE_LOG_SEVERITIES
#define FRLOG_OFF (0)
#define FRLOGP    (1)
#define FRLOGE    (2)
#define FRLOGW    (3)
#define FRLOG1    (4)
#define FRLOG2    (5)
#define FRLOG3    (6)
#define FRLOG4    (7)
#endif

#define FRFL(x) x

#define FRAMES_LOG0(ctx, sev, fmt)
#define FRAMES_LOG1(ctx, sev, fmt, p1)
#define FRAMES_LOG2(ctx, sev, fmt, p1, p2)
#define FRAMES_LOG3(ctx, sev, fmt, p1, p2, p3)
#define FRAMES_LOG4(ctx, sev, fmt, p1, p2, p3, p4)
#define FRAMES_DUMP(ctx, sev, p, n)
#ifndef FRAMES_SEV_FOR_FRAME
#define FRAMES_SEV_FOR_FRAME(ctx, sig) FRLOG3
#endif

#if defined(DOT11F_ENABLE_DBG_BREAK) && defined (WIN32)
#define FRAMES_DBG_BREAK() { _asm int 3 }
#else
#define FRAMES_DBG_BREAK()
#endif

#if !defined(DOT11F_PARAMETER_CHECK)
#if defined (DOT11F_HAVE_WIN32_API)

#define DOT11F_PARAMETER_CHECK(pBuf, nBuf, pFrm, nFrm) \
	do { \
		if (!pBuf || IsBadReadPtr(pBuf, nBuf))\
			return DOT11F_BAD_INPUT_BUFFER; \
		if (!pFrm || IsBadWritePtr(pFrm, nFrm))\
			return DOT11F_BAD_OUTPUT_BUFFER; \
	} while (0)

#define DOT11F_PARAMETER_CHECK2(pSrc, pBuf, nBuf, pnConsumed) \
	do { \
		if (!pSrc || IsBadReadPtr(pSrc, 4))\
			eturn DOT11F_BAD_INPUT_BUFFER; \
		if (!pBuf || IsBadWritePtr(pBuf, nBuf))\
			return DOT11F_BAD_OUTPUT_BUFFER; \
		if (!nBuf)\
			return DOT11F_BAD_OUTPUT_BUFFER; \
		if (IsBadWritePtr(pnConsumed, 4))\
			return DOT11F_BAD_OUTPUT_BUFFER; \
	} while (0)

#else

#define DOT11F_PARAMETER_CHECK(pBuf, nBuf, pFrm, nFrm) \
	if (!pBuf)\
		return DOT11F_BAD_INPUT_BUFFER; \
	if (!pFrm)\
		return DOT11F_BAD_OUTPUT_BUFFER \

#define DOT11F_PARAMETER_CHECK2(pSrc, pBuf, nBuf, pnConsumed) \
	if (!pSrc)\
		return DOT11F_BAD_INPUT_BUFFER; \
	if (!pBuf)\
		return DOT11F_BAD_OUTPUT_BUFFER; \
	if (!nBuf)\
		return DOT11F_BAD_OUTPUT_BUFFER; \
	if (!pnConsumed)\
		return DOT11F_BAD_OUTPUT_BUFFER \

#endif
#endif

static void framesntohs(tpAniSirGlobal    pCtx,
			uint16_t *pOut,
			uint8_t  *pIn,
			tFRAMES_BOOL  fMsb)
{
	(void)pCtx;
#if defined (DOT11F_LITTLE_ENDIAN_HOST)
	if (!fMsb)
		DOT11F_MEMCPY(pCtx, (uint16_t *)pOut, pIn, 2);
	else
		*pOut = (uint16_t)(*pIn << 8) | *(pIn + 1);
#else
	if (!fMsb)
		*pOut = (uint16_t)(*pIn | (*(pIn + 1) << 8));
	else
		DOT11F_MEMCPY(pCtx, (uint16_t *)pOut, pIn, 2);
#endif
}

static void framesntohl(tpAniSirGlobal    pCtx,
			uint32_t *pOut,
			uint8_t  *pIn,
			tFRAMES_BOOL  fMsb)
{
	(void)pCtx;
#if defined (DOT11F_LITTLE_ENDIAN_HOST)
	if (!fMsb)
		DOT11F_MEMCPY(pCtx, (uint32_t *)pOut, pIn, 4);
	else
		*pOut = (uint32_t)(*pIn << 24) |
			(*(pIn + 1) << 16) |
			(*(pIn + 2) <<  8) |
			(*(pIn + 3));
#else
	if (!fMsb)
		*pOut = (uint32_t)(*(pIn + 3) << 24) |
			(*(pIn + 2) << 16) |
			(*(pIn + 1) <<  8) |
			(*(pIn));
else
		*pOut = *(uint32_t *)pIn;
#endif
}

static void framesntohq(tpAniSirGlobal    pCtx,
			tDOT11F_U64 *pOut,
			uint8_t  *pIn,
			tFRAMES_BOOL  fMsb)
{
#if defined (DOT11F_LITTLE_ENDIAN_HOST)
	framesntohl(pCtx, &((*pOut)[0]), pIn, fMsb);
	framesntohl(pCtx, &((*pOut)[1]), pIn + 4, fMsb);
#else
	framesntohl(pCtx, &((*pOut)[1]), pIn, fMsb);
	framesntohl(pCtx, &((*pOut)[0]), pIn + 4, fMsb);
#endif
}

static void frameshtons(tpAniSirGlobal    pCtx,
			uint8_t  *pOut,
			uint16_t  pIn,
			tFRAMES_BOOL  fMsb)
{
	(void)pCtx;
#if defined (DOT11F_LITTLE_ENDIAN_HOST)
	if (!fMsb) {
		DOT11F_MEMCPY(pCtx, pOut, &pIn, 2);
	} else {
		*pOut       = (pIn & 0xff00) >> 8;
		*(pOut + 1) = pIn & 0xff;
	}
#else
	if (!fMsb) {
		*pOut       = pIn & 0xff;
		*(pOut + 1) = (pIn & 0xff00) >> 8;
	} else {
		DOT11F_MEMCPY(pCtx, pOut, &pIn, 2);
	}
#endif
}

static void frameshtonl(tpAniSirGlobal    pCtx,
			uint8_t  *pOut,
			uint32_t  pIn,
			tFRAMES_BOOL  fMsb)
{
	(void)pCtx;
#if defined (DOT11F_LITTLE_ENDIAN_HOST)
	if (!fMsb) {
		DOT11F_MEMCPY(pCtx, pOut, &pIn, 4);
	} else {
		*pOut       = (pIn & 0xff000000) >> 24;
		*(pOut + 1) = (pIn & 0x00ff0000) >> 16;
		*(pOut + 2) = (pIn & 0x0000ff00) >>  8;
		*(pOut + 3) = (pIn & 0x000000ff);
	}
#else
	if (!fMsb) {
		*pOut       = (pIn & 0x000000ff);
		*(pOut + 1) = (pIn & 0x0000ff00) >>  8;
		*(pOut + 2) = (pIn & 0x00ff0000) >> 16;
		*(pOut + 3) = (pIn & 0xff000000) >> 24;
	} else {
		DOT11F_MEMCPY(pCtx, pOut, &pIn, 4);
	}
#endif
}

static void frameshtonq(tpAniSirGlobal    pCtx,
			uint8_t  *pOut,
			tDOT11F_U64  pIn,
			tFRAMES_BOOL  fMsb)
{
#if defined (DOT11F_LITTLE_ENDIAN_HOST)
	frameshtonl(pCtx, pOut, pIn[0], fMsb);
	frameshtonl(pCtx, pOut + 4, pIn[1], fMsb);
#else
	frameshtonl(pCtx, pOut + 4, pIn[1], fMsb);
	frameshtonl(pCtx, pOut, pIn[0], fMsb);
#endif
}

static const tIEDefn *find_ie_defn(tpAniSirGlobal pCtx,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   const tIEDefn  IEs[])
{
	const tIEDefn *pIe;
	(void)pCtx;

	pIe = &(IEs[0]);
	while (0xff != pIe->eid || pIe->extn_eid) {
		if (*pBuf == pIe->eid) {
			if (pIe->eid == 0xff) {
				if ((nBuf > 2) &&
				    (*(pBuf + 2)) == pIe->extn_eid)
					return pIe;
			} else {
				if (0 == pIe->noui)
					return pIe;

				if ((nBuf > (uint32_t)(pIe->noui + 2)) &&
				    (!DOT11F_MEMCMP(pCtx, pBuf + 2, pIe->oui,
						      pIe->noui)))
					return pIe;
			}
		}

		++pIe;
	}

	return NULL;
}

static uint32_t get_container_ies_len(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint32_t  nBuf,
				      uint8_t *pnConsumed,
				      const tIEDefn  IEs[])
{
	const tIEDefn *pIe, *pIeFirst;
	uint8_t *pBufRemaining = pBuf;
	uint32_t len = 0;
	(void)pCtx;

	pIeFirst = &(IEs[0]);

	if (*pBufRemaining != pIeFirst->eid)
		return DOT11F_INTERNAL_ERROR;
	len += *(pBufRemaining+1);
	pBufRemaining += len + 2;
	len += 2;
	while (len + 1 < nBuf) {
		pIe = find_ie_defn(pCtx, pBufRemaining, nBuf - len, IEs);
		if (NULL == pIe)
			break;
		if (pIe->eid == pIeFirst->eid)
			break;
		len += *(pBufRemaining + 1) + 2;
		pBufRemaining += *(pBufRemaining + 1) + 2;
	}

	if ((len > 0xFF) || (len > nBuf))
		return DOT11F_INTERNAL_ERROR;
	*pnConsumed = len;
	return DOT11F_PARSE_SUCCESS;

}


static uint32_t unpack_core(tpAniSirGlobal pCtx,
			    uint8_t *pBuf,
			    uint32_t nBuf,
			    const tFFDefn  FFs[],
			    const tIEDefn  IEs[],
			    uint8_t *pFrm,
			    size_t nFrm,
			    bool append_ie);
static uint32_t pack_core(tpAniSirGlobal pCtx,
			  uint8_t *pSrc,
			  uint8_t *pBuf,
			  uint32_t  nBuf,
			  uint32_t *pnConsumed,
			  const tFFDefn  FFs[],
			  const tIEDefn  IEs[]);
static uint32_t get_packed_size_core(tpAniSirGlobal pCtx,
				     uint8_t *pFrm,
				     uint32_t *pnNeeded,
				     const tIEDefn  IEs[]);

static uint32_t dot11f_unpack_tlv_common_func(tpAniSirGlobal pCtx,
			 uint8_t *pBuf, uint16_t tlvlen,
			 uint8_t *pDstPresent, uint8_t *pDstField)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)tlvlen; /* Shutup the compiler */

	*pDstPresent = 1;
	*pDstField = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_common_func. */

static uint32_t dot11f_unpack_tlv_common_func2(tpAniSirGlobal  pCtx,
			 uint8_t *pBuf, uint16_t tlvlen,
			 uint8_t *pDstPresent, uint16_t *pDstState)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)tlvlen; /* Shutup the compiler */

	*pDstPresent = 1;
	framesntohs(pCtx, pDstState, pBuf, 1);
	(void)pCtx;
	return status;

} /* End dot11f_unpack_tlv_common_func2. */

static void dot11f_unpack_ff_common_func(tpAniSirGlobal pCtx,
				  uint8_t *pBuf, uint16_t *pDstField)
{
	framesntohs(pCtx, pDstField, pBuf, 0);
	(void)pCtx;
} /* End dot11f_unpack_ff_common_func. */

static uint32_t dot11f_unpack_ie_common_func(tpAniSirGlobal pCtx, uint8_t *pBuf,
				      uint8_t ielen, uint8_t *pDstPresent,
				      uint8_t *pDstField)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)ielen;
	(void)pBuf;
	if ((*pDstPresent))
		status = DOT11F_DUPLICATE_IE;
	*pDstPresent = 1;
	*pDstField = *pBuf;
	(void)pCtx;

	return status;
} /* End dot11f_unpack_ie_common_func */

typedef struct sTLVDefn {
	uint32_t   offset;
	uint32_t   presenceOffset;
	const char     *name;
	uint16_t   sig;
	uint32_t   id;
	uint32_t   pec;
	uint32_t   minSize;
	uint32_t   maxSize;
	uint8_t    fMandatory;
	uint8_t    sType;
	uint8_t    sLen;
	uint8_t    fMsb;
} tTLVDefn;

static const tTLVDefn *find_tlv_defn(tpAniSirGlobal    pCtx,
				     uint8_t  *pBuf,
				     uint32_t  nBuf,
				     const tTLVDefn      TLVs[])
{
	const tTLVDefn *pTlv;
	uint32_t   pec;
	uint16_t   id;

	pTlv = &(TLVs[0]);
	(void)pCtx;
	if (pTlv->sType == 2)
		framesntohs(pCtx, &id, pBuf, 1);
	else
		id = *pBuf;

	while (0xffff != pTlv->id) {
		if (id == pTlv->id) {
			if (0 == pTlv->pec)
				return pTlv;

			if (nBuf > 5) {
				pec = ((*(pBuf + 4)) << 16) |
				      ((*(pBuf + 5)) <<  8) |
				      *(pBuf + 6);
				if (pec == pTlv->pec)
					return pTlv;
			}
		}

		++pTlv;
	}

	return NULL;
}

static uint32_t unpack_tlv_core(tpAniSirGlobal   pCtx,
			uint8_t *pBuf,
			uint32_t nBuf,
			const tTLVDefn TLVs[],
			uint8_t *pFrm,
			size_t nFrm);
static uint32_t pack_tlv_core(tpAniSirGlobal pCtx,
			      uint8_t *pSrc,
			      uint8_t *pBuf,
			      uint32_t  nBuf,
			      uint32_t *pnConsumed,
			      const tTLVDefn  TLVs[],
			      uint32_t *pidx);
static uint32_t get_packed_size_tlv_core(tpAniSirGlobal pCtx,
					 uint8_t *pFrm,
					 uint32_t *pnNeeded,
					 const tTLVDefn  TLVs[]);

#define SigFfAID (0x0001)

void dot11f_unpack_ff_action(tpAniSirGlobal pCtx,
			     uint8_t *pBuf,
			     tDot11fFfAction *pDst)
{
	pDst->action = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_action. */

#define SigFfAction (0x0002)

#define SigFfAuthAlgo (0x0003)

#define SigFfAuthSeqNo (0x0004)

#define SigFfBeaconInterval (0x0005)

void dot11f_unpack_ff_capabilities(tpAniSirGlobal pCtx,
				   uint8_t *pBuf,
				   tDot11fFfCapabilities *pDst)
{
	uint16_t tmp0__;
	framesntohs(pCtx, &tmp0__, pBuf, 0);
	pDst->ess = tmp0__ >> 0 & 0x1;
	pDst->ibss = tmp0__ >> 1 & 0x1;
	pDst->cfPollable = tmp0__ >> 2 & 0x1;
	pDst->cfPollReq = tmp0__ >> 3 & 0x1;
	pDst->privacy = tmp0__ >> 4 & 0x1;
	pDst->shortPreamble = tmp0__ >> 5 & 0x1;
	pDst->pbcc = tmp0__ >> 6 & 0x1;
	pDst->channelAgility = tmp0__ >> 7 & 0x1;
	pDst->spectrumMgt = tmp0__ >> 8 & 0x1;
	pDst->qos = tmp0__ >> 9 & 0x1;
	pDst->shortSlotTime = tmp0__ >> 10 & 0x1;
	pDst->apsd = tmp0__ >> 11 & 0x1;
	pDst->rrm = tmp0__ >> 12 & 0x1;
	pDst->dsssOfdm = tmp0__ >> 13 & 0x1;
	pDst->delayedBA = tmp0__ >> 14 & 0x1;
	pDst->immediateBA = tmp0__ >> 15 & 0x1;
	(void)pCtx;
} /* End dot11f_unpack_ff_capabilities. */

#define SigFfCapabilities (0x0006)

void dot11f_unpack_ff_category(tpAniSirGlobal pCtx,
			       uint8_t *pBuf,
			       tDot11fFfCategory *pDst)
{
	pDst->category = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_category. */

#define SigFfCategory (0x0007)

void dot11f_unpack_ff_current_ap_address(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       tDot11fFfCurrentAPAddress *pDst)
{
	DOT11F_MEMCPY(pCtx, pDst->mac, pBuf, 6);
	(void)pCtx;
} /* End dot11f_unpack_ff_current_ap_address. */

#define SigFfCurrentAPAddress (0x0008)

void dot11f_unpack_ff_dialog_token(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  tDot11fFfDialogToken *pDst)
{
	pDst->token = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_dialog_token. */

#define SigFfDialogToken (0x0009)

void dot11f_unpack_ff_link_margin(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 tDot11fFfLinkMargin *pDst)
{
	pDst->linkMargin = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_link_margin. */

#define SigFfLinkMargin (0x000a)

#define SigFfListenInterval (0x000b)

void dot11f_unpack_ff_max_tx_power(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 tDot11fFfMaxTxPower *pDst)
{
	pDst->maxTxPower = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_max_tx_power. */

#define SigFfMaxTxPower (0x000c)

void dot11f_unpack_ff_num_of_repetitions(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       tDot11fFfNumOfRepetitions *pDst)
{
	framesntohs(pCtx, &pDst->repetitions, pBuf, 0);
	(void)pCtx;
} /* End dot11f_unpack_ff_num_of_repetitions. */

#define SigFfNumOfRepetitions (0x000d)

void dot11f_unpack_ff_operating_mode(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    tDot11fFfOperatingMode *pDst)
{
	uint8_t tmp1__;
	tmp1__ = *pBuf;
	pDst->chanWidth = tmp1__ >> 0 & 0x3;
	pDst->reserved = tmp1__ >> 2 & 0x3;
	pDst->rxNSS = tmp1__ >> 4 & 0x7;
	pDst->rxNSSType = tmp1__ >> 7 & 0x1;
	(void)pCtx;
} /* End dot11f_unpack_ff_operating_mode. */

#define SigFfOperatingMode (0x000e)

void dot11f_unpack_ff_rcpi(tpAniSirGlobal pCtx,
			   uint8_t *pBuf,
			   tDot11fFfRCPI *pDst)
{
	pDst->rcpi = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_rcpi. */

#define SigFfRCPI (0x000f)

void dot11f_unpack_ff_rsni(tpAniSirGlobal pCtx,
			   uint8_t *pBuf,
			   tDot11fFfRSNI *pDst)
{
	pDst->rsni = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_rsni. */

#define SigFfRSNI (0x0010)

#define SigFfReason (0x0011)

void dot11f_unpack_ff_rx_antenna_id(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  tDot11fFfRxAntennaId *pDst)
{
	pDst->antennaId = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_rx_antenna_id. */

#define SigFfRxAntennaId (0x0012)

void dot11f_unpack_ff_sm_power_mode_set(tpAniSirGlobal pCtx,
				     uint8_t *pBuf,
				     tDot11fFfSMPowerModeSet *pDst)
{
	uint8_t tmp2__;
	tmp2__ = *pBuf;
	pDst->PowerSave_En = tmp2__ >> 0 & 0x1;
	pDst->Mode = tmp2__ >> 1 & 0x1;
	pDst->reserved = tmp2__ >> 2 & 0x3f;
	(void)pCtx;
} /* End dot11f_unpack_ff_sm_power_mode_set. */

#define SigFfSMPowerModeSet (0x0013)

#define SigFfStatus (0x0014)

void dot11f_unpack_ff_status_code(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 tDot11fFfStatusCode *pDst)
{
	pDst->statusCode = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_status_code. */

#define SigFfStatusCode (0x0015)

void dot11f_unpack_ff_tpc_ele_id(tpAniSirGlobal pCtx,
			       uint8_t *pBuf,
			       tDot11fFfTPCEleID *pDst)
{
	pDst->TPCId = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_tpc_ele_id. */

#define SigFfTPCEleID (0x0016)

void dot11f_unpack_ff_tpc_ele_len(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 tDot11fFfTPCEleLen *pDst)
{
	pDst->TPCLen = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_tpc_ele_len. */

#define SigFfTPCEleLen (0x0017)

void dot11f_unpack_ff_ts_info(tpAniSirGlobal pCtx,
			     uint8_t *pBuf,
			     tDot11fFfTSInfo *pDst)
{
	uint32_t tmp3__;
	framesntohl(pCtx, &tmp3__, pBuf, 0);
	pDst->traffic_type = tmp3__ >> 0 & 0x1;
	pDst->tsid = tmp3__ >> 1 & 0xf;
	pDst->direction = tmp3__ >> 5 & 0x3;
	pDst->access_policy = tmp3__ >> 7 & 0x3;
	pDst->aggregation = tmp3__ >> 9 & 0x1;
	pDst->psb = tmp3__ >> 10 & 0x1;
	pDst->user_priority = tmp3__ >> 11 & 0x7;
	pDst->tsinfo_ack_pol = tmp3__ >> 14 & 0x3;
	pDst->schedule = tmp3__ >> 16 & 0x1;
	pDst->unused = tmp3__ >> 17 & 0x7fff;
	(void)pCtx;
} /* End dot11f_unpack_ff_ts_info. */

#define SigFfTSInfo (0x0018)

void dot11f_unpack_ff_time_stamp(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 tDot11fFfTimeStamp *pDst)
{
	framesntohq(pCtx, &pDst->timestamp, pBuf, 0);
	(void)pCtx;
} /* End dot11f_unpack_ff_time_stamp. */

#define SigFfTimeStamp (0x0019)

void dot11f_unpack_ff_transaction_id(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    tDot11fFfTransactionId *pDst)
{
	DOT11F_MEMCPY(pCtx, pDst->transId, pBuf, 2);
	(void)pCtx;
} /* End dot11f_unpack_ff_transaction_id. */

#define SigFfTransactionId (0x001a)

void dot11f_unpack_ff_tx_antenna_id(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  tDot11fFfTxAntennaId *pDst)
{
	pDst->antennaId = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_tx_antenna_id. */

#define SigFfTxAntennaId (0x001b)

void dot11f_unpack_ff_tx_power(tpAniSirGlobal pCtx,
			      uint8_t *pBuf,
			      tDot11fFfTxPower *pDst)
{
	pDst->txPower = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_tx_power. */

#define SigFfTxPower (0x001c)

void dot11f_unpack_ff_vht_membership_status_array(tpAniSirGlobal pCtx,
					       uint8_t *pBuf,
					       tDot11fFfVhtMembershipStatusArray *pDst)
{
	DOT11F_MEMCPY(pCtx, pDst->membershipStatusArray, pBuf, 8);
	(void)pCtx;
} /* End dot11f_unpack_ff_vht_membership_status_array. */

#define SigFfVhtMembershipStatusArray (0x001d)

void dot11f_unpack_ff_vht_user_position_array(tpAniSirGlobal pCtx,
					   uint8_t *pBuf,
					   tDot11fFfVhtUserPositionArray *pDst)
{
	DOT11F_MEMCPY(pCtx, pDst->userPositionArray, pBuf, 16);
	(void)pCtx;
} /* End dot11f_unpack_ff_vht_user_position_array. */

#define SigFfVhtUserPositionArray (0x001e)

void dot11f_unpack_ff_addba_param_set(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      tDot11fFfaddba_param_set *pDst)
{
	uint16_t tmp4__;
	framesntohs(pCtx, &tmp4__, pBuf, 0);
	pDst->amsdu_supp = tmp4__ >> 0 & 0x1;
	pDst->policy = tmp4__ >> 1 & 0x1;
	pDst->tid = tmp4__ >> 2 & 0xf;
	pDst->buff_size = tmp4__ >> 6 & 0x3ff;
	(void)pCtx;
} /* End dot11f_unpack_ff_addba_param_set. */

#define SigFfaddba_param_set (0x001f)

void dot11f_unpack_ff_ba_start_seq_ctrl(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 tDot11fFfba_start_seq_ctrl *pDst)
{
	uint16_t tmp5__;
	framesntohs(pCtx, &tmp5__, pBuf, 0);
	pDst->frag_number = tmp5__ >> 0 & 0xf;
	pDst->ssn = tmp5__ >> 4 & 0xfff;
	(void)pCtx;
} /* End dot11f_unpack_ff_ba_start_seq_ctrl. */

#define SigFfba_start_seq_ctrl (0x0020)

void dot11f_unpack_ff_ba_timeout(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 tDot11fFfba_timeout *pDst)
{
	framesntohs(pCtx, &pDst->timeout, pBuf, 0);
	(void)pCtx;
} /* End dot11f_unpack_ff_ba_timeout. */

#define SigFfba_timeout (0x0021)

void dot11f_unpack_ff_delba_param_set(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      tDot11fFfdelba_param_set *pDst)
{
	uint16_t tmp6__;
	framesntohs(pCtx, &tmp6__, pBuf, 0);
	pDst->reserved = tmp6__ >> 0 & 0x7ff;
	pDst->initiator = tmp6__ >> 11 & 0x1;
	pDst->tid = tmp6__ >> 12 & 0xf;
	(void)pCtx;
} /* End dot11f_unpack_ff_delba_param_set. */

#define SigFfdelba_param_set (0x0022)

void dot11f_unpack_ff_ext_chan_switch_ann_action(tpAniSirGlobal pCtx,
						 uint8_t *pBuf,
						 tDot11fFfext_chan_switch_ann_action *pDst)
{
	uint32_t tmp7__;
	framesntohl(pCtx, &tmp7__, pBuf, 0);
	pDst->switch_mode = tmp7__ >> 0 & 0xff;
	pDst->op_class = tmp7__ >> 8 & 0xff;
	pDst->new_channel = tmp7__ >> 16 & 0xff;
	pDst->switch_count = tmp7__ >> 24 & 0xff;
	(void)pCtx;
} /* End dot11f_unpack_ff_ext_chan_switch_ann_action. */

#define SigFfext_chan_switch_ann_action (0x0023)

void dot11f_unpack_ff_p2p_action_oui(tpAniSirGlobal pCtx,
				     uint8_t *pBuf,
				     tDot11fFfp2p_action_oui *pDst)
{
	DOT11F_MEMCPY(pCtx, pDst->oui_data, pBuf, 4);
	(void)pCtx;
} /* End dot11f_unpack_ff_p2p_action_oui. */

#define SigFfp2p_action_oui (0x0024)

void dot11f_unpack_ff_p2p_action_subtype(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 tDot11fFfp2p_action_subtype *pDst)
{
	pDst->subtype = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_p2p_action_subtype. */

#define SigFfp2p_action_subtype (0x0025)

void dot11f_unpack_ff_vendor_action_subtype(tpAniSirGlobal pCtx,
					    uint8_t *pBuf,
					    tDot11fFfvendor_action_subtype *pDst)
{
	pDst->subtype = *pBuf;
	(void)pCtx;
} /* End dot11f_unpack_ff_vendor_action_subtype. */

#define SigFfvendor_action_subtype (0x0026)

void dot11f_unpack_ff_vendor_oui(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 tDot11fFfvendor_oui *pDst)
{
	DOT11F_MEMCPY(pCtx, pDst->oui_data, pBuf, 3);
	(void)pCtx;
} /* End dot11f_unpack_ff_vendor_oui. */

#define SigFfvendor_oui (0x0027)

uint32_t dot11f_unpack_tlv_authorized_ma_cs(tpAniSirGlobal pCtx,
					  uint8_t *pBuf,
					  uint16_t tlvlen,
					  tDot11fTLVAuthorizedMACs *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->mac, pBuf, 6);
	pBuf += 6;
	tlvlen -= (uint8_t)6;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_authorized_ma_cs. */

#define SigTlvAuthorizedMACs (0x0001)


#define SigTlvRequestToEnroll (0x0002)


uint32_t dot11f_unpack_tlv_version2(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint16_t tlvlen,
				    tDot11fTLVVersion2 *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp8__;
	pDst->present = 1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp8__ = *pBuf;
	pBuf += 1;
	tlvlen -= 1;
	pDst->minor = tmp8__ >> 0 & 0xf;
	pDst->major = tmp8__ >> 4 & 0xf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_version2. */

#define SigTlvVersion2 (0x0003)


#define SigTlvAPSetupLocked (0x0004)


#define SigTlvAssociationState (0x0005)


#define SigTlvConfigMethods (0x0006)


#define SigTlvConfigurationError (0x0007)


uint32_t dot11f_unpack_tlv_device_name(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint16_t tlvlen,
				      tDot11fTLVDeviceName *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	pDst->num_text = (uint8_t)(tlvlen);
	if (tlvlen > 32) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->text, pBuf, (tlvlen));
	pBuf += (tlvlen);
	tlvlen -= (tlvlen);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_device_name. */

#define SigTlvDeviceName (0x0008)


#define SigTlvDevicePasswordID (0x0009)


uint32_t dot11f_unpack_tlv_extended_listen_timing(tpAniSirGlobal pCtx,
						 uint8_t *pBuf,
						 uint16_t tlvlen,
						 tDot11fTLVExtendedListenTiming *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->availibilityPeriod, pBuf, 0);
	pBuf += 2;
	tlvlen -= (uint8_t)2;
	if (unlikely(tlvlen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->availibilityInterval, pBuf, 0);
	pBuf += 2;
	tlvlen -= (uint8_t)2;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_extended_listen_timing. */

#define SigTlvExtendedListenTiming (0x000a)


uint32_t dot11f_unpack_tlv_listen_channel(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint16_t tlvlen,
					 tDot11fTLVListenChannel *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 3)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->countryString, pBuf, 3);
	pBuf += 3;
	tlvlen -= (uint8_t)3;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->regulatoryClass = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->channel = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_listen_channel. */

#define SigTlvListenChannel (0x000b)


uint32_t dot11f_unpack_tlv_manufacturer(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint16_t tlvlen,
					 tDot11fTLVManufacturer *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	pDst->num_name = (uint8_t)(tlvlen);
	if (tlvlen > 64) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->name, pBuf, (tlvlen));
	pBuf += (tlvlen);
	tlvlen -= (tlvlen);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_manufacturer. */

#define SigTlvManufacturer (0x000c)


#define SigTlvMinorReasonCode (0x000d)


uint32_t dot11f_unpack_tlv_model_name(tpAniSirGlobal pCtx,
				     uint8_t *pBuf,
				     uint16_t tlvlen,
				     tDot11fTLVModelName *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	pDst->num_text = (uint8_t)(tlvlen);
	if (tlvlen > 32) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->text, pBuf, (tlvlen));
	pBuf += (tlvlen);
	tlvlen -= (tlvlen);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_model_name. */

#define SigTlvModelName (0x000e)


uint32_t dot11f_unpack_tlv_model_number(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint16_t tlvlen,
				       tDot11fTLVModelNumber *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	pDst->num_text = (uint8_t)(tlvlen);
	if (tlvlen > 32) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->text, pBuf, (tlvlen));
	pBuf += (tlvlen);
	tlvlen -= (tlvlen);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_model_number. */

#define SigTlvModelNumber (0x000f)


uint32_t dot11f_unpack_tlv_notice_of_absence(tpAniSirGlobal pCtx,
					   uint8_t *pBuf,
					   uint16_t tlvlen,
					   tDot11fTLVNoticeOfAbsence *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->index = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->CTSWindowOppPS = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	pDst->num_NoADesc = (uint8_t)(tlvlen);
	if (tlvlen > 36) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->NoADesc, pBuf, (tlvlen));
	pBuf += (tlvlen);
	tlvlen -= (tlvlen);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_notice_of_absence. */

#define SigTlvNoticeOfAbsence (0x0010)


uint32_t dot11f_unpack_tlv_operating_channel(tpAniSirGlobal pCtx,
					    uint8_t *pBuf,
					    uint16_t tlvlen,
					    tDot11fTLVOperatingChannel *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 3)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->countryString, pBuf, 3);
	pBuf += 3;
	tlvlen -= (uint8_t)3;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->regulatoryClass = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->channel = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_operating_channel. */

#define SigTlvOperatingChannel (0x0011)


uint32_t dot11f_unpack_tlv_p2_p_capability(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint16_t tlvlen,
					 tDot11fTLVP2PCapability *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->deviceCapability = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->groupCapability = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_p2_p_capability. */

#define SigTlvP2PCapability (0x0012)


uint32_t dot11f_unpack_tlv_p2_p_device_id(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint16_t tlvlen,
				       tDot11fTLVP2PDeviceId *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->P2PDeviceAddress, pBuf, 6);
	pBuf += 6;
	tlvlen -= (uint8_t)6;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_p2_p_device_id. */

#define SigTlvP2PDeviceId (0x0013)


static const tTLVDefn TLVS_P2PDeviceInfo[] = {
	{ offsetof(tDot11fTLVP2PDeviceInfo, DeviceName),
	offsetof(tDot11fTLVDeviceName, present), "DeviceName", SigTlvDeviceName,
	DOT11F_TLV_DEVICENAME, 0, 4, 36, 1, 2, 2, 1, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_tlv_p2_p_device_info(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint16_t tlvlen,
					 tDot11fTLVP2PDeviceInfo *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->P2PDeviceAddress, pBuf, 6);
	pBuf += 6;
	tlvlen -= (uint8_t)6;
	if (unlikely(tlvlen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->configMethod, pBuf, 0);
	pBuf += 2;
	tlvlen -= (uint8_t)2;
	if (unlikely(tlvlen < 8)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->primaryDeviceType, pBuf, 8);
	pBuf += 8;
	tlvlen -= (uint8_t)8;
	(void)pCtx;
	status |= unpack_tlv_core(pCtx,
				  pBuf,
				  tlvlen,
				  TLVS_P2PDeviceInfo,
				  (uint8_t *)pDst,
				  sizeof(*pDst));
	return status;
} /* End dot11f_unpack_tlv_p2_p_device_info. */

#define SigTlvP2PDeviceInfo (0x0014)


uint32_t dot11f_unpack_tlv_p2_p_group_info(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint16_t tlvlen,
					 tDot11fTLVP2PGroupInfo *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	pDst->num_P2PClientInfoDesc = (uint8_t)(tlvlen);
	DOT11F_MEMCPY(pCtx, pDst->P2PClientInfoDesc, pBuf, (tlvlen));
	pBuf += (tlvlen);
	tlvlen -= (tlvlen);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_p2_p_group_info. */

#define SigTlvP2PGroupInfo (0x0015)


#define SigTlvP2PStatus (0x0016)


uint32_t dot11f_unpack_tlv_primary_device_type(tpAniSirGlobal pCtx,
					     uint8_t *pBuf,
					     uint16_t tlvlen,
					     tDot11fTLVPrimaryDeviceType *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)tlvlen; /* Shutup the compiler */
	pDst->present = 1;
	if (unlikely(tlvlen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->primary_category, pBuf, 1);
	pBuf += 2;
	tlvlen -= (uint8_t)2;
	if (unlikely(tlvlen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->oui, pBuf, 4);
	pBuf += 4;
	tlvlen -= (uint8_t)4;
	if (unlikely(tlvlen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->sub_category, pBuf, 1);
	pBuf += 2;
	tlvlen -= (uint8_t)2;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_primary_device_type. */

#define SigTlvPrimaryDeviceType (0x0017)


#define SigTlvRFBands (0x0018)


uint32_t dot11f_unpack_tlv_request_device_type(tpAniSirGlobal pCtx,
					     uint8_t *pBuf,
					     uint16_t tlvlen,
					     tDot11fTLVRequestDeviceType *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->primary_category, pBuf, 1);
	pBuf += 2;
	tlvlen -= (uint8_t)2;
	if (unlikely(tlvlen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->oui, pBuf, 4);
	pBuf += 4;
	tlvlen -= (uint8_t)4;
	if (unlikely(tlvlen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->sub_category, pBuf, 1);
	pBuf += 2;
	tlvlen -= (uint8_t)2;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_request_device_type. */

#define SigTlvRequestDeviceType (0x0019)


#define SigTlvRequestType (0x001a)


#define SigTlvResponseType (0x001b)


#define SigTlvSelectedRegistrar (0x001c)


#define SigTlvSelectedRegistrarConfigMethods (0x001d)


uint32_t dot11f_unpack_tlv_serial_number(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint16_t tlvlen,
					 tDot11fTLVSerialNumber *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	pDst->num_text = (uint8_t)(tlvlen);
	if (tlvlen > 32) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->text, pBuf, (tlvlen));
	pBuf += (tlvlen);
	tlvlen -= (tlvlen);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_serial_number. */

#define SigTlvSerialNumber (0x001e)


uint32_t dot11f_unpack_tlv_uuid_e(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint16_t tlvlen,
				  tDot11fTLVUUID_E *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 16)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->uuid, pBuf, 16);
	pBuf += 16;
	tlvlen -= (uint8_t)16;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_uuid_e. */

#define SigTlvUUID_E (0x001f)


uint32_t dot11f_unpack_tlv_uuid_r(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint16_t tlvlen,
				  tDot11fTLVUUID_R *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 16)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->uuid, pBuf, 16);
	pBuf += 16;
	tlvlen -= (uint8_t)16;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_uuid_r. */

#define SigTlvUUID_R (0x0020)


static const tTLVDefn TLVS_VendorExtension[] = {
	{ offsetof(tDot11fTLVVendorExtension, Version2),
	offsetof(tDot11fTLVVersion2, present), "Version2", SigTlvVersion2,
	DOT11F_TLV_VERSION2, 0, 3, 3, 0, 1, 1, 1, },
	{ offsetof(tDot11fTLVVendorExtension, AuthorizedMACs),
	offsetof(tDot11fTLVAuthorizedMACs, present), "AuthorizedMACs",
	SigTlvAuthorizedMACs, DOT11F_TLV_AUTHORIZEDMACS, 0, 8, 8, 0, 1, 1, 1, },
	{ offsetof(tDot11fTLVVendorExtension, RequestToEnroll),
	offsetof(tDot11fTLVRequestToEnroll, present), "RequestToEnroll",
	SigTlvRequestToEnroll, DOT11F_TLV_REQUESTTOENROLL,
	0, 3, 3, 0, 1, 1, 1, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_tlv_vendor_extension(tpAniSirGlobal pCtx,
					   uint8_t *pBuf,
					   uint16_t tlvlen,
					   tDot11fTLVVendorExtension *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 3)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->vendorId, pBuf, 3);
	pBuf += 3;
	tlvlen -= (uint8_t)3;
	(void)pCtx;
	status |= unpack_tlv_core(pCtx,
				  pBuf,
				  tlvlen,
				  TLVS_VendorExtension,
				  (uint8_t *)pDst,
				  sizeof(*pDst));
	return status;
} /* End dot11f_unpack_tlv_vendor_extension. */

#define SigTlvVendorExtension (0x0021)


uint32_t dot11f_unpack_tlv_version(tpAniSirGlobal pCtx,
				   uint8_t *pBuf,
				   uint16_t tlvlen,
				   tDot11fTLVVersion *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp9__;
	pDst->present = 1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp9__ = *pBuf;
	pBuf += 1;
	tlvlen -= 1;
	pDst->minor = tmp9__ >> 0 & 0xf;
	pDst->major = tmp9__ >> 4 & 0xf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_version. */

#define SigTlvVersion (0x0022)


#define SigTlvWPSState (0x0023)


#define SigTlvassoc_disallowed (0x0024)


#define SigTlvassoc_retry_delay (0x0025)


#define SigTlvcellular_data_cap (0x0026)


#define SigTlvcellular_data_con_pref (0x0027)


#define SigTlvhe_2xltf_160mhz_supp (0x0028)


uint32_t dot11f_unpack_tlv_he_400ns_sgi_attr(tpAniSirGlobal pCtx,
					     uint8_t *pBuf,
					     uint16_t tlvlen,
					     tDot11fTLVhe_400ns_sgi_attr *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->he_ltf1x_400ns_sgi = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->he_ltf2x_400ns_sgi = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->he_ltf4x_400ns_sgi = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_he_400ns_sgi_attr. */

#define SigTlvhe_400ns_sgi_attr (0x0029)


#define SigTlvhe_dl_mumimo_attr (0x002a)


#define SigTlvhe_dl_ofdma_attr (0x002b)


uint32_t dot11f_unpack_tlv_he_mcs13_attr(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint16_t tlvlen,
					 tDot11fTLVhe_mcs13_attr *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->he_mcs_12_13_supp_80 = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->he_mcs_12_13_supp_160 = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_he_mcs13_attr. */

#define SigTlvhe_mcs13_attr (0x002c)


#define SigTlvmbo_ap_cap (0x002d)


uint32_t dot11f_unpack_tlv_non_prefferd_chan_rep(tpAniSirGlobal pCtx,
						 uint8_t *pBuf,
						 uint16_t tlvlen,
						 tDot11fTLVnon_prefferd_chan_rep *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->oper_class = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	pDst->num_channel_report = (uint8_t)(tlvlen);
	if (tlvlen > 254) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->channel_report, pBuf, (tlvlen));
	pBuf += (tlvlen);
	tlvlen -= (tlvlen);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_non_prefferd_chan_rep. */

#define SigTlvnon_prefferd_chan_rep (0x002e)


uint32_t dot11f_unpack_tlv_oce_cap(tpAniSirGlobal pCtx,
				   uint8_t *pBuf,
				   uint16_t tlvlen,
				   tDot11fTLVoce_cap *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp10__;
	pDst->present = 1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp10__ = *pBuf;
	pBuf += 1;
	tlvlen -= 1;
	pDst->oce_release = tmp10__ >> 0 & 0x7;
	pDst->is_sta_cfon = tmp10__ >> 3 & 0x1;
	pDst->non_oce_ap_present = tmp10__ >> 4 & 0x1;
	pDst->reserved = tmp10__ >> 5 & 0x7;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_oce_cap. */

#define SigTlvoce_cap (0x002f)


uint32_t dot11f_unpack_tlv_qcn_version(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint16_t tlvlen,
				       tDot11fTLVqcn_version *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->version = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->sub_version = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_qcn_version. */

#define SigTlvqcn_version (0x0030)


uint32_t dot11f_unpack_tlv_reduced_wan_metrics(tpAniSirGlobal pCtx,
					       uint8_t *pBuf,
					       uint16_t tlvlen,
					       tDot11fTLVreduced_wan_metrics *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp11__;
	pDst->present = 1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp11__ = *pBuf;
	pBuf += 1;
	tlvlen -= 1;
	pDst->downlink_av_cap = tmp11__ >> 0 & 0xf;
	pDst->uplink_av_cap = tmp11__ >> 4 & 0xf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_reduced_wan_metrics. */

#define SigTlvreduced_wan_metrics (0x0031)


uint32_t dot11f_unpack_tlv_rssi_assoc_rej(tpAniSirGlobal pCtx,
					  uint8_t *pBuf,
					  uint16_t tlvlen,
					  tDot11fTLVrssi_assoc_rej *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->delta_rssi = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	if (unlikely(tlvlen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->retry_delay = *pBuf;
	pBuf += 1;
	tlvlen -= (uint8_t)1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_rssi_assoc_rej. */

#define SigTlvrssi_assoc_rej (0x0032)


#define SigTlvtrans_reasonp_attr (0x0033)


#define SigTlvtrans_rejectp_attr (0x0034)


#define SigTlvtransition_reason (0x0035)


#define SigTlvtransition_reject_reason (0x0036)


#define SigTlvvht_mcs11_attr (0x0037)


uint32_t dot11f_unpack_tlv_p2_p_interface(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint16_t tlvlen,
					 tDot11fTLVP2PInterface *pDst)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	pDst->present = 1;
	if (unlikely(tlvlen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->P2PDeviceAddress, pBuf, 6);
	pBuf += 6;
	tlvlen -= (uint8_t)6;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_tlv_p2_p_interface. */

#define SigTlvP2PInterface (0x0038)


#define SigTlvP2PManageability (0x0039)


uint32_t dot11f_unpack_ie_gtk(tpAniSirGlobal pCtx,
			      uint8_t *pBuf,
			      uint8_t ielen,
			      tDot11fIEGTK *pDst,
			      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint16_t tmp12__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp12__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->keyId = tmp12__ >> 0 & 0x3;
	pDst->reserved = tmp12__ >> 2 & 0x3feb;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->keyLength = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 8)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->RSC, pBuf, 8);
	pBuf += 8;
	ielen -= (uint8_t)8;
	pDst->num_key = (uint8_t)(ielen);
	if (ielen > 32) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->key, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_gtk. */

#define SigIeGTK (0x0001)


uint32_t dot11f_unpack_ie_igtk(tpAniSirGlobal pCtx,
			       uint8_t *pBuf,
			       uint8_t ielen,
			       tDot11fIEIGTK *pDst,
			       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->keyID, pBuf, 2);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->IPN, pBuf, 6);
	pBuf += 6;
	ielen -= (uint8_t)6;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->keyLength = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 24)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->key, pBuf, 24);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_igtk. */

#define SigIeIGTK (0x0002)


uint32_t dot11f_unpack_ie_r0_kh_id(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint8_t ielen,
				  tDot11fIER0KH_ID *pDst,
				  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_PMK_R0_ID = (uint8_t)(ielen);
	if (ielen > 48) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->PMK_R0_ID, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_r0_kh_id. */

#define SigIeR0KH_ID (0x0003)


uint32_t dot11f_unpack_ie_r1_kh_id(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint8_t ielen,
				  tDot11fIER1KH_ID *pDst,
				  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->PMK_R1_ID, pBuf, 6);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_r1_kh_id. */

#define SigIeR1KH_ID (0x0004)


uint32_t dot11f_unpack_ie_ap_channel_report(tpAniSirGlobal pCtx,
					  uint8_t *pBuf,
					  uint8_t ielen,
					  tDot11fIEAPChannelReport *pDst,
					  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->regulatoryClass = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	pDst->num_channelList = (uint8_t)(ielen);
	if (ielen > 50) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->channelList, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ap_channel_report. */

#define SigIeAPChannelReport (0x0005)


uint32_t dot11f_unpack_ie_bcn_reporting_detail(tpAniSirGlobal pCtx,
					     uint8_t *pBuf,
					     uint8_t ielen,
					     tDot11fIEBcnReportingDetail *pDst,
					     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->reportingDetail = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_bcn_reporting_detail. */

#define SigIeBcnReportingDetail (0x0006)


uint32_t dot11f_unpack_ie_beacon_report_frm_body(tpAniSirGlobal pCtx,
					      uint8_t *pBuf,
					      uint8_t ielen,
					      tDot11fIEBeaconReportFrmBody *pDst,
					      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_reportedFields = (uint8_t)(ielen);
	if (ielen > 224) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->reportedFields, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_beacon_report_frm_body. */

#define SigIeBeaconReportFrmBody (0x0007)


uint32_t dot11f_unpack_ie_beacon_reporting(tpAniSirGlobal pCtx,
					  uint8_t *pBuf,
					  uint8_t ielen,
					  tDot11fIEBeaconReporting *pDst,
					  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->reportingCondition = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->threshold = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_beacon_reporting. */

#define SigIeBeaconReporting (0x0008)


uint32_t dot11f_unpack_ie_condensed_country_str(tpAniSirGlobal pCtx,
					      uint8_t *pBuf,
					      uint8_t ielen,
					      tDot11fIECondensedCountryStr *pDst,
					      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->countryStr, pBuf, 2);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_condensed_country_str. */

#define SigIeCondensedCountryStr (0x0009)


uint32_t dot11f_unpack_ie_measurement_pilot(tpAniSirGlobal pCtx,
					   uint8_t *pBuf,
					   uint8_t ielen,
					   tDot11fIEMeasurementPilot *pDst,
					   bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->measurementPilot = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	pDst->num_vendorSpecific = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->vendorSpecific, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_measurement_pilot. */

#define SigIeMeasurementPilot (0x000a)


uint32_t dot11f_unpack_ie_multi_bssid(tpAniSirGlobal pCtx,
				     uint8_t *pBuf,
				     uint8_t ielen,
				     tDot11fIEMultiBssid *pDst,
				     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->maxBSSIDIndicator = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	pDst->num_vendorSpecific = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->vendorSpecific, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_multi_bssid. */

#define SigIeMultiBssid (0x000b)


uint32_t dot11f_unpack_ie_ric_data(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint8_t ielen,
				  tDot11fIERICData *pDst,
				  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->Identifier = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->resourceDescCount = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->statusCode, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ric_data. */

#define SigIeRICData (0x000c)


uint32_t dot11f_unpack_ie_ric_descriptor(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIERICDescriptor *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->resourceType = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	pDst->num_variableData = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->variableData, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ric_descriptor. */

#define SigIeRICDescriptor (0x000d)


uint32_t dot11f_unpack_ie_rrm_enabled_cap(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIERRMEnabledCap *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp13__;
	uint8_t tmp14__;
	uint8_t tmp15__;
	uint8_t tmp16__;
	uint8_t tmp17__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp13__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->LinkMeasurement = tmp13__ >> 0 & 0x1;
	pDst->NeighborRpt = tmp13__ >> 1 & 0x1;
	pDst->parallel = tmp13__ >> 2 & 0x1;
	pDst->repeated = tmp13__ >> 3 & 0x1;
	pDst->BeaconPassive = tmp13__ >> 4 & 0x1;
	pDst->BeaconActive = tmp13__ >> 5 & 0x1;
	pDst->BeaconTable = tmp13__ >> 6 & 0x1;
	pDst->BeaconRepCond = tmp13__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp14__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->FrameMeasurement = tmp14__ >> 0 & 0x1;
	pDst->ChannelLoad = tmp14__ >> 1 & 0x1;
	pDst->NoiseHistogram = tmp14__ >> 2 & 0x1;
	pDst->statistics = tmp14__ >> 3 & 0x1;
	pDst->LCIMeasurement = tmp14__ >> 4 & 0x1;
	pDst->LCIAzimuth = tmp14__ >> 5 & 0x1;
	pDst->TCMCapability = tmp14__ >> 6 & 0x1;
	pDst->triggeredTCM = tmp14__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp15__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->APChanReport = tmp15__ >> 0 & 0x1;
	pDst->RRMMIBEnabled = tmp15__ >> 1 & 0x1;
	pDst->operatingChanMax = tmp15__ >> 2 & 0x7;
	pDst->nonOperatinChanMax = tmp15__ >> 5 & 0x7;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp16__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->MeasurementPilot = tmp16__ >> 0 & 0x7;
	pDst->MeasurementPilotEnabled = tmp16__ >> 3 & 0x1;
	pDst->NeighborTSFOffset = tmp16__ >> 4 & 0x1;
	pDst->RCPIMeasurement = tmp16__ >> 5 & 0x1;
	pDst->RSNIMeasurement = tmp16__ >> 6 & 0x1;
	pDst->BssAvgAccessDelay = tmp16__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp17__ = *pBuf;
	pDst->BSSAvailAdmission = tmp17__ >> 0 & 0x1;
	pDst->AntennaInformation = tmp17__ >> 1 & 0x1;
	pDst->fine_time_meas_rpt = tmp17__ >> 2 & 0x1;
	pDst->lci_capability = tmp17__ >> 3 & 0x1;
	pDst->reserved = tmp17__ >> 4 & 0xf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_rrm_enabled_cap. */

#define SigIeRRMEnabledCap (0x000e)


uint32_t dot11f_unpack_ie_requested_info(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIERequestedInfo *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_requested_eids = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->requested_eids, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_requested_info. */

#define SigIeRequestedInfo (0x000f)


uint32_t dot11f_unpack_ie_ssid(tpAniSirGlobal pCtx,
			       uint8_t *pBuf,
			       uint8_t ielen,
			       tDot11fIESSID *pDst,
			       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present) {
		status = DOT11F_DUPLICATE_IE;
		return status;
	}
	pDst->present = 1;
	pDst->num_ssid = (uint8_t)(ielen);
	if (ielen > 32) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->ssid, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ssid. */

#define SigIeSSID (0x0010)


uint32_t dot11f_unpack_ie_schedule(tpAniSirGlobal pCtx,
				   uint8_t *pBuf,
				   uint8_t ielen,
				   tDot11fIESchedule *pDst,
				   bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint16_t tmp18__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp18__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->aggregation = tmp18__ >> 0 & 0x1;
	pDst->tsid = tmp18__ >> 1 & 0xf;
	pDst->direction = tmp18__ >> 5 & 0x3;
	pDst->reserved = tmp18__ >> 7 & 0x1ff;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->service_start_time, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->service_interval, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->max_service_dur, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->spec_interval, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_schedule. */

#define SigIeSchedule (0x0011)


uint32_t dot11f_unpack_ie_tclas(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIETCLAS *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->user_priority = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->classifier_type = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->classifier_mask = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	switch (pDst->classifier_type) {
	case 0:
		if (unlikely(ielen < 6)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->info.EthParams.source, pBuf, 6);
		pBuf += 6;
		ielen -= (uint8_t)6;
		if (unlikely(ielen < 6)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->info.EthParams.dest, pBuf, 6);
		pBuf += 6;
		ielen -= (uint8_t)6;
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->info.EthParams.type, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
		break;
	case 1:
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->info.IpParams.version = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		switch (pDst->info.IpParams.version) {
		case 4:
			if (unlikely(ielen < 4)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			DOT11F_MEMCPY(pCtx, pDst->info.IpParams.params.IpV4Params.source, pBuf, 4);
			pBuf += 4;
			ielen -= (uint8_t)4;
			if (unlikely(ielen < 4)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			DOT11F_MEMCPY(pCtx, pDst->info.IpParams.params.IpV4Params.dest, pBuf, 4);
			pBuf += 4;
			ielen -= (uint8_t)4;
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->info.IpParams.params.IpV4Params.src_port, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->info.IpParams.params.IpV4Params.dest_port, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->info.IpParams.params.IpV4Params.DSCP = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->info.IpParams.params.IpV4Params.proto = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->info.IpParams.params.IpV4Params.reserved = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			break;
		case 6:
			if (unlikely(ielen < 16)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			DOT11F_MEMCPY(pCtx, pDst->info.IpParams.params.IpV6Params.source, pBuf, 16);
			pBuf += 16;
			ielen -= (uint8_t)16;
			if (unlikely(ielen < 16)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			DOT11F_MEMCPY(pCtx, pDst->info.IpParams.params.IpV6Params.dest, pBuf, 16);
			pBuf += 16;
			ielen -= (uint8_t)16;
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->info.IpParams.params.IpV6Params.src_port, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->info.IpParams.params.IpV6Params.dest_port, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			if (unlikely(ielen < 3)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			DOT11F_MEMCPY(pCtx, pDst->info.IpParams.params.IpV6Params.flow_label, pBuf, 3);
			pBuf += 3;
			ielen -= (uint8_t)3;
			break;
		}
		break;
	case 2:
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->info.Params8021dq.tag_type, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
		break;
	}
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_tclas. */

#define SigIeTCLAS (0x0012)


#define SigIeTCLASSPROC (0x0013)


uint32_t dot11f_unpack_ie_ts_delay(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint8_t ielen,
				  tDot11fIETSDelay *pDst,
				  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->delay, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ts_delay. */

#define SigIeTSDelay (0x0014)


uint32_t dot11f_unpack_ie_tsf_info(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint8_t ielen,
				  tDot11fIETSFInfo *pDst,
				  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->TsfOffset, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->BeaconIntvl, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_tsf_info. */

#define SigIeTSFInfo (0x0015)


uint32_t dot11f_unpack_ie_tspec(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIETSPEC *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint16_t tmp19__;
	uint8_t tmp20__;
	uint16_t tmp21__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp19__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->traffic_type = tmp19__ >> 0 & 0x1;
	pDst->tsid = tmp19__ >> 1 & 0xf;
	pDst->direction = tmp19__ >> 5 & 0x3;
	pDst->access_policy = tmp19__ >> 7 & 0x3;
	pDst->aggregation = tmp19__ >> 9 & 0x1;
	pDst->psb = tmp19__ >> 10 & 0x1;
	pDst->user_priority = tmp19__ >> 11 & 0x7;
	pDst->tsinfo_ack_pol = tmp19__ >> 14 & 0x3;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp20__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->schedule = tmp20__ >> 0 & 0x1;
	pDst->unused = tmp20__ >> 1 & 0x7f;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp21__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->size = tmp21__ >> 0 & 0x7fff;
	pDst->fixed = tmp21__ >> 15 & 0x1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->max_msdu_size, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->min_service_int, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->max_service_int, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->inactivity_int, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->suspension_int, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->service_start_time, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->min_data_rate, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->mean_data_rate, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->peak_data_rate, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->burst_size, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->delay_bound, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->min_phy_rate, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->surplus_bw_allowance, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->medium_time, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_tspec. */

#define SigIeTSPEC (0x0016)


uint32_t dot11f_unpack_ie_vht_caps(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint8_t ielen,
				  tDot11fIEVHTCaps *pDst,
				  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t tmp22__;
	uint16_t tmp23__;
	uint16_t tmp24__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &tmp22__, pBuf, 0);
	pBuf += 4;
	ielen -= 4;
	pDst->maxMPDULen = tmp22__ >> 0 & 0x3;
	pDst->supportedChannelWidthSet = tmp22__ >> 2 & 0x3;
	pDst->ldpcCodingCap = tmp22__ >> 4 & 0x1;
	pDst->shortGI80MHz = tmp22__ >> 5 & 0x1;
	pDst->shortGI160and80plus80MHz = tmp22__ >> 6 & 0x1;
	pDst->txSTBC = tmp22__ >> 7 & 0x1;
	pDst->rxSTBC = tmp22__ >> 8 & 0x7;
	pDst->suBeamFormerCap = tmp22__ >> 11 & 0x1;
	pDst->suBeamformeeCap = tmp22__ >> 12 & 0x1;
	pDst->csnofBeamformerAntSup = tmp22__ >> 13 & 0x7;
	pDst->numSoundingDim = tmp22__ >> 16 & 0x7;
	pDst->muBeamformerCap = tmp22__ >> 19 & 0x1;
	pDst->muBeamformeeCap = tmp22__ >> 20 & 0x1;
	pDst->vhtTXOPPS = tmp22__ >> 21 & 0x1;
	pDst->htcVHTCap = tmp22__ >> 22 & 0x1;
	pDst->maxAMPDULenExp = tmp22__ >> 23 & 0x7;
	pDst->vhtLinkAdaptCap = tmp22__ >> 26 & 0x3;
	pDst->rxAntPattern = tmp22__ >> 28 & 0x1;
	pDst->txAntPattern = tmp22__ >> 29 & 0x1;
	pDst->extended_nss_bw_supp = tmp22__ >> 30 & 0x3;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->rxMCSMap, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp23__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->rxHighSupDataRate = tmp23__ >> 0 & 0x1fff;
	pDst->max_nsts_total = tmp23__ >> 13 & 0x7;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->txMCSMap, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp24__, pBuf, 0);
	pDst->txSupDataRate = tmp24__ >> 0 & 0x1fff;
	pDst->vht_extended_nss_bw_cap = tmp24__ >> 13 & 0x1;
	pDst->reserved = tmp24__ >> 14 & 0x3;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_vht_caps. */

#define SigIeVHTCaps (0x0017)


uint32_t dot11f_unpack_ie_vht_operation(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint8_t ielen,
				       tDot11fIEVHTOperation *pDst,
				       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->chanWidth = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->chan_center_freq_seg0 = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->chan_center_freq_seg1 = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->basicMCSSet, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_vht_operation. */

#define SigIeVHTOperation (0x0018)


uint32_t dot11f_unpack_ie_wmm_schedule(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEWMMSchedule *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint16_t tmp25__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->version = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (pDst->version != 0x1) {
		pDst->present = 0;
		return status | DOT11F_BAD_FIXED_VALUE;
	}
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp25__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->aggregation = tmp25__ >> 0 & 0x1;
	pDst->tsid = tmp25__ >> 1 & 0xf;
	pDst->direction = tmp25__ >> 5 & 0x3;
	pDst->reserved = tmp25__ >> 7 & 0x1ff;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->service_start_time, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->service_interval, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->max_service_dur, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->spec_interval, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wmm_schedule. */

#define SigIeWMMSchedule (0x0019)


uint32_t dot11f_unpack_ie_wmmtclas(tpAniSirGlobal pCtx,
				   uint8_t *pBuf,
				   uint8_t ielen,
				   tDot11fIEWMMTCLAS *pDst,
				   bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->version = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (pDst->version != 0x1) {
		pDst->present = 0;
		return status | DOT11F_BAD_FIXED_VALUE;
	}
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->user_priority = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->classifier_type = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->classifier_mask = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	switch (pDst->classifier_type) {
	case 0:
		if (unlikely(ielen < 6)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->info.EthParams.source, pBuf, 6);
		pBuf += 6;
		ielen -= (uint8_t)6;
		if (unlikely(ielen < 6)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->info.EthParams.dest, pBuf, 6);
		pBuf += 6;
		ielen -= (uint8_t)6;
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->info.EthParams.type, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
		break;
	case 1:
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->info.IpParams.version = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		switch (pDst->info.IpParams.version) {
		case 4:
			if (unlikely(ielen < 4)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			DOT11F_MEMCPY(pCtx, pDst->info.IpParams.params.IpV4Params.source, pBuf, 4);
			pBuf += 4;
			ielen -= (uint8_t)4;
			if (unlikely(ielen < 4)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			DOT11F_MEMCPY(pCtx, pDst->info.IpParams.params.IpV4Params.dest, pBuf, 4);
			pBuf += 4;
			ielen -= (uint8_t)4;
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->info.IpParams.params.IpV4Params.src_port, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->info.IpParams.params.IpV4Params.dest_port, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->info.IpParams.params.IpV4Params.DSCP = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->info.IpParams.params.IpV4Params.proto = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->info.IpParams.params.IpV4Params.reserved = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			break;
		case 6:
			if (unlikely(ielen < 16)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			DOT11F_MEMCPY(pCtx, pDst->info.IpParams.params.IpV6Params.source, pBuf, 16);
			pBuf += 16;
			ielen -= (uint8_t)16;
			if (unlikely(ielen < 16)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			DOT11F_MEMCPY(pCtx, pDst->info.IpParams.params.IpV6Params.dest, pBuf, 16);
			pBuf += 16;
			ielen -= (uint8_t)16;
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->info.IpParams.params.IpV6Params.src_port, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->info.IpParams.params.IpV6Params.dest_port, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			if (unlikely(ielen < 3)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			DOT11F_MEMCPY(pCtx, pDst->info.IpParams.params.IpV6Params.flow_label, pBuf, 3);
			pBuf += 3;
			ielen -= (uint8_t)3;
			break;
		}
		break;
	case 2:
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->info.Params8021dq.tag_type, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
		break;
	}
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wmmtclas. */

#define SigIeWMMTCLAS (0x001a)


uint32_t dot11f_unpack_ie_wmmtclasproc(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint8_t ielen,
				       tDot11fIEWMMTCLASPROC *pDst,
				       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->version = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (pDst->version != 0x1) {
		pDst->present = 0;
		return status | DOT11F_BAD_FIXED_VALUE;
	}
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->processing = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wmmtclasproc. */

#define SigIeWMMTCLASPROC (0x001b)


uint32_t dot11f_unpack_ie_wmmts_delay(tpAniSirGlobal pCtx,
				     uint8_t *pBuf,
				     uint8_t ielen,
				     tDot11fIEWMMTSDelay *pDst,
				     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->version = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (pDst->version != 0x1) {
		pDst->present = 0;
		return status | DOT11F_BAD_FIXED_VALUE;
	}
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->delay, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wmmts_delay. */

#define SigIeWMMTSDelay (0x001c)


uint32_t dot11f_unpack_ie_wmmtspec(tpAniSirGlobal pCtx,
				   uint8_t *pBuf,
				   uint8_t ielen,
				   tDot11fIEWMMTSPEC *pDst,
				   bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint16_t tmp26__;
	uint8_t tmp27__;
	uint16_t tmp28__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->version = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (pDst->version != 0x1) {
		pDst->present = 0;
		return status | DOT11F_BAD_FIXED_VALUE;
	}
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp26__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->traffic_type = tmp26__ >> 0 & 0x1;
	pDst->tsid = tmp26__ >> 1 & 0xf;
	pDst->direction = tmp26__ >> 5 & 0x3;
	pDst->access_policy = tmp26__ >> 7 & 0x3;
	pDst->aggregation = tmp26__ >> 9 & 0x1;
	pDst->psb = tmp26__ >> 10 & 0x1;
	pDst->user_priority = tmp26__ >> 11 & 0x7;
	pDst->tsinfo_ack_pol = tmp26__ >> 14 & 0x3;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp27__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->tsinfo_rsvd = tmp27__ >> 0 & 0x7f;
	pDst->burst_size_defn = tmp27__ >> 7 & 0x1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp28__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->size = tmp28__ >> 0 & 0x7fff;
	pDst->fixed = tmp28__ >> 15 & 0x1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->max_msdu_size, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->min_service_int, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->max_service_int, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->inactivity_int, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->suspension_int, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->service_start_time, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->min_data_rate, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->mean_data_rate, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->peak_data_rate, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->burst_size, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->delay_bound, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->min_phy_rate, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->surplus_bw_allowance, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->medium_time, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wmmtspec. */

#define SigIeWMMTSPEC (0x001d)


uint32_t dot11f_unpack_ie_wider_bw_chan_switch_ann(tpAniSirGlobal pCtx,
					       uint8_t *pBuf,
					       uint8_t ielen,
					       tDot11fIEWiderBWChanSwitchAnn *pDst,
					       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->newChanWidth = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->newCenterChanFreq0 = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->newCenterChanFreq1 = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wider_bw_chan_switch_ann. */

#define SigIeWiderBWChanSwitchAnn (0x001e)


uint32_t dot11f_unpack_ie_azimuth_req(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEazimuth_req *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->request = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_azimuth_req. */

#define SigIeazimuth_req (0x001f)


uint32_t dot11f_unpack_ie_beacon_report_frm_body_fragment_id(tpAniSirGlobal pCtx,
							     uint8_t *pBuf,
							     uint8_t ielen,
							     tDot11fIEbeacon_report_frm_body_fragment_id *pDst,
							     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint16_t tmp29__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp29__, pBuf, 0);
	pDst->beacon_report_id = tmp29__ >> 0 & 0xff;
	pDst->fragment_id_number = tmp29__ >> 8 & 0x7f;
	pDst->more_fragments = tmp29__ >> 15 & 0x1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_beacon_report_frm_body_fragment_id. */

#define SigIebeacon_report_frm_body_fragment_id (0x0020)


uint32_t dot11f_unpack_ie_last_beacon_report_indication(tpAniSirGlobal pCtx,
							 uint8_t *pBuf,
							 uint8_t ielen,
							 tDot11fIElast_beacon_report_indication *pDst,
							 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->last_fragment = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_last_beacon_report_indication. */

#define SigIelast_beacon_report_indication (0x0021)


uint32_t dot11f_unpack_ie_max_age(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint8_t ielen,
				  tDot11fIEmax_age *pDst,
				  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->max_age, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_max_age. */

#define SigIemax_age (0x0022)


uint32_t dot11f_unpack_ie_mscs_status(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEmscs_status *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->status_code = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_mscs_status. */

#define SigIemscs_status (0x0023)


static const tFFDefn FFS_neighbor_rpt[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_neighbor_rpt[] = {
	{ offsetof(tDot11fIEneighbor_rpt, TSFInfo), offsetof(tDot11fIETSFInfo,
	present), 0, "TSFInfo", 0, 6, 6, SigIeTSFInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TSFINFO, 0, 0, },
	{ offsetof(tDot11fIEneighbor_rpt, CondensedCountryStr),
	offsetof(tDot11fIECondensedCountryStr, present), 0, "CondensedCountryStr",
	0, 4, 4, SigIeCondensedCountryStr, {0, 0, 0, 0, 0},
	0, DOT11F_EID_CONDENSEDCOUNTRYSTR, 0, 0, },
	{ offsetof(tDot11fIEneighbor_rpt, MeasurementPilot),
	offsetof(tDot11fIEMeasurementPilot, present), 0, "MeasurementPilot",
	0, 3, 258, SigIeMeasurementPilot, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MEASUREMENTPILOT, 0, 0, },
	{ offsetof(tDot11fIEneighbor_rpt, RRMEnabledCap),
	offsetof(tDot11fIERRMEnabledCap, present), 0, "RRMEnabledCap",
	0, 7, 7, SigIeRRMEnabledCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RRMENABLEDCAP, 0, 0, },
	{ offsetof(tDot11fIEneighbor_rpt, MultiBssid),
	offsetof(tDot11fIEMultiBssid, present), 0, "MultiBssid",
	0, 3, 258, SigIeMultiBssid, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MULTIBSSID, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },
};

uint32_t dot11f_unpack_ie_neighbor_rpt(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint8_t ielen,
				       tDot11fIEneighbor_rpt *pDst,
				       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp30__;
	uint8_t tmp31__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->bssid, pBuf, 6);
	pBuf += 6;
	ielen -= (uint8_t)6;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp30__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->APReachability = tmp30__ >> 0 & 0x3;
	pDst->Security = tmp30__ >> 2 & 0x1;
	pDst->KeyScope = tmp30__ >> 3 & 0x1;
	pDst->SpecMgmtCap = tmp30__ >> 4 & 0x1;
	pDst->QosCap = tmp30__ >> 5 & 0x1;
	pDst->apsd = tmp30__ >> 6 & 0x1;
	pDst->rrm = tmp30__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp31__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->DelayedBA = tmp31__ >> 0 & 0x1;
	pDst->ImmBA = tmp31__ >> 1 & 0x1;
	pDst->MobilityDomain = tmp31__ >> 2 & 0x1;
	pDst->reserved = tmp31__ >> 3 & 0x1f;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->reserved1, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->regulatoryClass = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->channel = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->PhyType = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	(void)pCtx;
	status |= unpack_core(pCtx,
				pBuf,
				ielen,
				FFS_neighbor_rpt,
				IES_neighbor_rpt,
				(uint8_t *)pDst,
				sizeof(*pDst),
				append_ie);
	return status;
} /* End dot11f_unpack_ie_neighbor_rpt. */

#define SigIeneighbor_rpt (0x0024)


uint32_t dot11f_unpack_ie_req_mac_addr(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint8_t ielen,
				       tDot11fIEreq_mac_addr *pDst,
				       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->addr, pBuf, 6);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_req_mac_addr. */

#define SigIereq_mac_addr (0x0025)


uint32_t dot11f_unpack_ie_tclas_mask(tpAniSirGlobal pCtx,
				     uint8_t *pBuf,
				     uint8_t ielen,
				     tDot11fIEtclas_mask *pDst,
				     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->classifier_type = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->classifier_mask = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	switch (pDst->classifier_type) {
	case 4:
		if (unlikely(ielen < 16)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->info.ip_param.reserved, pBuf, 16);
		pBuf += 16;
		ielen -= (uint8_t)16;
		break;
	}
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_tclas_mask. */

#define SigIetclas_mask (0x0026)


uint32_t dot11f_unpack_ie_tgt_mac_addr(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint8_t ielen,
				       tDot11fIEtgt_mac_addr *pDst,
				       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->addr, pBuf, 6);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_tgt_mac_addr. */

#define SigIetgt_mac_addr (0x0027)


uint32_t dot11f_unpack_ie_transmit_power_env(tpAniSirGlobal pCtx,
					     uint8_t *pBuf,
					     uint8_t ielen,
					     tDot11fIEtransmit_power_env *pDst,
					     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp32__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp32__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->max_tx_pwr_count = tmp32__ >> 0 & 0x7;
	pDst->max_tx_pwr_interpret = tmp32__ >> 3 & 0x7;
	pDst->max_tx_pwr_category = tmp32__ >> 6 & 0x3;
	pDst->num_tx_power = (uint8_t)(ielen);
	if (ielen > 8) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->tx_power, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_transmit_power_env. */

#define SigIetransmit_power_env (0x0028)


uint32_t dot11f_unpack_ie_aid(tpAniSirGlobal pCtx,
			      uint8_t *pBuf,
			      uint8_t ielen,
			      tDot11fIEAID *pDst,
			      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->assocId, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_aid. */

#define SigIeAID (0x0029)


uint32_t dot11f_unpack_ie_cf_params(tpAniSirGlobal pCtx,
				   uint8_t *pBuf,
				   uint8_t ielen,
				   tDot11fIECFParams *pDst,
				   bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->cfp_count = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->cfp_period = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->cfp_maxduration, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->cfp_durremaining, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_cf_params. */

#define SigIeCFParams (0x002a)


uint32_t dot11f_unpack_ie_challenge_text(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEChallengeText *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_text = (uint8_t)(ielen);
	if (ielen > 253) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->text, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_challenge_text. */

#define SigIeChallengeText (0x002b)


uint32_t dot11f_unpack_ie_chan_switch_ann(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEChanSwitchAnn *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->switchMode = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->newChannel = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->switchCount = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_chan_switch_ann. */

#define SigIeChanSwitchAnn (0x002c)


static const tFFDefn FFS_ChannelSwitchWrapper[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_ChannelSwitchWrapper[] = {
	{ offsetof(tDot11fIEChannelSwitchWrapper, WiderBWChanSwitchAnn),
	offsetof(tDot11fIEWiderBWChanSwitchAnn, present), 0,
	"WiderBWChanSwitchAnn", 0, 5, 5, SigIeWiderBWChanSwitchAnn,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_WIDERBWCHANSWITCHANN, 0, 0, },
	{ offsetof(tDot11fIEChannelSwitchWrapper, transmit_power_env),
	offsetof(tDot11fIEtransmit_power_env, present), 0, "transmit_power_env",
	0, 4, 11, SigIetransmit_power_env, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TRANSMIT_POWER_ENV, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },
};

uint32_t dot11f_unpack_ie_channel_switch_wrapper(tpAniSirGlobal pCtx,
					       uint8_t *pBuf,
					       uint8_t ielen,
					       tDot11fIEChannelSwitchWrapper *pDst,
					       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	(void)pCtx;
	status |= unpack_core(pCtx,
				pBuf,
				ielen,
				FFS_ChannelSwitchWrapper,
				IES_ChannelSwitchWrapper,
				(uint8_t *)pDst,
				sizeof(*pDst),
				append_ie);
	return status;
} /* End dot11f_unpack_ie_channel_switch_wrapper. */

#define SigIeChannelSwitchWrapper (0x002d)


uint32_t dot11f_unpack_ie_country(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint8_t ielen,
				  tDot11fIECountry *pDst,
				  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 3)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->country, pBuf, 3);
	pBuf += 3;
	ielen -= (uint8_t)3;
	if (unlikely(ielen < 3)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->first_triplet, pBuf, 3);
	pBuf += 3;
	ielen -= (uint8_t)3;
	if (!ielen) {
		pDst->num_more_triplets = 0U;
		return 0U;
	} else {
		pDst->num_more_triplets = (uint8_t)(ielen / 3);
		if (ielen / 3 > 80) {
			pDst->present = 0;
			return DOT11F_SKIPPED_BAD_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->more_triplets, pBuf, (ielen));
	}
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_country. */

#define SigIeCountry (0x002e)


#define SigIeDSParams (0x002f)


uint32_t dot11f_unpack_ie_edca_param_set(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint8_t ielen,
				       tDot11fIEEDCAParamSet *pDst,
				       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp33__;
	uint8_t tmp34__;
	uint8_t tmp35__;
	uint8_t tmp36__;
	uint8_t tmp37__;
	uint8_t tmp38__;
	uint8_t tmp39__;
	uint8_t tmp40__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->qos = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->reserved = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp33__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acbe_aifsn = tmp33__ >> 0 & 0xf;
	pDst->acbe_acm = tmp33__ >> 4 & 0x1;
	pDst->acbe_aci = tmp33__ >> 5 & 0x3;
	pDst->unused1 = tmp33__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp34__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acbe_acwmin = tmp34__ >> 0 & 0xf;
	pDst->acbe_acwmax = tmp34__ >> 4 & 0xf;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->acbe_txoplimit, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp35__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acbk_aifsn = tmp35__ >> 0 & 0xf;
	pDst->acbk_acm = tmp35__ >> 4 & 0x1;
	pDst->acbk_aci = tmp35__ >> 5 & 0x3;
	pDst->unused2 = tmp35__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp36__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acbk_acwmin = tmp36__ >> 0 & 0xf;
	pDst->acbk_acwmax = tmp36__ >> 4 & 0xf;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->acbk_txoplimit, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp37__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acvi_aifsn = tmp37__ >> 0 & 0xf;
	pDst->acvi_acm = tmp37__ >> 4 & 0x1;
	pDst->acvi_aci = tmp37__ >> 5 & 0x3;
	pDst->unused3 = tmp37__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp38__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acvi_acwmin = tmp38__ >> 0 & 0xf;
	pDst->acvi_acwmax = tmp38__ >> 4 & 0xf;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->acvi_txoplimit, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp39__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acvo_aifsn = tmp39__ >> 0 & 0xf;
	pDst->acvo_acm = tmp39__ >> 4 & 0x1;
	pDst->acvo_aci = tmp39__ >> 5 & 0x3;
	pDst->unused4 = tmp39__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp40__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acvo_acwmin = tmp40__ >> 0 & 0xf;
	pDst->acvo_acwmax = tmp40__ >> 4 & 0xf;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->acvo_txoplimit, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_edca_param_set. */

#define SigIeEDCAParamSet (0x0030)


uint32_t dot11f_unpack_ie_erp_info(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint8_t ielen,
				  tDot11fIEERPInfo *pDst,
				  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp41__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp41__ = *pBuf;
	pDst->non_erp_present = tmp41__ >> 0 & 0x1;
	pDst->use_prot = tmp41__ >> 1 & 0x1;
	pDst->barker_preamble = tmp41__ >> 2 & 0x1;
	pDst->unused = tmp41__ >> 3 & 0x1f;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_erp_info. */

#define SigIeERPInfo (0x0031)


uint32_t dot11f_unpack_ie_ese_cckm_opaque(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEESECckmOpaque *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_data = (uint8_t)(ielen);
	if (ielen > 20) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ese_cckm_opaque. */

#define SigIeESECckmOpaque (0x0032)


uint32_t dot11f_unpack_ie_ese_rad_mgmt_cap(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEESERadMgmtCap *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp42__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->mgmt_state = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp42__ = *pBuf;
	pDst->mbssid_mask = tmp42__ >> 0 & 0x7;
	pDst->reserved = tmp42__ >> 3 & 0x1f;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ese_rad_mgmt_cap. */

#define SigIeESERadMgmtCap (0x0033)


uint32_t dot11f_unpack_ie_ese_traf_strm_met(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEESETrafStrmMet *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->tsid = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->state = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->msmt_interval, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ese_traf_strm_met. */

#define SigIeESETrafStrmMet (0x0034)


uint32_t dot11f_unpack_ie_ese_traf_strm_rate_set(tpAniSirGlobal pCtx,
					     uint8_t *pBuf,
					     uint8_t ielen,
					     tDot11fIEESETrafStrmRateSet *pDst,
					     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->tsid = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	pDst->num_tsrates = (uint8_t)(ielen);
	if (ielen > 8) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->tsrates, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ese_traf_strm_rate_set. */

#define SigIeESETrafStrmRateSet (0x0035)


uint32_t dot11f_unpack_ie_ese_txmit_power(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEESETxmitPower *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->power_limit = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->reserved = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ese_txmit_power. */

#define SigIeESETxmitPower (0x0036)


uint32_t dot11f_unpack_ie_ese_version(tpAniSirGlobal pCtx,
				     uint8_t *pBuf,
				     uint8_t ielen,
				     tDot11fIEESEVersion *pDst,
				     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->version = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ese_version. */

#define SigIeESEVersion (0x0037)


uint32_t dot11f_unpack_ie_ext_cap(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIEExtCap *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;

	if (!ielen) /* Check to ensure copying of ielen bytes */
		goto endUnpackIeExtCap;
	pDst->num_bytes = (uint8_t)(ielen);
	if (ielen > 15) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->bytes, pBuf, (ielen));

endUnpackIeExtCap:
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ext_cap. */

#define SigIeExtCap (0x0038)


uint32_t dot11f_unpack_ie_ext_supp_rates(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint8_t ielen,
				       tDot11fIEExtSuppRates *pDst,
				       bool append_ie)
{
	uint8_t i;
	uint8_t rate_indx = 0;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	for (i = 0; i < ielen; i++) {
		if ((DOT11F_IS_BG_RATE(pBuf[i] & 0x7F)) &&
			(rate_indx < 12)) {
			pDst->rates[rate_indx++] = pBuf[i];
		}
	}

	if (rate_indx == 0) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	pDst->num_rates = rate_indx;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ext_supp_rates. */

#define SigIeExtSuppRates (0x0039)


uint32_t dot11f_unpack_ie_fh_param_set(tpAniSirGlobal pCtx,
				     uint8_t *pBuf,
				     uint8_t ielen,
				     tDot11fIEFHParamSet *pDst,
				     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->dwell_time, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->hop_set = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->hop_pattern = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->hop_index = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fh_param_set. */

#define SigIeFHParamSet (0x003a)


uint32_t dot11f_unpack_ie_fh_params(tpAniSirGlobal pCtx,
				   uint8_t *pBuf,
				   uint8_t ielen,
				   tDot11fIEFHParams *pDst,
				   bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->radix = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->nchannels = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fh_params. */

#define SigIeFHParams (0x003b)


uint32_t dot11f_unpack_ie_fh_patt_table(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEFHPattTable *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->flag = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->nsets = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->modulus = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->offset = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	pDst->num_randtable = (uint8_t)(ielen);
	if (ielen > 251) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->randtable, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fh_patt_table. */

#define SigIeFHPattTable (0x003c)


static const tFFDefn FFS_FTInfo[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_FTInfo[] = {
	{ offsetof(tDot11fIEFTInfo, R1KH_ID), offsetof(tDot11fIER1KH_ID, present),
	0, "R1KH_ID", 0, 8, 8, SigIeR1KH_ID, {0, 0, 0, 0, 0},
	0, DOT11F_EID_R1KH_ID, 0, 0, },
	{ offsetof(tDot11fIEFTInfo, GTK), offsetof(tDot11fIEGTK, present), 0, "GTK",
	0, 18, 45, SigIeGTK, {0, 0, 0, 0, 0}, 0, DOT11F_EID_GTK, 0, 0, },
	{ offsetof(tDot11fIEFTInfo, R0KH_ID), offsetof(tDot11fIER0KH_ID, present),
	0, "R0KH_ID", 0, 3, 50, SigIeR0KH_ID, {0, 0, 0, 0, 0},
	0, DOT11F_EID_R0KH_ID, 0, 0, },
	{ offsetof(tDot11fIEFTInfo, IGTK), offsetof(tDot11fIEIGTK, present), 0,
	"IGTK", 0, 35, 35, SigIeIGTK, {0, 0, 0, 0, 0},
	0, DOT11F_EID_IGTK, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },
};

uint32_t dot11f_unpack_ie_ft_info(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIEFTInfo *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint16_t tmp43__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp43__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->reserved = tmp43__ >> 0 & 0xff;
	pDst->IECount = tmp43__ >> 8 & 0xff;
	if (unlikely(ielen < 16)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->MIC, pBuf, 16);
	pBuf += 16;
	ielen -= (uint8_t)16;
	if (unlikely(ielen < 32)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->Anonce, pBuf, 32);
	pBuf += 32;
	ielen -= (uint8_t)32;
	if (unlikely(ielen < 32)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->Snonce, pBuf, 32);
	pBuf += 32;
	ielen -= (uint8_t)32;
	(void)pCtx;
	status |= unpack_core(pCtx,
				pBuf,
				ielen,
				FFS_FTInfo,
				IES_FTInfo,
				(uint8_t *)pDst,
				sizeof(*pDst),
				append_ie);
	return status;
} /* End dot11f_unpack_ie_ft_info. */

#define SigIeFTInfo (0x003d)


uint32_t dot11f_unpack_ie_ht_caps(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIEHTCaps *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint16_t tmp44__;
	uint8_t tmp45__;
	uint16_t tmp46__;
	uint32_t tmp47__;
	uint8_t tmp48__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp44__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->advCodingCap = tmp44__ >> 0 & 0x1;
	pDst->supportedChannelWidthSet = tmp44__ >> 1 & 0x1;
	pDst->mimoPowerSave = tmp44__ >> 2 & 0x3;
	pDst->greenField = tmp44__ >> 4 & 0x1;
	pDst->shortGI20MHz = tmp44__ >> 5 & 0x1;
	pDst->shortGI40MHz = tmp44__ >> 6 & 0x1;
	pDst->txSTBC = tmp44__ >> 7 & 0x1;
	pDst->rxSTBC = tmp44__ >> 8 & 0x3;
	pDst->delayedBA = tmp44__ >> 10 & 0x1;
	pDst->maximalAMSDUsize = tmp44__ >> 11 & 0x1;
	pDst->dsssCckMode40MHz = tmp44__ >> 12 & 0x1;
	pDst->psmp = tmp44__ >> 13 & 0x1;
	pDst->stbcControlFrame = tmp44__ >> 14 & 0x1;
	pDst->lsigTXOPProtection = tmp44__ >> 15 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp45__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->maxRxAMPDUFactor = tmp45__ >> 0 & 0x3;
	pDst->mpduDensity = tmp45__ >> 2 & 0x7;
	pDst->reserved1 = tmp45__ >> 5 & 0x7;
	if (unlikely(ielen < 16)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->supportedMCSSet, pBuf, 16);
	pBuf += 16;
	ielen -= (uint8_t)16;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp46__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->pco = tmp46__ >> 0 & 0x1;
	pDst->transitionTime = tmp46__ >> 1 & 0x3;
	pDst->reserved2 = tmp46__ >> 3 & 0x1f;
	pDst->mcsFeedback = tmp46__ >> 8 & 0x3;
	pDst->reserved3 = tmp46__ >> 10 & 0x3f;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &tmp47__, pBuf, 0);
	pBuf += 4;
	ielen -= 4;
	pDst->txBF = tmp47__ >> 0 & 0x1;
	pDst->rxStaggeredSounding = tmp47__ >> 1 & 0x1;
	pDst->txStaggeredSounding = tmp47__ >> 2 & 0x1;
	pDst->rxZLF = tmp47__ >> 3 & 0x1;
	pDst->txZLF = tmp47__ >> 4 & 0x1;
	pDst->implicitTxBF = tmp47__ >> 5 & 0x1;
	pDst->calibration = tmp47__ >> 6 & 0x3;
	pDst->explicitCSITxBF = tmp47__ >> 8 & 0x1;
	pDst->explicitUncompressedSteeringMatrix = tmp47__ >> 9 & 0x1;
	pDst->explicitBFCSIFeedback = tmp47__ >> 10 & 0x7;
	pDst->explicitUncompressedSteeringMatrixFeedback = tmp47__ >> 13 & 0x7;
	pDst->explicitCompressedSteeringMatrixFeedback = tmp47__ >> 16 & 0x7;
	pDst->csiNumBFAntennae = tmp47__ >> 19 & 0x3;
	pDst->uncompressedSteeringMatrixBFAntennae = tmp47__ >> 21 & 0x3;
	pDst->compressedSteeringMatrixBFAntennae = tmp47__ >> 23 & 0x3;
	pDst->reserved4 = tmp47__ >> 25 & 0x7f;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp48__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->antennaSelection = tmp48__ >> 0 & 0x1;
	pDst->explicitCSIFeedbackTx = tmp48__ >> 1 & 0x1;
	pDst->antennaIndicesFeedbackTx = tmp48__ >> 2 & 0x1;
	pDst->explicitCSIFeedback = tmp48__ >> 3 & 0x1;
	pDst->antennaIndicesFeedback = tmp48__ >> 4 & 0x1;
	pDst->rxAS = tmp48__ >> 5 & 0x1;
	pDst->txSoundingPPDUs = tmp48__ >> 6 & 0x1;
	pDst->reserved5 = tmp48__ >> 7 & 0x1;
	pDst->num_rsvd = (uint8_t)(ielen);
	if (ielen > 32) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->rsvd, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ht_caps. */

#define SigIeHTCaps (0x003e)


uint32_t dot11f_unpack_ie_ht_info(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIEHTInfo *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp49__;
	uint16_t tmp50__;
	uint16_t tmp51__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->primaryChannel = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp49__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->secondaryChannelOffset = tmp49__ >> 0 & 0x3;
	pDst->recommendedTxWidthSet = tmp49__ >> 2 & 0x1;
	pDst->rifsMode = tmp49__ >> 3 & 0x1;
	pDst->controlledAccessOnly = tmp49__ >> 4 & 0x1;
	pDst->serviceIntervalGranularity = tmp49__ >> 5 & 0x7;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp50__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->opMode = tmp50__ >> 0 & 0x3;
	pDst->nonGFDevicesPresent = tmp50__ >> 2 & 0x1;
	pDst->transmitBurstLimit = tmp50__ >> 3 & 0x1;
	pDst->obssNonHTStaPresent = tmp50__ >> 4 & 0x1;
	pDst->chan_center_freq_seg2 = tmp50__ >> 5 & 0xff;
	pDst->reserved = tmp50__ >> 13 & 0x7;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp51__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->basicSTBCMCS = tmp51__ >> 0 & 0x7f;
	pDst->dualCTSProtection = tmp51__ >> 7 & 0x1;
	pDst->secondaryBeacon = tmp51__ >> 8 & 0x1;
	pDst->lsigTXOPProtectionFullSupport = tmp51__ >> 9 & 0x1;
	pDst->pcoActive = tmp51__ >> 10 & 0x1;
	pDst->pcoPhase = tmp51__ >> 11 & 0x1;
	pDst->reserved2 = tmp51__ >> 12 & 0xf;
	if (unlikely(ielen < 16)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->basicMCSSet, pBuf, 16);
	pBuf += 16;
	ielen -= (uint8_t)16;
	pDst->num_rsvd = (uint8_t)(ielen);
	if (ielen > 32) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->rsvd, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ht_info. */

#define SigIeHTInfo (0x003f)


uint32_t dot11f_unpack_ie_link_identifier(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIELinkIdentifier *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->bssid, pBuf, 6);
	pBuf += 6;
	ielen -= (uint8_t)6;
	if (unlikely(ielen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->InitStaAddr, pBuf, 6);
	pBuf += 6;
	ielen -= (uint8_t)6;
	if (unlikely(ielen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->RespStaAddr, pBuf, 6);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_link_identifier. */

#define SigIeLinkIdentifier (0x0040)


static const tTLVDefn TLVS_MBO_IE[] = {
	{ offsetof(tDot11fIEMBO_IE, mbo_ap_cap), offsetof(tDot11fTLVmbo_ap_cap,
	present), "mbo_ap_cap", SigTlvmbo_ap_cap, DOT11F_TLV_MBO_AP_CAP,
	0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEMBO_IE, non_prefferd_chan_rep),
	offsetof(tDot11fTLVnon_prefferd_chan_rep, present),
	"non_prefferd_chan_rep", SigTlvnon_prefferd_chan_rep,
	DOT11F_TLV_NON_PREFFERD_CHAN_REP, 0, 6, 257, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEMBO_IE, cellular_data_cap),
	offsetof(tDot11fTLVcellular_data_cap, present), "cellular_data_cap",
	SigTlvcellular_data_cap, DOT11F_TLV_CELLULAR_DATA_CAP,
	0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEMBO_IE, assoc_disallowed),
	offsetof(tDot11fTLVassoc_disallowed, present), "assoc_disallowed",
	SigTlvassoc_disallowed, DOT11F_TLV_ASSOC_DISALLOWED,
	0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEMBO_IE, cellular_data_con_pref),
	offsetof(tDot11fTLVcellular_data_con_pref, present),
	"cellular_data_con_pref", SigTlvcellular_data_con_pref,
	DOT11F_TLV_CELLULAR_DATA_CON_PREF, 0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEMBO_IE, transition_reason),
	offsetof(tDot11fTLVtransition_reason, present), "transition_reason",
	SigTlvtransition_reason, DOT11F_TLV_TRANSITION_REASON,
	0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEMBO_IE, transition_reject_reason),
	offsetof(tDot11fTLVtransition_reject_reason, present),
	"transition_reject_reason", SigTlvtransition_reject_reason,
	DOT11F_TLV_TRANSITION_REJECT_REASON, 0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEMBO_IE, assoc_retry_delay),
	offsetof(tDot11fTLVassoc_retry_delay, present), "assoc_retry_delay",
	SigTlvassoc_retry_delay, DOT11F_TLV_ASSOC_RETRY_DELAY,
	0, 4, 4, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEMBO_IE, oce_cap), offsetof(tDot11fTLVoce_cap,
	present), "oce_cap", SigTlvoce_cap, DOT11F_TLV_OCE_CAP,
	0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEMBO_IE, rssi_assoc_rej),
	offsetof(tDot11fTLVrssi_assoc_rej, present), "rssi_assoc_rej",
	SigTlvrssi_assoc_rej, DOT11F_TLV_RSSI_ASSOC_REJ, 0, 4, 4, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEMBO_IE, reduced_wan_metrics),
	offsetof(tDot11fTLVreduced_wan_metrics, present), "reduced_wan_metrics",
	SigTlvreduced_wan_metrics, DOT11F_TLV_REDUCED_WAN_METRICS,
	0, 3, 3, 0, 1, 1, 0, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_MBO_IE(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIEMBO_IE *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_MBO_IE,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_MBO_IE. */

#define SigIeMBO_IE (0x0041)


static const tFFDefn FFS_reportBeacon[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_reportBeacon[] = {
	{ offsetof(tDot11fIEMeasurementReport,
	report.Beacon.BeaconReportFrmBody),
	offsetof(tDot11fIEBeaconReportFrmBody, present), 0, "BeaconReportFrmBody",
	0, 2, 226, SigIeBeaconReportFrmBody, {0, 0, 0, 0, 0},
	0, DOT11F_EID_BEACONREPORTFRMBODY, 0, 0, },
	{ offsetof(tDot11fIEMeasurementReport,
	report.Beacon.beacon_report_frm_body_fragment_id),
	offsetof(tDot11fIEbeacon_report_frm_body_fragment_id, present), 0,
	"beacon_report_frm_body_fragment_id",
	0, 4, 4, SigIebeacon_report_frm_body_fragment_id, {0, 0, 0, 0, 0},
	0, DOT11F_EID_BEACON_REPORT_FRM_BODY_FRAGMENT_ID, 0, 0, },
	{ offsetof(tDot11fIEMeasurementReport,
	report.Beacon.last_beacon_report_indication),
	offsetof(tDot11fIElast_beacon_report_indication, present), 0,
	"last_beacon_report_indication",
	0, 3, 3, SigIelast_beacon_report_indication, {0, 0, 0, 0, 0},
	0, DOT11F_EID_LAST_BEACON_REPORT_INDICATION, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },
};

uint32_t dot11f_unpack_ie_measurement_report(tpAniSirGlobal pCtx,
					    uint8_t *pBuf,
					    uint8_t ielen,
					    tDot11fIEMeasurementReport *pDst,
					    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp52__;
	uint8_t tmp53__;
	uint8_t tmp54__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->token = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp52__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->late = tmp52__ >> 0 & 0x1;
	pDst->incapable = tmp52__ >> 1 & 0x1;
	pDst->refused = tmp52__ >> 2 & 0x1;
	pDst->unused = tmp52__ >> 3 & 0x1f;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->type = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (!ielen) {
		return 0U;
	} else {
		switch (pDst->type) {
		case 0:
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.Basic.channel = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 8)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohq(pCtx, &pDst->report.Basic.meas_start_time, pBuf, 0);
			pBuf += 8;
			ielen -= (uint8_t)8;
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->report.Basic.meas_duration, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			tmp53__ = *pBuf;
			pBuf += 1;
			ielen -= 1;
			pDst->report.Basic.bss = tmp53__ >> 0 & 0x1;
			pDst->report.Basic.ofdm_preamble = tmp53__ >> 1 & 0x1;
			pDst->report.Basic.unid_signal = tmp53__ >> 2 & 0x1;
			pDst->report.Basic.rader = tmp53__ >> 3 & 0x1;
			pDst->report.Basic.unmeasured = tmp53__ >> 4 & 0x1;
			pDst->report.Basic.unused = tmp53__ >> 5 & 0x7;
			break;
		case 1:
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.CCA.channel = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 8)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohq(pCtx, &pDst->report.CCA.meas_start_time, pBuf, 0);
			pBuf += 8;
			ielen -= (uint8_t)8;
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->report.CCA.meas_duration, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.CCA.cca_busy_fraction = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			break;
		case 2:
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.RPIHistogram.channel = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 8)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohq(pCtx, &pDst->report.RPIHistogram.meas_start_time, pBuf, 0);
			pBuf += 8;
			ielen -= (uint8_t)8;
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->report.RPIHistogram.meas_duration, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.RPIHistogram.rpi0_density = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.RPIHistogram.rpi1_density = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.RPIHistogram.rpi2_density = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.RPIHistogram.rpi3_density = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.RPIHistogram.rpi4_density = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.RPIHistogram.rpi5_density = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.RPIHistogram.rpi6_density = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.RPIHistogram.rpi7_density = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			break;
		case 5:
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.Beacon.regClass = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.Beacon.channel = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 8)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohq(pCtx, &pDst->report.Beacon.meas_start_time, pBuf, 0);
			pBuf += 8;
			ielen -= (uint8_t)8;
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->report.Beacon.meas_duration, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			tmp54__ = *pBuf;
			pBuf += 1;
			ielen -= 1;
			pDst->report.Beacon.condensed_PHY = tmp54__ >> 0 & 0x7f;
			pDst->report.Beacon.reported_frame_type = tmp54__ >> 7 & 0x1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.Beacon.RCPI = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.Beacon.RSNI = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 6)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			DOT11F_MEMCPY(pCtx, pDst->report.Beacon.BSSID, pBuf, 6);
			pBuf += 6;
			ielen -= (uint8_t)6;
			if (unlikely(ielen < 1)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			pDst->report.Beacon.antenna_id = *pBuf;
			pBuf += 1;
			ielen -= (uint8_t)1;
			if (unlikely(ielen < 4)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohl(pCtx, &pDst->report.Beacon.parent_TSF, pBuf, 0);
			pBuf += 4;
			ielen -= (uint8_t)4;
			status |= unpack_core(pCtx,
				pBuf,
				ielen,
				FFS_reportBeacon,
				IES_reportBeacon,
				(uint8_t *)pDst,
				sizeof(*pDst), append_ie);
			break;
		}
	}
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_measurement_report. */

#define SigIeMeasurementReport (0x0042)


static const tFFDefn FFS_measurement_requestBeacon[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_measurement_requestBeacon[] = {
	{ offsetof(tDot11fIEMeasurementRequest,
	measurement_request.Beacon.SSID), offsetof(tDot11fIESSID, present), 0,
	"SSID", 0, 2, 34, SigIeSSID, {0, 0, 0, 0, 0}, 0, DOT11F_EID_SSID, 0, 0, },
	{ offsetof(tDot11fIEMeasurementRequest,
	measurement_request.Beacon.BeaconReporting),
	offsetof(tDot11fIEBeaconReporting, present), 0, "BeaconReporting",
	0, 4, 4, SigIeBeaconReporting, {0, 0, 0, 0, 0},
	0, DOT11F_EID_BEACONREPORTING, 0, 0, },
	{ offsetof(tDot11fIEMeasurementRequest,
	measurement_request.Beacon.BcnReportingDetail),
	offsetof(tDot11fIEBcnReportingDetail, present), 0, "BcnReportingDetail",
	0, 3, 3, SigIeBcnReportingDetail, {0, 0, 0, 0, 0},
	0, DOT11F_EID_BCNREPORTINGDETAIL, 0, 0, },
	{ offsetof(tDot11fIEMeasurementRequest,
	measurement_request.Beacon.RequestedInfo),
	offsetof(tDot11fIERequestedInfo, present), 0, "RequestedInfo",
	0, 2, 257, SigIeRequestedInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_REQUESTEDINFO, 0, 0, },
	{ offsetof(tDot11fIEMeasurementRequest,
	measurement_request.Beacon.APChannelReport),
	offsetof(tDot11fIEAPChannelReport, present),
	offsetof(tDot11fIEMeasurementRequest, measurement_request.Beacon.num_APChannelReport), "APChannelReport", 2, 3, 53, SigIeAPChannelReport, {0, 0, 0, 0, 0}, 0, DOT11F_EID_APCHANNELREPORT, 0, 0, },
	{ offsetof(tDot11fIEMeasurementRequest,
	measurement_request.Beacon.last_beacon_report_indication),
	offsetof(tDot11fIElast_beacon_report_indication, present), 0,
	"last_beacon_report_indication",
	0, 3, 3, SigIelast_beacon_report_indication, {0, 0, 0, 0, 0},
	0, DOT11F_EID_LAST_BEACON_REPORT_INDICATION, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },
};

static const tFFDefn FFS_measurement_requestlci[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_measurement_requestlci[] = {
	{ offsetof(tDot11fIEMeasurementRequest,
	measurement_request.lci.azimuth_req), offsetof(tDot11fIEazimuth_req,
	present), 0, "azimuth_req", 0, 3, 3, SigIeazimuth_req, {0, 0, 0, 0, 0},
	0, DOT11F_EID_AZIMUTH_REQ, 0, 0, },
	{ offsetof(tDot11fIEMeasurementRequest,
	measurement_request.lci.req_mac_addr), offsetof(tDot11fIEreq_mac_addr,
	present), 0, "req_mac_addr", 0, 8, 8, SigIereq_mac_addr, {0, 0, 0, 0, 0},
	0, DOT11F_EID_REQ_MAC_ADDR, 0, 0, },
	{ offsetof(tDot11fIEMeasurementRequest,
	measurement_request.lci.tgt_mac_addr), offsetof(tDot11fIEtgt_mac_addr,
	present), 0, "tgt_mac_addr", 0, 8, 8, SigIetgt_mac_addr, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TGT_MAC_ADDR, 0, 0, },
	{ offsetof(tDot11fIEMeasurementRequest,
	measurement_request.lci.max_age), offsetof(tDot11fIEmax_age, present), 0,
	"max_age", 0, 4, 4, SigIemax_age, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MAX_AGE, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },
};

static const tFFDefn FFS_measurement_requestftmrr[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_measurement_requestftmrr[] = {
	{ offsetof(tDot11fIEMeasurementRequest,
	measurement_request.ftmrr.neighbor_rpt), offsetof(tDot11fIEneighbor_rpt,
	present), 0, "neighbor_rpt", 0, 15, 548, SigIeneighbor_rpt,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_NEIGHBOR_RPT, 0, 0, },
	{ offsetof(tDot11fIEMeasurementRequest,
	measurement_request.ftmrr.max_age), offsetof(tDot11fIEmax_age, present),
	0, "max_age", 0, 4, 4, SigIemax_age, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MAX_AGE, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },
};

uint32_t dot11f_unpack_ie_measurement_request(tpAniSirGlobal pCtx,
					     uint8_t *pBuf,
					     uint8_t ielen,
					     tDot11fIEMeasurementRequest *pDst,
					     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp55__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->measurement_token = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp55__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->parallel = tmp55__ >> 0 & 0x1;
	pDst->enable = tmp55__ >> 1 & 0x1;
	pDst->request = tmp55__ >> 2 & 0x1;
	pDst->report = tmp55__ >> 3 & 0x1;
	pDst->durationMandatory = tmp55__ >> 4 & 0x1;
	pDst->unused = tmp55__ >> 5 & 0x7;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->measurement_type = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	switch (pDst->measurement_type) {
	case 0:
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->measurement_request.Basic.channel_no = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		if (unlikely(ielen < 8)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->measurement_request.Basic.meas_start_time, pBuf, 8);
		pBuf += 8;
		ielen -= (uint8_t)8;
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->measurement_request.Basic.meas_duration, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
		break;
	case 1:
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->measurement_request.CCA.channel_no = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		if (unlikely(ielen < 8)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->measurement_request.CCA.meas_start_time, pBuf, 8);
		pBuf += 8;
		ielen -= (uint8_t)8;
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->measurement_request.CCA.meas_duration, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
		break;
	case 2:
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->measurement_request.RPIHistogram.channel_no = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		if (unlikely(ielen < 8)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->measurement_request.RPIHistogram.meas_start_time, pBuf, 8);
		pBuf += 8;
		ielen -= (uint8_t)8;
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->measurement_request.RPIHistogram.meas_duration, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
		break;
	case 5:
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->measurement_request.Beacon.regClass = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->measurement_request.Beacon.channel = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->measurement_request.Beacon.randomization, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->measurement_request.Beacon.meas_duration, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->measurement_request.Beacon.meas_mode = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		if (unlikely(ielen < 6)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->measurement_request.Beacon.BSSID, pBuf, 6);
		pBuf += 6;
		ielen -= (uint8_t)6;
		status |= unpack_core(pCtx,
				pBuf,
				ielen,
				FFS_measurement_requestBeacon,
				IES_measurement_requestBeacon,
				(uint8_t *)pDst,
				sizeof(*pDst), append_ie);
		break;
	case 8:
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->measurement_request.lci.loc_subject = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		status |= unpack_core(pCtx,
				pBuf,
				ielen,
				FFS_measurement_requestlci,
				IES_measurement_requestlci,
				(uint8_t *)pDst,
				sizeof(*pDst), append_ie);
		break;
	case 16:
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->measurement_request.ftmrr.random_interval, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->measurement_request.ftmrr.min_ap_count = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		status |= unpack_core(pCtx,
				pBuf,
				ielen,
				FFS_measurement_requestftmrr,
				IES_measurement_requestftmrr,
				(uint8_t *)pDst,
				sizeof(*pDst), append_ie);
		break;
	}
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_measurement_request. */

#define SigIeMeasurementRequest (0x0043)


uint32_t dot11f_unpack_ie_mobility_domain(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEMobilityDomain *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp56__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->MDID, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp56__ = *pBuf;
	pDst->overDSCap = tmp56__ >> 0 & 0x1;
	pDst->resourceReqCap = tmp56__ >> 1 & 0x1;
	pDst->reserved = tmp56__ >> 2 & 0x3f;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_mobility_domain. */

#define SigIeMobilityDomain (0x0044)


static const tFFDefn FFS_NeighborReport[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_NeighborReport[] = {
	{ offsetof(tDot11fIENeighborReport, TSFInfo), offsetof(tDot11fIETSFInfo,
	present), 0, "TSFInfo", 0, 6, 6, SigIeTSFInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TSFINFO, 0, 0, },
	{ offsetof(tDot11fIENeighborReport, CondensedCountryStr),
	offsetof(tDot11fIECondensedCountryStr, present), 0, "CondensedCountryStr",
	0, 4, 4, SigIeCondensedCountryStr, {0, 0, 0, 0, 0},
	0, DOT11F_EID_CONDENSEDCOUNTRYSTR, 0, 0, },
	{ offsetof(tDot11fIENeighborReport, MeasurementPilot),
	offsetof(tDot11fIEMeasurementPilot, present), 0, "MeasurementPilot",
	0, 3, 258, SigIeMeasurementPilot, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MEASUREMENTPILOT, 0, 0, },
	{ offsetof(tDot11fIENeighborReport, RRMEnabledCap),
	offsetof(tDot11fIERRMEnabledCap, present), 0, "RRMEnabledCap",
	0, 7, 7, SigIeRRMEnabledCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RRMENABLEDCAP, 0, 0, },
	{ offsetof(tDot11fIENeighborReport, MultiBssid),
	offsetof(tDot11fIEMultiBssid, present), 0, "MultiBssid",
	0, 3, 258, SigIeMultiBssid, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MULTIBSSID, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },
};

uint32_t dot11f_unpack_ie_neighbor_report(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIENeighborReport *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp57__;
	uint8_t tmp58__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->bssid, pBuf, 6);
	pBuf += 6;
	ielen -= (uint8_t)6;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp57__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->APReachability = tmp57__ >> 0 & 0x3;
	pDst->Security = tmp57__ >> 2 & 0x1;
	pDst->KeyScope = tmp57__ >> 3 & 0x1;
	pDst->SpecMgmtCap = tmp57__ >> 4 & 0x1;
	pDst->QosCap = tmp57__ >> 5 & 0x1;
	pDst->apsd = tmp57__ >> 6 & 0x1;
	pDst->rrm = tmp57__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp58__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->DelayedBA = tmp58__ >> 0 & 0x1;
	pDst->ImmBA = tmp58__ >> 1 & 0x1;
	pDst->MobilityDomain = tmp58__ >> 2 & 0x1;
	pDst->reserved = tmp58__ >> 3 & 0x1f;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->reserved1, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->regulatoryClass = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->channel = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->PhyType = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	(void)pCtx;
	status |= unpack_core(pCtx,
				pBuf,
				ielen,
				FFS_NeighborReport,
				IES_NeighborReport,
				(uint8_t *)pDst,
				sizeof(*pDst),
				append_ie);
	return status;
} /* End dot11f_unpack_ie_neighbor_report. */

#define SigIeNeighborReport (0x0045)


uint32_t dot11f_unpack_ie_obss_scan_parameters(tpAniSirGlobal pCtx,
					     uint8_t *pBuf,
					     uint8_t ielen,
					     tDot11fIEOBSSScanParameters *pDst,
					     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->obssScanPassiveDwell, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->obssScanActiveDwell, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->bssChannelWidthTriggerScanInterval, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->obssScanPassiveTotalPerChannel, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->obssScanActiveTotalPerChannel, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->bssWidthChannelTransitionDelayFactor, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->obssScanActivityThreshold, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_obss_scan_parameters. */

#define SigIeOBSSScanParameters (0x0046)


uint32_t dot11f_unpack_ie_operating_mode(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEOperatingMode *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp59__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp59__ = *pBuf;
	pDst->chanWidth = tmp59__ >> 0 & 0x3;
	pDst->vht_160_80p80_supp = tmp59__ >> 2 & 0x1;
	pDst->no_ldpc = tmp59__ >> 3 & 0x1;
	pDst->rxNSS = tmp59__ >> 4 & 0x7;
	pDst->rxNSSType = tmp59__ >> 7 & 0x1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_operating_mode. */

#define SigIeOperatingMode (0x0047)


static const tTLVDefn TLVS_P2PAssocReq[] = {
	{ offsetof(tDot11fIEP2PAssocReq, P2PCapability),
	offsetof(tDot11fTLVP2PCapability, present), "P2PCapability",
	SigTlvP2PCapability, DOT11F_TLV_P2PCAPABILITY, 0, 5, 5, 1, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PAssocReq, ExtendedListenTiming),
	offsetof(tDot11fTLVExtendedListenTiming, present),
	"ExtendedListenTiming", SigTlvExtendedListenTiming,
	DOT11F_TLV_EXTENDEDLISTENTIMING, 0, 7, 7, 0, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PAssocReq, P2PDeviceInfo),
	offsetof(tDot11fTLVP2PDeviceInfo, present), "P2PDeviceInfo",
	SigTlvP2PDeviceInfo, DOT11F_TLV_P2PDEVICEINFO, 0, 19, 55, 1, 1, 2, 0, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_p2_p_assoc_req(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEP2PAssocReq *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_P2PAssocReq,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_p2_p_assoc_req. */

#define SigIeP2PAssocReq (0x0048)


static const tTLVDefn TLVS_P2PAssocRes[] = {
	{ offsetof(tDot11fIEP2PAssocRes, P2PStatus),
	offsetof(tDot11fTLVP2PStatus, present), "P2PStatus", SigTlvP2PStatus,
	DOT11F_TLV_P2PSTATUS, 0, 4, 4, 1, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PAssocRes, ExtendedListenTiming),
	offsetof(tDot11fTLVExtendedListenTiming, present),
	"ExtendedListenTiming", SigTlvExtendedListenTiming,
	DOT11F_TLV_EXTENDEDLISTENTIMING, 0, 7, 7, 0, 1, 2, 0, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_p2_p_assoc_res(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEP2PAssocRes *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_P2PAssocRes,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_p2_p_assoc_res. */

#define SigIeP2PAssocRes (0x0049)


static const tTLVDefn TLVS_P2PBeacon[] = {
	{ offsetof(tDot11fIEP2PBeacon, P2PCapability),
	offsetof(tDot11fTLVP2PCapability, present), "P2PCapability",
	SigTlvP2PCapability, DOT11F_TLV_P2PCAPABILITY, 0, 5, 5, 1, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PBeacon, P2PDeviceId),
	offsetof(tDot11fTLVP2PDeviceId, present), "P2PDeviceId",
	SigTlvP2PDeviceId, DOT11F_TLV_P2PDEVICEID, 0, 9, 9, 1, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PBeacon, NoticeOfAbsence),
	offsetof(tDot11fTLVNoticeOfAbsence, present), "NoticeOfAbsence",
	SigTlvNoticeOfAbsence, DOT11F_TLV_NOTICEOFABSENCE,
	0, 5, 41, 0, 1, 2, 0, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_p2_p_beacon(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIEP2PBeacon *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_P2PBeacon,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_p2_p_beacon. */

#define SigIeP2PBeacon (0x004a)


static const tTLVDefn TLVS_P2PBeaconProbeRes[] = {
	{ offsetof(tDot11fIEP2PBeaconProbeRes, P2PCapability),
	offsetof(tDot11fTLVP2PCapability, present), "P2PCapability",
	SigTlvP2PCapability, DOT11F_TLV_P2PCAPABILITY, 0, 5, 5, 0, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PBeaconProbeRes, P2PDeviceId),
	offsetof(tDot11fTLVP2PDeviceId, present), "P2PDeviceId",
	SigTlvP2PDeviceId, DOT11F_TLV_P2PDEVICEID, 0, 9, 9, 0, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PBeaconProbeRes, ExtendedListenTiming),
	offsetof(tDot11fTLVExtendedListenTiming, present),
	"ExtendedListenTiming", SigTlvExtendedListenTiming,
	DOT11F_TLV_EXTENDEDLISTENTIMING, 0, 7, 7, 0, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PBeaconProbeRes, NoticeOfAbsence),
	offsetof(tDot11fTLVNoticeOfAbsence, present), "NoticeOfAbsence",
	SigTlvNoticeOfAbsence, DOT11F_TLV_NOTICEOFABSENCE,
	0, 5, 41, 0, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PBeaconProbeRes, P2PDeviceInfo),
	offsetof(tDot11fTLVP2PDeviceInfo, present), "P2PDeviceInfo",
	SigTlvP2PDeviceInfo, DOT11F_TLV_P2PDEVICEINFO, 0, 19, 55, 0, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PBeaconProbeRes, P2PGroupInfo),
	offsetof(tDot11fTLVP2PGroupInfo, present), "P2PGroupInfo",
	SigTlvP2PGroupInfo, DOT11F_TLV_P2PGROUPINFO, 0, 3, 1027, 0, 1, 2, 0, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_p2_p_beacon_probe_res(tpAniSirGlobal pCtx,
					    uint8_t *pBuf,
					    uint8_t ielen,
					    tDot11fIEP2PBeaconProbeRes *pDst,
					    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_P2PBeaconProbeRes,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_p2_p_beacon_probe_res. */

#define SigIeP2PBeaconProbeRes (0x004b)


static const tTLVDefn TLVS_P2PDeAuth[] = {
	{ offsetof(tDot11fIEP2PDeAuth, MinorReasonCode),
	offsetof(tDot11fTLVMinorReasonCode, present), "MinorReasonCode",
	SigTlvMinorReasonCode, DOT11F_TLV_MINORREASONCODE,
	0, 4, 4, 1, 1, 2, 0, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_p2_p_de_auth(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIEP2PDeAuth *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_P2PDeAuth,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_p2_p_de_auth. */

#define SigIeP2PDeAuth (0x004c)


static const tTLVDefn TLVS_P2PDisAssoc[] = {
	{ offsetof(tDot11fIEP2PDisAssoc, MinorReasonCode),
	offsetof(tDot11fTLVMinorReasonCode, present), "MinorReasonCode",
	SigTlvMinorReasonCode, DOT11F_TLV_MINORREASONCODE,
	0, 4, 4, 1, 1, 2, 0, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_p2_p_dis_assoc(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEP2PDisAssoc *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_P2PDisAssoc,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_p2_p_dis_assoc. */

#define SigIeP2PDisAssoc (0x004d)


uint32_t dot11f_unpack_ie_p2_pie_opaque(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEP2PIEOpaque *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_data = (uint8_t)(ielen);
	if (ielen > 249) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_p2_pie_opaque. */

#define SigIeP2PIEOpaque (0x004e)


static const tTLVDefn TLVS_P2PProbeReq[] = {
	{ offsetof(tDot11fIEP2PProbeReq, P2PCapability),
	offsetof(tDot11fTLVP2PCapability, present), "P2PCapability",
	SigTlvP2PCapability, DOT11F_TLV_P2PCAPABILITY, 0, 5, 5, 1, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PProbeReq, P2PDeviceId),
	offsetof(tDot11fTLVP2PDeviceId, present), "P2PDeviceId",
	SigTlvP2PDeviceId, DOT11F_TLV_P2PDEVICEID, 0, 9, 9, 0, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PProbeReq, ListenChannel),
	offsetof(tDot11fTLVListenChannel, present), "ListenChannel",
	SigTlvListenChannel, DOT11F_TLV_LISTENCHANNEL, 0, 8, 8, 1, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PProbeReq, ExtendedListenTiming),
	offsetof(tDot11fTLVExtendedListenTiming, present),
	"ExtendedListenTiming", SigTlvExtendedListenTiming,
	DOT11F_TLV_EXTENDEDLISTENTIMING, 0, 7, 7, 0, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PProbeReq, OperatingChannel),
	offsetof(tDot11fTLVOperatingChannel, present), "OperatingChannel",
	SigTlvOperatingChannel, DOT11F_TLV_OPERATINGCHANNEL,
	0, 8, 8, 0, 1, 2, 0, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_p2_p_probe_req(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEP2PProbeReq *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_P2PProbeReq,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_p2_p_probe_req. */

#define SigIeP2PProbeReq (0x004f)


static const tTLVDefn TLVS_P2PProbeRes[] = {
	{ offsetof(tDot11fIEP2PProbeRes, P2PCapability),
	offsetof(tDot11fTLVP2PCapability, present), "P2PCapability",
	SigTlvP2PCapability, DOT11F_TLV_P2PCAPABILITY, 0, 5, 5, 1, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PProbeRes, ExtendedListenTiming),
	offsetof(tDot11fTLVExtendedListenTiming, present),
	"ExtendedListenTiming", SigTlvExtendedListenTiming,
	DOT11F_TLV_EXTENDEDLISTENTIMING, 0, 7, 7, 0, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PProbeRes, NoticeOfAbsence),
	offsetof(tDot11fTLVNoticeOfAbsence, present), "NoticeOfAbsence",
	SigTlvNoticeOfAbsence, DOT11F_TLV_NOTICEOFABSENCE,
	0, 5, 41, 0, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PProbeRes, P2PDeviceInfo),
	offsetof(tDot11fTLVP2PDeviceInfo, present), "P2PDeviceInfo",
	SigTlvP2PDeviceInfo, DOT11F_TLV_P2PDEVICEINFO, 0, 19, 55, 1, 1, 2, 0, },
	{ offsetof(tDot11fIEP2PProbeRes, P2PGroupInfo),
	offsetof(tDot11fTLVP2PGroupInfo, present), "P2PGroupInfo",
	SigTlvP2PGroupInfo, DOT11F_TLV_P2PGROUPINFO, 0, 3, 1027, 0, 1, 2, 0, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_p2_p_probe_res(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEP2PProbeRes *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_P2PProbeRes,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_p2_p_probe_res. */

#define SigIeP2PProbeRes (0x0050)


uint32_t dot11f_unpack_ie_pti_control(tpAniSirGlobal pCtx,
				     uint8_t *pBuf,
				     uint8_t ielen,
				     tDot11fIEPTIControl *pDst,
				     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->tid = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->sequence_control, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_pti_control. */

#define SigIePTIControl (0x0051)


uint32_t dot11f_unpack_ie_pu_buffer_status(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEPUBufferStatus *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp60__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp60__ = *pBuf;
	pDst->ac_bk_traffic_aval = tmp60__ >> 0 & 0x1;
	pDst->ac_be_traffic_aval = tmp60__ >> 1 & 0x1;
	pDst->ac_vi_traffic_aval = tmp60__ >> 2 & 0x1;
	pDst->ac_vo_traffic_aval = tmp60__ >> 3 & 0x1;
	pDst->reserved = tmp60__ >> 4 & 0xf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_pu_buffer_status. */

#define SigIePUBufferStatus (0x0052)


uint32_t dot11f_unpack_ie_power_caps(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIEPowerCaps *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->minTxPower = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->maxTxPower = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_power_caps. */

#define SigIePowerCaps (0x0053)


uint32_t dot11f_unpack_ie_power_constraints(tpAniSirGlobal pCtx,
					   uint8_t *pBuf,
					   uint8_t ielen,
					   tDot11fIEPowerConstraints *pDst,
					   bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->localPowerConstraints = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_power_constraints. */

#define SigIePowerConstraints (0x0054)


uint32_t dot11f_unpack_ie_qbss_load(tpAniSirGlobal pCtx,
				   uint8_t *pBuf,
				   uint8_t ielen,
				   tDot11fIEQBSSLoad *pDst,
				   bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->stacount, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->chautil = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->avail, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_qbss_load. */

#define SigIeQBSSLoad (0x0055)


uint32_t dot11f_unpack_ie_QComVendorIE(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint8_t ielen,
				       tDot11fIEQComVendorIE *pDst,
				       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->type = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->channel = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_QComVendorIE. */

#define SigIeQComVendorIE (0x0056)


uint32_t dot11f_unpack_ie_qos_caps_ap(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIEQOSCapsAp *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp61__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp61__ = *pBuf;
	pDst->count = tmp61__ >> 0 & 0xf;
	pDst->qack = tmp61__ >> 4 & 0x1;
	pDst->qreq = tmp61__ >> 5 & 0x1;
	pDst->txopreq = tmp61__ >> 6 & 0x1;
	pDst->reserved = tmp61__ >> 7 & 0x1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_qos_caps_ap. */

#define SigIeQOSCapsAp (0x0057)


uint32_t dot11f_unpack_ie_qos_caps_station(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEQOSCapsStation *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp62__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp62__ = *pBuf;
	pDst->acvo_uapsd = tmp62__ >> 0 & 0x1;
	pDst->acvi_uapsd = tmp62__ >> 1 & 0x1;
	pDst->acbk_uapsd = tmp62__ >> 2 & 0x1;
	pDst->acbe_uapsd = tmp62__ >> 3 & 0x1;
	pDst->qack = tmp62__ >> 4 & 0x1;
	pDst->max_sp_length = tmp62__ >> 5 & 0x3;
	pDst->more_data_ack = tmp62__ >> 7 & 0x1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_qos_caps_station. */

#define SigIeQOSCapsStation (0x0058)


uint32_t dot11f_unpack_ie_qos_map_set(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIEQosMapSet *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_dscp_exceptions = (uint8_t)(ielen);
	if (ielen > 58) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->dscp_exceptions, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_qos_map_set. */

#define SigIeQosMapSet (0x0059)


uint32_t dot11f_unpack_ie_quiet(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIEQuiet *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->count = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->period = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->duration, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->offset, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_quiet. */

#define SigIeQuiet (0x005a)


uint32_t dot11f_unpack_ie_rcpiie(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIERCPIIE *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->rcpi = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_rcpiie. */

#define SigIeRCPIIE (0x005b)


static const tFFDefn FFS_RICDataDesc[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_RICDataDesc[] = {
	{ offsetof(tDot11fIERICDataDesc, RICData), offsetof(tDot11fIERICData,
	present), 0, "RICData", 0, 6, 6, SigIeRICData, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RICDATA, 0, 1, },
	{ offsetof(tDot11fIERICDataDesc, RICDescriptor),
	offsetof(tDot11fIERICDescriptor, present), 0, "RICDescriptor",
	0, 3, 258, SigIeRICDescriptor, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RICDESCRIPTOR, 0, 0, },
	{ offsetof(tDot11fIERICDataDesc, TSPEC), offsetof(tDot11fIETSPEC,
	present), 0, "TSPEC", 0, 57, 57, SigIeTSPEC, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TSPEC, 0, 0, },
	{ offsetof(tDot11fIERICDataDesc, TCLAS), offsetof(tDot11fIETCLAS,
	present), offsetof(tDot11fIERICDataDesc, num_TCLAS), "TCLAS",
	2, 7, 45, SigIeTCLAS, {0, 0, 0, 0, 0}, 0, DOT11F_EID_TCLAS, 0, 0, },
	{ offsetof(tDot11fIERICDataDesc, TCLASSPROC),
	offsetof(tDot11fIETCLASSPROC, present), 0, "TCLASSPROC",
	0, 3, 3, SigIeTCLASSPROC, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TCLASSPROC, 0, 0, },
	{ offsetof(tDot11fIERICDataDesc, TSDelay), offsetof(tDot11fIETSDelay,
	present), 0, "TSDelay", 0, 6, 6, SigIeTSDelay, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TSDELAY, 0, 0, },
	{ offsetof(tDot11fIERICDataDesc, Schedule), offsetof(tDot11fIESchedule,
	present), 0, "Schedule", 0, 16, 16, SigIeSchedule, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SCHEDULE, 0, 0, },
	{ offsetof(tDot11fIERICDataDesc, WMMTSPEC), offsetof(tDot11fIEWMMTSPEC,
	present), 0, "WMMTSPEC", 0, 63, 63, SigIeWMMTSPEC, {0, 80, 242, 2, 2},
	5, DOT11F_EID_WMMTSPEC, 0, 0, },
	{ offsetof(tDot11fIERICDataDesc, WMMTCLAS), offsetof(tDot11fIEWMMTCLAS,
	present), offsetof(tDot11fIERICDataDesc, num_WMMTCLAS), "WMMTCLAS",
	2, 13, 51, SigIeWMMTCLAS, {0, 80, 242, 2, 6},
	5, DOT11F_EID_WMMTCLAS, 0, 0, },
	{ offsetof(tDot11fIERICDataDesc, WMMTCLASPROC),
	offsetof(tDot11fIEWMMTCLASPROC, present), 0, "WMMTCLASPROC",
	0, 9, 9, SigIeWMMTCLASPROC, {0, 80, 242, 2, 7},
	5, DOT11F_EID_WMMTCLASPROC, 0, 0, },
	{ offsetof(tDot11fIERICDataDesc, WMMTSDelay),
	offsetof(tDot11fIEWMMTSDelay, present), 0, "WMMTSDelay",
	0, 12, 12, SigIeWMMTSDelay, {0, 80, 242, 2, 8},
	5, DOT11F_EID_WMMTSDELAY, 0, 0, },
	{ offsetof(tDot11fIERICDataDesc, WMMSchedule),
	offsetof(tDot11fIEWMMSchedule, present), 0, "WMMSchedule",
	0, 22, 22, SigIeWMMSchedule, {0, 80, 242, 2, 9},
	5, DOT11F_EID_WMMSCHEDULE, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },
};

uint32_t dot11f_unpack_ie_ric_data_desc(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIERICDataDesc *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	(void)pCtx;
	status |= unpack_core(pCtx,
				pBuf,
				ielen,
				FFS_RICDataDesc,
				IES_RICDataDesc,
				(uint8_t *)pDst,
				sizeof(*pDst),
				append_ie);
	return status;
} /* End dot11f_unpack_ie_ric_data_desc. */

#define SigIeRICDataDesc (0x005c)


uint32_t dot11f_unpack_ie_rsn(tpAniSirGlobal pCtx,
			      uint8_t *pBuf,
			      uint8_t ielen,
			      tDot11fIERSN *pDst,
			      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t def_cipher_suite[4] = {0x00, 0x0f, 0xac, 0x04};
	uint8_t def_akm_suite[4] = {0x00, 0x0f, 0xac, 0x01};

	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->version, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (pDst->version != 0x1) {
		pDst->present = 0;
		return status | DOT11F_BAD_FIXED_VALUE;
	}
	if (!ielen) {
		pDst->RSN_Cap_present = 0U;
		pDst->gp_mgmt_cipher_suite_present = 0U;
		pDst->gp_cipher_suite_present = 1;
		DOT11F_MEMCPY(pCtx, pDst->gp_cipher_suite, def_cipher_suite, 4);
		pDst->pwise_cipher_suite_count = 1;
		DOT11F_MEMCPY(pCtx,
				pDst->pwise_cipher_suites, def_cipher_suite, 4);
		pDst->akm_suite_cnt = 1;
		DOT11F_MEMCPY(pCtx, pDst->akm_suite, def_akm_suite, 4);
		pDst->pmkid_count = 0U;
		return 0U;
	} else {
		pDst->gp_cipher_suite_present = 1;
		if (unlikely(ielen < 4)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->gp_cipher_suite, pBuf, 4);
		pBuf += 4;
		ielen -= (uint8_t)4;
	}
	if (!ielen) {
		pDst->RSN_Cap_present = 0U;
		pDst->gp_mgmt_cipher_suite_present = 0U;
		pDst->pwise_cipher_suite_count = 1;
		DOT11F_MEMCPY(pCtx,
				pDst->pwise_cipher_suites, def_cipher_suite, 4);
		pDst->akm_suite_cnt = 1;
		DOT11F_MEMCPY(pCtx, pDst->akm_suite, def_akm_suite, 4);
		pDst->pmkid_count = 0U;
		return 0U;
	} else {
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->pwise_cipher_suite_count, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
	}
	if (unlikely(ielen < pDst->pwise_cipher_suite_count * 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	if (!pDst->pwise_cipher_suite_count ||
		pDst->pwise_cipher_suite_count > 6) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->pwise_cipher_suites, pBuf, (pDst->pwise_cipher_suite_count * 4));
	pBuf += (pDst->pwise_cipher_suite_count * 4);
	ielen -= (pDst->pwise_cipher_suite_count * 4);
	if (!ielen) {
		pDst->RSN_Cap_present = 0U;
		pDst->gp_mgmt_cipher_suite_present = 0U;
		pDst->akm_suite_cnt = 1;
		DOT11F_MEMCPY(pCtx, pDst->akm_suite, def_akm_suite, 4);
		pDst->pmkid_count = 0U;
		return 0U;
	} else {
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->akm_suite_cnt, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
	}
	if (unlikely(ielen < pDst->akm_suite_cnt * 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	if (!pDst->akm_suite_cnt ||
		pDst->akm_suite_cnt > 6) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->akm_suite, pBuf, (pDst->akm_suite_cnt * 4));
	pBuf += (pDst->akm_suite_cnt * 4);
	ielen -= (pDst->akm_suite_cnt * 4);
	if (!ielen) {
		pDst->RSN_Cap_present = 0U;
		pDst->gp_mgmt_cipher_suite_present = 0U;
		pDst->pmkid_count = 0U;
		return 0U;
	} else {
		pDst->RSN_Cap_present = 1;
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->RSN_Cap, pBuf, 2);
		pBuf += 2;
		ielen -= (uint8_t)2;
	}
	if (!ielen) {
		pDst->gp_mgmt_cipher_suite_present = 0U;
		pDst->pmkid_count = 0U;
		return 0U;
	} else {
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->pmkid_count, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
	}
	if (unlikely(ielen < pDst->pmkid_count * 16)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	if (pDst->pmkid_count > 4) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->pmkid, pBuf, (pDst->pmkid_count * 16));
	pBuf += (pDst->pmkid_count * 16);
	ielen -= (pDst->pmkid_count * 16);
	if (!ielen) {
		return 0U;
	} else {
		pDst->gp_mgmt_cipher_suite_present = 1;
		if (unlikely(ielen < 4)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->gp_mgmt_cipher_suite, pBuf, 4);
	}
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_rsn. */

#define SigIeRSN (0x005d)


uint32_t dot11f_unpack_ie_rsniie(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIERSNIIE *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->rsni = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_rsniie. */

#define SigIeRSNIIE (0x005e)


uint32_t dot11f_unpack_ie_rsn_opaque(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIERSNOpaque *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_data = (uint8_t)(ielen);
	if (ielen > 253) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_rsn_opaque. */

#define SigIeRSNOpaque (0x005f)


uint32_t dot11f_unpack_ie_supp_channels(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint8_t ielen,
				       tDot11fIESuppChannels *pDst,
				       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_bands = (uint8_t)(ielen / 2);
	if (ielen > 48 * 2) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->bands, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_supp_channels. */

#define SigIeSuppChannels (0x0060)


uint32_t dot11f_unpack_ie_supp_operating_classes(tpAniSirGlobal pCtx,
					       uint8_t *pBuf,
					       uint8_t ielen,
					       tDot11fIESuppOperatingClasses *pDst,
					       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_classes = (uint8_t)(ielen);
	if (ielen > 32) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->classes, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_supp_operating_classes. */

#define SigIeSuppOperatingClasses (0x0061)


uint32_t dot11f_unpack_ie_supp_rates(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIESuppRates *pDst,
				    bool append_ie)
{
	uint8_t i;
	uint8_t rate_indx = 0;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	for (i = 0; i < ielen; i++) {
		if ((DOT11F_IS_BG_RATE(pBuf[i] & 0x7F)) &&
			(rate_indx < 12)) {
			pDst->rates[rate_indx++] = pBuf[i];
		}
	}

	if (rate_indx == 0) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	pDst->num_rates = rate_indx;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_supp_rates. */

#define SigIeSuppRates (0x0062)


uint32_t dot11f_unpack_ie_tim(tpAniSirGlobal pCtx,
			      uint8_t *pBuf,
			      uint8_t ielen,
			      tDot11fIETIM *pDst,
			      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->dtim_count = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->dtim_period = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->bmpctl = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	pDst->num_vbmp = (uint8_t)(ielen);
	if (ielen > 251) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->vbmp, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_tim. */

#define SigIeTIM (0x0063)


uint32_t dot11f_unpack_ie_tpc_report(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIETPCReport *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->tx_power = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->link_margin = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_tpc_report. */

#define SigIeTPCReport (0x0064)


uint32_t dot11f_unpack_ie_tpc_request(tpAniSirGlobal pCtx,
				     uint8_t *pBuf,
				     uint8_t ielen,
				     tDot11fIETPCRequest *pDst,
				     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_tpc_request. */

#define SigIeTPCRequest (0x0065)


uint32_t dot11f_unpack_ie_time_advertisement(tpAniSirGlobal pCtx,
					    uint8_t *pBuf,
					    uint8_t ielen,
					    tDot11fIETimeAdvertisement *pDst,
					    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->timing_capabilities = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 10)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->time_value, pBuf, 10);
	pBuf += 10;
	ielen -= (uint8_t)10;
	if (unlikely(ielen < 5)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->time_error, pBuf, 5);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_time_advertisement. */

#define SigIeTimeAdvertisement (0x0066)


uint32_t dot11f_unpack_ie_timeout_interval(tpAniSirGlobal pCtx,
					  uint8_t *pBuf,
					  uint8_t ielen,
					  tDot11fIETimeoutInterval *pDst,
					  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->timeoutType = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->timeoutValue, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_timeout_interval. */

#define SigIeTimeoutInterval (0x0067)


uint32_t dot11f_unpack_ie_vht_ext_bss_load(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEVHTExtBssLoad *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->muMIMOCapStaCount = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->ssUnderUtil = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->FortyMHzUtil = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->EightyMHzUtil = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->OneSixtyMHzUtil = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_vht_ext_bss_load. */

#define SigIeVHTExtBssLoad (0x0068)


uint32_t dot11f_unpack_ie_vendor1_ie(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIEVendor1IE *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_vendor1_ie. */

#define SigIeVendor1IE (0x0069)


uint32_t dot11f_unpack_ie_vendor3_ie(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIEVendor3IE *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_vendor3_ie. */

#define SigIeVendor3IE (0x006a)


uint32_t dot11f_unpack_ie_wapi(tpAniSirGlobal pCtx,
			       uint8_t *pBuf,
			       uint8_t ielen,
			       tDot11fIEWAPI *pDst,
			       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint16_t tmp63__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->version, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (pDst->version != 0x1) {
		pDst->present = 0;
		return status | DOT11F_BAD_FIXED_VALUE;
	}
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->akm_suite_count, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < pDst->akm_suite_count * 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	if (pDst->akm_suite_count > 4) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->akm_suites, pBuf, (pDst->akm_suite_count * 4));
	pBuf += (pDst->akm_suite_count * 4);
	ielen -= (pDst->akm_suite_count * 4);
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->unicast_cipher_suite_count, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < pDst->unicast_cipher_suite_count * 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	if (pDst->unicast_cipher_suite_count > 4) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->unicast_cipher_suites, pBuf, (pDst->unicast_cipher_suite_count * 4));
	pBuf += (pDst->unicast_cipher_suite_count * 4);
	ielen -= (pDst->unicast_cipher_suite_count * 4);
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->multicast_cipher_suite, pBuf, 4);
	pBuf += 4;
	ielen -= (uint8_t)4;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp63__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->preauth = tmp63__ >> 0 & 0x1;
	pDst->reserved = tmp63__ >> 1 & 0x7fff;
	if (!ielen) {
		pDst->bkid_count = 0U;
		return 0U;
	} else {
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->bkid_count, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
	}
	if (unlikely(ielen < pDst->bkid_count * 16)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	if (pDst->bkid_count > 4) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->bkid, pBuf, (pDst->bkid_count * 16));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wapi. */

#define SigIeWAPI (0x006b)


uint32_t dot11f_unpack_ie_wapi_opaque(tpAniSirGlobal pCtx,
				     uint8_t *pBuf,
				     uint8_t ielen,
				     tDot11fIEWAPIOpaque *pDst,
				     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_data = (uint8_t)(ielen);
	if (ielen > 253) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wapi_opaque. */

#define SigIeWAPIOpaque (0x006c)


uint32_t dot11f_unpack_ie_wfatpc(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIEWFATPC *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->txPower = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->linkMargin = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wfatpc. */

#define SigIeWFATPC (0x006d)


uint32_t dot11f_unpack_ie_wfdie_opaque(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEWFDIEOpaque *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_data = (uint8_t)(ielen);
	if (ielen > 249) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wfdie_opaque. */

#define SigIeWFDIEOpaque (0x006e)


uint32_t dot11f_unpack_ie_wmm_caps(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint8_t ielen,
				  tDot11fIEWMMCaps *pDst,
				  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp64__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->version = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (pDst->version != 0x1) {
		pDst->present = 0;
		return status | DOT11F_BAD_FIXED_VALUE;
	}
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp64__ = *pBuf;
	pDst->reserved = tmp64__ >> 0 & 0xf;
	pDst->qack = tmp64__ >> 4 & 0x1;
	pDst->queue_request = tmp64__ >> 5 & 0x1;
	pDst->txop_request = tmp64__ >> 6 & 0x1;
	pDst->more_ack = tmp64__ >> 7 & 0x1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wmm_caps. */

#define SigIeWMMCaps (0x006f)


uint32_t dot11f_unpack_ie_wmm_info_ap(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIEWMMInfoAp *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp65__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->version = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp65__ = *pBuf;
	pDst->param_set_count = tmp65__ >> 0 & 0xf;
	pDst->reserved = tmp65__ >> 4 & 0x7;
	pDst->uapsd = tmp65__ >> 7 & 0x1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wmm_info_ap. */

#define SigIeWMMInfoAp (0x0070)


uint32_t dot11f_unpack_ie_wmm_info_station(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEWMMInfoStation *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp66__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->version = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp66__ = *pBuf;
	pDst->acvo_uapsd = tmp66__ >> 0 & 0x1;
	pDst->acvi_uapsd = tmp66__ >> 1 & 0x1;
	pDst->acbk_uapsd = tmp66__ >> 2 & 0x1;
	pDst->acbe_uapsd = tmp66__ >> 3 & 0x1;
	pDst->reserved1 = tmp66__ >> 4 & 0x1;
	pDst->max_sp_length = tmp66__ >> 5 & 0x3;
	pDst->reserved2 = tmp66__ >> 7 & 0x1;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wmm_info_station. */

#define SigIeWMMInfoStation (0x0071)


uint32_t dot11f_unpack_ie_wmm_params(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIEWMMParams *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp67__;
	uint8_t tmp68__;
	uint8_t tmp69__;
	uint8_t tmp70__;
	uint8_t tmp71__;
	uint8_t tmp72__;
	uint8_t tmp73__;
	uint8_t tmp74__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->version = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (pDst->version != 0x1) {
		pDst->present = 0;
		return status | DOT11F_BAD_FIXED_VALUE;
	}
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->qosInfo = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->reserved2 = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp67__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acbe_aifsn = tmp67__ >> 0 & 0xf;
	pDst->acbe_acm = tmp67__ >> 4 & 0x1;
	pDst->acbe_aci = tmp67__ >> 5 & 0x3;
	pDst->unused1 = tmp67__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp68__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acbe_acwmin = tmp68__ >> 0 & 0xf;
	pDst->acbe_acwmax = tmp68__ >> 4 & 0xf;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->acbe_txoplimit, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp69__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acbk_aifsn = tmp69__ >> 0 & 0xf;
	pDst->acbk_acm = tmp69__ >> 4 & 0x1;
	pDst->acbk_aci = tmp69__ >> 5 & 0x3;
	pDst->unused2 = tmp69__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp70__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acbk_acwmin = tmp70__ >> 0 & 0xf;
	pDst->acbk_acwmax = tmp70__ >> 4 & 0xf;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->acbk_txoplimit, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp71__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acvi_aifsn = tmp71__ >> 0 & 0xf;
	pDst->acvi_acm = tmp71__ >> 4 & 0x1;
	pDst->acvi_aci = tmp71__ >> 5 & 0x3;
	pDst->unused3 = tmp71__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp72__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acvi_acwmin = tmp72__ >> 0 & 0xf;
	pDst->acvi_acwmax = tmp72__ >> 4 & 0xf;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->acvi_txoplimit, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp73__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acvo_aifsn = tmp73__ >> 0 & 0xf;
	pDst->acvo_acm = tmp73__ >> 4 & 0x1;
	pDst->acvo_aci = tmp73__ >> 5 & 0x3;
	pDst->unused4 = tmp73__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp74__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acvo_acwmin = tmp74__ >> 0 & 0xf;
	pDst->acvo_acwmax = tmp74__ >> 4 & 0xf;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->acvo_txoplimit, pBuf, 0);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wmm_params. */

#define SigIeWMMParams (0x0072)


uint32_t dot11f_unpack_ie_wpa(tpAniSirGlobal pCtx,
			      uint8_t *pBuf,
			      uint8_t ielen,
			      tDot11fIEWPA *pDst,
			      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->version, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (pDst->version != 0x1) {
		pDst->present = 0;
		return status | DOT11F_BAD_FIXED_VALUE;
	}
	if (!ielen) {
		pDst->multicast_cipher_present = 0U;
		pDst->unicast_cipher_count = 0U;
		pDst->auth_suite_count = 0U;
		return 0U;
	} else {
		pDst->multicast_cipher_present = 1U;
		if (unlikely(ielen < 4)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->multicast_cipher, pBuf, 4);
		pBuf += 4;
		ielen -= (uint8_t)4;
	}
	if (!ielen) {
		pDst->unicast_cipher_count = 0U;
		pDst->auth_suite_count = 0U;
		return 0U;
	} else {
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->unicast_cipher_count, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
	}
	if (unlikely(ielen < pDst->unicast_cipher_count * 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	if (pDst->unicast_cipher_count > 4) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->unicast_ciphers, pBuf, (pDst->unicast_cipher_count * 4));
	pBuf += (pDst->unicast_cipher_count * 4);
	ielen -= (pDst->unicast_cipher_count * 4);
	if (!ielen) {
		pDst->auth_suite_count = 0U;
		return 0U;
	} else {
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->auth_suite_count, pBuf, 0);
		pBuf += 2;
		ielen -= (uint8_t)2;
	}
	if (unlikely(ielen < pDst->auth_suite_count * 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	if (pDst->auth_suite_count > 4) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->auth_suites, pBuf, (pDst->auth_suite_count * 4));
	pBuf += (pDst->auth_suite_count * 4);
	ielen -= (pDst->auth_suite_count * 4);
	if (!ielen) {
		return 0U;
	} else {
		if (unlikely(ielen < 2)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		framesntohs(pCtx, &pDst->caps, pBuf, 0);
	}
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wpa. */

#define SigIeWPA (0x0073)


uint32_t dot11f_unpack_ie_wpa_opaque(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIEWPAOpaque *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_data = (uint8_t)(ielen);
	if (ielen > 249) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wpa_opaque. */

#define SigIeWPAOpaque (0x0074)


static const tTLVDefn TLVS_WSC[] = {
	{ offsetof(tDot11fIEWSC, Version), offsetof(tDot11fTLVVersion, present),
	"Version", SigTlvVersion, DOT11F_TLV_VERSION, 0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, WPSState), offsetof(tDot11fTLVWPSState, present),
	"WPSState", SigTlvWPSState, DOT11F_TLV_WPSSTATE, 0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, APSetupLocked),
	offsetof(tDot11fTLVAPSetupLocked, present), "APSetupLocked",
	SigTlvAPSetupLocked, DOT11F_TLV_APSETUPLOCKED, 0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, SelectedRegistrarConfigMethods),
	offsetof(tDot11fTLVSelectedRegistrarConfigMethods, present),
	"SelectedRegistrarConfigMethods", SigTlvSelectedRegistrarConfigMethods,
	DOT11F_TLV_SELECTEDREGISTRARCONFIGMETHODS, 0, 6, 6, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, UUID_E), offsetof(tDot11fTLVUUID_E, present),
	"UUID_E", SigTlvUUID_E, DOT11F_TLV_UUID_E, 0, 20, 20, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, UUID_R), offsetof(tDot11fTLVUUID_R, present),
	"UUID_R", SigTlvUUID_R, DOT11F_TLV_UUID_R, 0, 20, 20, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, RFBands), offsetof(tDot11fTLVRFBands, present),
	"RFBands", SigTlvRFBands, DOT11F_TLV_RFBANDS, 0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, SelectedRegistrar),
	offsetof(tDot11fTLVSelectedRegistrar, present), "SelectedRegistrar",
	SigTlvSelectedRegistrar, DOT11F_TLV_SELECTEDREGISTRAR,
	0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, ConfigMethods),
	offsetof(tDot11fTLVConfigMethods, present), "ConfigMethods",
	SigTlvConfigMethods, DOT11F_TLV_CONFIGMETHODS, 0, 6, 6, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, AssociationState),
	offsetof(tDot11fTLVAssociationState, present), "AssociationState",
	SigTlvAssociationState, DOT11F_TLV_ASSOCIATIONSTATE,
	0, 6, 6, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, ConfigurationError),
	offsetof(tDot11fTLVConfigurationError, present), "ConfigurationError",
	SigTlvConfigurationError, DOT11F_TLV_CONFIGURATIONERROR,
	0, 6, 6, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, Manufacturer), offsetof(tDot11fTLVManufacturer,
	present), "Manufacturer", SigTlvManufacturer, DOT11F_TLV_MANUFACTURER,
	0, 4, 68, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, ModelName), offsetof(tDot11fTLVModelName,
	present), "ModelName", SigTlvModelName, DOT11F_TLV_MODELNAME,
	0, 4, 36, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, ModelNumber), offsetof(tDot11fTLVModelNumber,
	present), "ModelNumber", SigTlvModelNumber, DOT11F_TLV_MODELNUMBER,
	0, 4, 36, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, SerialNumber), offsetof(tDot11fTLVSerialNumber,
	present), "SerialNumber", SigTlvSerialNumber, DOT11F_TLV_SERIALNUMBER,
	0, 4, 36, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, DeviceName), offsetof(tDot11fTLVDeviceName,
	present), "DeviceName", SigTlvDeviceName, DOT11F_TLV_DEVICENAME,
	0, 4, 36, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, DevicePasswordID),
	offsetof(tDot11fTLVDevicePasswordID, present), "DevicePasswordID",
	SigTlvDevicePasswordID, DOT11F_TLV_DEVICEPASSWORDID,
	0, 6, 6, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, PrimaryDeviceType),
	offsetof(tDot11fTLVPrimaryDeviceType, present), "PrimaryDeviceType",
	SigTlvPrimaryDeviceType, DOT11F_TLV_PRIMARYDEVICETYPE,
	0, 12, 12, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, RequestType), offsetof(tDot11fTLVRequestType,
	present), "RequestType", SigTlvRequestType, DOT11F_TLV_REQUESTTYPE,
	0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, ResponseType), offsetof(tDot11fTLVResponseType,
	present), "ResponseType", SigTlvResponseType, DOT11F_TLV_RESPONSETYPE,
	0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, VendorExtension),
	offsetof(tDot11fTLVVendorExtension, present), "VendorExtension",
	SigTlvVendorExtension, DOT11F_TLV_VENDOREXTENSION,
	0, 7, 21, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWSC, RequestDeviceType),
	offsetof(tDot11fTLVRequestDeviceType, present), "RequestDeviceType",
	SigTlvRequestDeviceType, DOT11F_TLV_REQUESTDEVICETYPE,
	0, 12, 12, 0, 2, 2, 1, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_wsc(tpAniSirGlobal pCtx,
			      uint8_t *pBuf,
			      uint8_t ielen,
			      tDot11fIEWSC *pDst,
			      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_WSC,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_wsc. */

#define SigIeWSC (0x0075)


static const tTLVDefn TLVS_WscAssocReq[] = {
	{ offsetof(tDot11fIEWscAssocReq, Version), offsetof(tDot11fTLVVersion,
	present), "Version", SigTlvVersion, DOT11F_TLV_VERSION,
	0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscAssocReq, RequestType),
	offsetof(tDot11fTLVRequestType, present), "RequestType",
	SigTlvRequestType, DOT11F_TLV_REQUESTTYPE, 0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscAssocReq, VendorExtension),
	offsetof(tDot11fTLVVendorExtension, present), "VendorExtension",
	SigTlvVendorExtension, DOT11F_TLV_VENDOREXTENSION,
	0, 7, 21, 0, 2, 2, 1, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_wsc_assoc_req(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEWscAssocReq *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_WscAssocReq,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_wsc_assoc_req. */

#define SigIeWscAssocReq (0x0076)


static const tTLVDefn TLVS_WscAssocRes[] = {
	{ offsetof(tDot11fIEWscAssocRes, Version), offsetof(tDot11fTLVVersion,
	present), "Version", SigTlvVersion, DOT11F_TLV_VERSION,
	0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscAssocRes, ResponseType),
	offsetof(tDot11fTLVResponseType, present), "ResponseType",
	SigTlvResponseType, DOT11F_TLV_RESPONSETYPE, 0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscAssocRes, VendorExtension),
	offsetof(tDot11fTLVVendorExtension, present), "VendorExtension",
	SigTlvVendorExtension, DOT11F_TLV_VENDOREXTENSION,
	0, 7, 21, 0, 2, 2, 1, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_wsc_assoc_res(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEWscAssocRes *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_WscAssocRes,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_wsc_assoc_res. */

#define SigIeWscAssocRes (0x0077)


static const tTLVDefn TLVS_WscBeacon[] = {
	{ offsetof(tDot11fIEWscBeacon, Version), offsetof(tDot11fTLVVersion,
	present), "Version", SigTlvVersion, DOT11F_TLV_VERSION,
	0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeacon, WPSState), offsetof(tDot11fTLVWPSState,
	present), "WPSState", SigTlvWPSState, DOT11F_TLV_WPSSTATE,
	0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeacon, APSetupLocked),
	offsetof(tDot11fTLVAPSetupLocked, present), "APSetupLocked",
	SigTlvAPSetupLocked, DOT11F_TLV_APSETUPLOCKED, 0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeacon, SelectedRegistrar),
	offsetof(tDot11fTLVSelectedRegistrar, present), "SelectedRegistrar",
	SigTlvSelectedRegistrar, DOT11F_TLV_SELECTEDREGISTRAR,
	0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeacon, DevicePasswordID),
	offsetof(tDot11fTLVDevicePasswordID, present), "DevicePasswordID",
	SigTlvDevicePasswordID, DOT11F_TLV_DEVICEPASSWORDID,
	0, 6, 6, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeacon, SelectedRegistrarConfigMethods),
	offsetof(tDot11fTLVSelectedRegistrarConfigMethods, present),
	"SelectedRegistrarConfigMethods", SigTlvSelectedRegistrarConfigMethods,
	DOT11F_TLV_SELECTEDREGISTRARCONFIGMETHODS, 0, 6, 6, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeacon, UUID_E), offsetof(tDot11fTLVUUID_E,
	present), "UUID_E", SigTlvUUID_E, DOT11F_TLV_UUID_E,
	0, 20, 20, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeacon, RFBands), offsetof(tDot11fTLVRFBands,
	present), "RFBands", SigTlvRFBands, DOT11F_TLV_RFBANDS,
	0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeacon, VendorExtension),
	offsetof(tDot11fTLVVendorExtension, present), "VendorExtension",
	SigTlvVendorExtension, DOT11F_TLV_VENDOREXTENSION,
	0, 7, 21, 0, 2, 2, 1, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_wsc_beacon(tpAniSirGlobal pCtx,
				    uint8_t *pBuf,
				    uint8_t ielen,
				    tDot11fIEWscBeacon *pDst,
				    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_WscBeacon,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_wsc_beacon. */

#define SigIeWscBeacon (0x0078)


static const tTLVDefn TLVS_WscBeaconProbeRes[] = {
	{ offsetof(tDot11fIEWscBeaconProbeRes, Version),
	offsetof(tDot11fTLVVersion, present), "Version", SigTlvVersion,
	DOT11F_TLV_VERSION, 0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, WPSState),
	offsetof(tDot11fTLVWPSState, present), "WPSState", SigTlvWPSState,
	DOT11F_TLV_WPSSTATE, 0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, APSetupLocked),
	offsetof(tDot11fTLVAPSetupLocked, present), "APSetupLocked",
	SigTlvAPSetupLocked, DOT11F_TLV_APSETUPLOCKED, 0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, SelectedRegistrar),
	offsetof(tDot11fTLVSelectedRegistrar, present), "SelectedRegistrar",
	SigTlvSelectedRegistrar, DOT11F_TLV_SELECTEDREGISTRAR,
	0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, DevicePasswordID),
	offsetof(tDot11fTLVDevicePasswordID, present), "DevicePasswordID",
	SigTlvDevicePasswordID, DOT11F_TLV_DEVICEPASSWORDID,
	0, 6, 6, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, SelectedRegistrarConfigMethods),
	offsetof(tDot11fTLVSelectedRegistrarConfigMethods, present),
	"SelectedRegistrarConfigMethods", SigTlvSelectedRegistrarConfigMethods,
	DOT11F_TLV_SELECTEDREGISTRARCONFIGMETHODS, 0, 6, 6, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, ResponseType),
	offsetof(tDot11fTLVResponseType, present), "ResponseType",
	SigTlvResponseType, DOT11F_TLV_RESPONSETYPE, 0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, UUID_E),
	offsetof(tDot11fTLVUUID_E, present), "UUID_E", SigTlvUUID_E,
	DOT11F_TLV_UUID_E, 0, 20, 20, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, Manufacturer),
	offsetof(tDot11fTLVManufacturer, present), "Manufacturer",
	SigTlvManufacturer, DOT11F_TLV_MANUFACTURER, 0, 4, 68, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, ModelName),
	offsetof(tDot11fTLVModelName, present), "ModelName", SigTlvModelName,
	DOT11F_TLV_MODELNAME, 0, 4, 36, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, ModelNumber),
	offsetof(tDot11fTLVModelNumber, present), "ModelNumber",
	SigTlvModelNumber, DOT11F_TLV_MODELNUMBER, 0, 4, 36, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, SerialNumber),
	offsetof(tDot11fTLVSerialNumber, present), "SerialNumber",
	SigTlvSerialNumber, DOT11F_TLV_SERIALNUMBER, 0, 4, 36, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, PrimaryDeviceType),
	offsetof(tDot11fTLVPrimaryDeviceType, present), "PrimaryDeviceType",
	SigTlvPrimaryDeviceType, DOT11F_TLV_PRIMARYDEVICETYPE,
	0, 12, 12, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, DeviceName),
	offsetof(tDot11fTLVDeviceName, present), "DeviceName", SigTlvDeviceName,
	DOT11F_TLV_DEVICENAME, 0, 4, 36, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, ConfigMethods),
	offsetof(tDot11fTLVConfigMethods, present), "ConfigMethods",
	SigTlvConfigMethods, DOT11F_TLV_CONFIGMETHODS, 0, 6, 6, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, RFBands),
	offsetof(tDot11fTLVRFBands, present), "RFBands", SigTlvRFBands,
	DOT11F_TLV_RFBANDS, 0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscBeaconProbeRes, VendorExtension),
	offsetof(tDot11fTLVVendorExtension, present), "VendorExtension",
	SigTlvVendorExtension, DOT11F_TLV_VENDOREXTENSION,
	0, 7, 21, 0, 2, 2, 1, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_wsc_beacon_probe_res(tpAniSirGlobal pCtx,
					    uint8_t *pBuf,
					    uint8_t ielen,
					    tDot11fIEWscBeaconProbeRes *pDst,
					    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_WscBeaconProbeRes,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_wsc_beacon_probe_res. */

#define SigIeWscBeaconProbeRes (0x0079)


uint32_t dot11f_unpack_ie_wsc_ie_opaque(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEWscIEOpaque *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_data = (uint8_t)(ielen);
	if (ielen > 249) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_wsc_ie_opaque. */

#define SigIeWscIEOpaque (0x007a)


static const tTLVDefn TLVS_WscProbeReq[] = {
	{ offsetof(tDot11fIEWscProbeReq, Version), offsetof(tDot11fTLVVersion,
	present), "Version", SigTlvVersion, DOT11F_TLV_VERSION,
	0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, RequestType),
	offsetof(tDot11fTLVRequestType, present), "RequestType",
	SigTlvRequestType, DOT11F_TLV_REQUESTTYPE, 0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, ConfigMethods),
	offsetof(tDot11fTLVConfigMethods, present), "ConfigMethods",
	SigTlvConfigMethods, DOT11F_TLV_CONFIGMETHODS, 0, 6, 6, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, UUID_E), offsetof(tDot11fTLVUUID_E,
	present), "UUID_E", SigTlvUUID_E, DOT11F_TLV_UUID_E,
	0, 20, 20, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, PrimaryDeviceType),
	offsetof(tDot11fTLVPrimaryDeviceType, present), "PrimaryDeviceType",
	SigTlvPrimaryDeviceType, DOT11F_TLV_PRIMARYDEVICETYPE,
	0, 12, 12, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, RFBands), offsetof(tDot11fTLVRFBands,
	present), "RFBands", SigTlvRFBands, DOT11F_TLV_RFBANDS,
	0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, AssociationState),
	offsetof(tDot11fTLVAssociationState, present), "AssociationState",
	SigTlvAssociationState, DOT11F_TLV_ASSOCIATIONSTATE,
	0, 6, 6, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, ConfigurationError),
	offsetof(tDot11fTLVConfigurationError, present), "ConfigurationError",
	SigTlvConfigurationError, DOT11F_TLV_CONFIGURATIONERROR,
	0, 6, 6, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, DevicePasswordID),
	offsetof(tDot11fTLVDevicePasswordID, present), "DevicePasswordID",
	SigTlvDevicePasswordID, DOT11F_TLV_DEVICEPASSWORDID,
	0, 6, 6, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, Manufacturer),
	offsetof(tDot11fTLVManufacturer, present), "Manufacturer",
	SigTlvManufacturer, DOT11F_TLV_MANUFACTURER, 0, 4, 68, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, ModelName),
	offsetof(tDot11fTLVModelName, present), "ModelName", SigTlvModelName,
	DOT11F_TLV_MODELNAME, 0, 4, 36, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, ModelNumber),
	offsetof(tDot11fTLVModelNumber, present), "ModelNumber",
	SigTlvModelNumber, DOT11F_TLV_MODELNUMBER, 0, 4, 36, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, DeviceName),
	offsetof(tDot11fTLVDeviceName, present), "DeviceName", SigTlvDeviceName,
	DOT11F_TLV_DEVICENAME, 0, 4, 36, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, VendorExtension),
	offsetof(tDot11fTLVVendorExtension, present), "VendorExtension",
	SigTlvVendorExtension, DOT11F_TLV_VENDOREXTENSION,
	0, 7, 21, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeReq, RequestDeviceType),
	offsetof(tDot11fTLVRequestDeviceType, present), "RequestDeviceType",
	SigTlvRequestDeviceType, DOT11F_TLV_REQUESTDEVICETYPE,
	0, 12, 12, 0, 2, 2, 1, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_wsc_probe_req(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEWscProbeReq *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_WscProbeReq,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_wsc_probe_req. */

#define SigIeWscProbeReq (0x007b)


static const tTLVDefn TLVS_WscProbeRes[] = {
	{ offsetof(tDot11fIEWscProbeRes, Version), offsetof(tDot11fTLVVersion,
	present), "Version", SigTlvVersion, DOT11F_TLV_VERSION,
	0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, WPSState), offsetof(tDot11fTLVWPSState,
	present), "WPSState", SigTlvWPSState, DOT11F_TLV_WPSSTATE,
	0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, APSetupLocked),
	offsetof(tDot11fTLVAPSetupLocked, present), "APSetupLocked",
	SigTlvAPSetupLocked, DOT11F_TLV_APSETUPLOCKED, 0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, SelectedRegistrar),
	offsetof(tDot11fTLVSelectedRegistrar, present), "SelectedRegistrar",
	SigTlvSelectedRegistrar, DOT11F_TLV_SELECTEDREGISTRAR,
	0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, DevicePasswordID),
	offsetof(tDot11fTLVDevicePasswordID, present), "DevicePasswordID",
	SigTlvDevicePasswordID, DOT11F_TLV_DEVICEPASSWORDID,
	0, 6, 6, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, SelectedRegistrarConfigMethods),
	offsetof(tDot11fTLVSelectedRegistrarConfigMethods, present),
	"SelectedRegistrarConfigMethods", SigTlvSelectedRegistrarConfigMethods,
	DOT11F_TLV_SELECTEDREGISTRARCONFIGMETHODS, 0, 6, 6, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, ResponseType),
	offsetof(tDot11fTLVResponseType, present), "ResponseType",
	SigTlvResponseType, DOT11F_TLV_RESPONSETYPE, 0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, UUID_E), offsetof(tDot11fTLVUUID_E,
	present), "UUID_E", SigTlvUUID_E, DOT11F_TLV_UUID_E,
	0, 20, 20, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, Manufacturer),
	offsetof(tDot11fTLVManufacturer, present), "Manufacturer",
	SigTlvManufacturer, DOT11F_TLV_MANUFACTURER, 0, 4, 68, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, ModelName),
	offsetof(tDot11fTLVModelName, present), "ModelName", SigTlvModelName,
	DOT11F_TLV_MODELNAME, 0, 4, 36, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, ModelNumber),
	offsetof(tDot11fTLVModelNumber, present), "ModelNumber",
	SigTlvModelNumber, DOT11F_TLV_MODELNUMBER, 0, 4, 36, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, SerialNumber),
	offsetof(tDot11fTLVSerialNumber, present), "SerialNumber",
	SigTlvSerialNumber, DOT11F_TLV_SERIALNUMBER, 0, 4, 36, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, PrimaryDeviceType),
	offsetof(tDot11fTLVPrimaryDeviceType, present), "PrimaryDeviceType",
	SigTlvPrimaryDeviceType, DOT11F_TLV_PRIMARYDEVICETYPE,
	0, 12, 12, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, DeviceName),
	offsetof(tDot11fTLVDeviceName, present), "DeviceName", SigTlvDeviceName,
	DOT11F_TLV_DEVICENAME, 0, 4, 36, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, ConfigMethods),
	offsetof(tDot11fTLVConfigMethods, present), "ConfigMethods",
	SigTlvConfigMethods, DOT11F_TLV_CONFIGMETHODS, 0, 6, 6, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, RFBands), offsetof(tDot11fTLVRFBands,
	present), "RFBands", SigTlvRFBands, DOT11F_TLV_RFBANDS,
	0, 5, 5, 0, 2, 2, 1, },
	{ offsetof(tDot11fIEWscProbeRes, VendorExtension),
	offsetof(tDot11fTLVVendorExtension, present), "VendorExtension",
	SigTlvVendorExtension, DOT11F_TLV_VENDOREXTENSION,
	0, 7, 21, 0, 2, 2, 1, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_wsc_probe_res(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEWscProbeRes *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_WscProbeRes,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_wsc_probe_res. */

#define SigIeWscProbeRes (0x007c)


static const tTLVDefn TLVS_WscReassocRes[] = {
	{ offsetof(tDot11fIEWscReassocRes, Version), offsetof(tDot11fTLVVersion,
	present), "Version", SigTlvVersion, DOT11F_TLV_VERSION,
	0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscReassocRes, ResponseType),
	offsetof(tDot11fTLVResponseType, present), "ResponseType",
	SigTlvResponseType, DOT11F_TLV_RESPONSETYPE, 0, 5, 5, 1, 2, 2, 1, },
	{ offsetof(tDot11fIEWscReassocRes, VendorExtension),
	offsetof(tDot11fTLVVendorExtension, present), "VendorExtension",
	SigTlvVendorExtension, DOT11F_TLV_VENDOREXTENSION,
	0, 7, 21, 0, 2, 2, 1, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_wsc_reassoc_res(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEWscReassocRes *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_WscReassocRes,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_wsc_reassoc_res. */

#define SigIeWscReassocRes (0x007d)


uint32_t dot11f_unpack_ie_addba_extn_element(tpAniSirGlobal pCtx,
					     uint8_t *pBuf,
					     uint8_t ielen,
					     tDot11fIEaddba_extn_element *pDst,
					     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp75__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp75__ = *pBuf;
	pDst->no_fragmentation = tmp75__ >> 0 & 0x1;
	pDst->he_frag_operation = tmp75__ >> 1 & 0x3;
	pDst->reserved = tmp75__ >> 3 & 0x1f;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_addba_extn_element. */

#define SigIeaddba_extn_element (0x007e)


uint32_t dot11f_unpack_ie_bss_color_change(tpAniSirGlobal pCtx,
					   uint8_t *pBuf,
					   uint8_t ielen,
					   tDot11fIEbss_color_change *pDst,
					   bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp76__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->countdown = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp76__ = *pBuf;
	pDst->new_color = tmp76__ >> 0 & 0x3f;
	pDst->reserved = tmp76__ >> 6 & 0x3;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_bss_color_change. */

#define SigIebss_color_change (0x007f)


static const tFFDefn FFS_decriptor_element[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_decriptor_element[] = {
	{ offsetof(tDot11fIEdecriptor_element, tclas_mask),
	offsetof(tDot11fIEtclas_mask, present), 0, "tclas_mask",
	0, 20, 20, SigIetclas_mask, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TCLAS_MASK, 89, 0, },
	{ offsetof(tDot11fIEdecriptor_element, mscs_status),
	offsetof(tDot11fIEmscs_status, present), 0, "mscs_status",
	0, 3, 3, SigIemscs_status, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MSCS_STATUS, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },
};

uint32_t dot11f_unpack_ie_decriptor_element(tpAniSirGlobal pCtx,
					    uint8_t *pBuf,
					    uint8_t ielen,
					    tDot11fIEdecriptor_element *pDst,
					    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->request_type = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->user_priority_control, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &pDst->stream_timeout, pBuf, 0);
	pBuf += 4;
	ielen -= (uint8_t)4;
	(void)pCtx;
	status |= unpack_core(pCtx,
				pBuf,
				ielen,
				FFS_decriptor_element,
				IES_decriptor_element,
				(uint8_t *)pDst,
				sizeof(*pDst),
				append_ie);
	return status;
} /* End dot11f_unpack_ie_decriptor_element. */

#define SigIedecriptor_element (0x0080)


uint32_t dot11f_unpack_ie_dh_parameter_element(tpAniSirGlobal pCtx,
					       uint8_t *pBuf,
					       uint8_t ielen,
					       tDot11fIEdh_parameter_element *pDst,
					       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->group, pBuf, 2);
	pBuf += 2;
	ielen -= (uint8_t)2;
	pDst->num_public_key = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->public_key, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_dh_parameter_element. */

#define SigIedh_parameter_element (0x0081)


uint32_t dot11f_unpack_ie_esp_information(tpAniSirGlobal pCtx,
					  uint8_t *pBuf,
					  uint8_t ielen,
					  tDot11fIEesp_information *pDst,
					  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_data = (uint8_t)(ielen);
	if (ielen > 96) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_esp_information. */

#define SigIeesp_information (0x0082)


uint32_t dot11f_unpack_ie_ext_chan_switch_ann(tpAniSirGlobal pCtx,
					      uint8_t *pBuf,
					      uint8_t ielen,
					      tDot11fIEext_chan_switch_ann *pDst,
					      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->switch_mode = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->new_reg_class = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->new_channel = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->switch_count = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ext_chan_switch_ann. */

#define SigIeext_chan_switch_ann (0x0083)


uint32_t dot11f_unpack_ie_fils_assoc_delay_info(tpAniSirGlobal pCtx,
						 uint8_t *pBuf,
						 uint8_t ielen,
						 tDot11fIEfils_assoc_delay_info *pDst,
						 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->assoc_delay_info = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fils_assoc_delay_info. */

#define SigIefils_assoc_delay_info (0x0084)


uint32_t dot11f_unpack_ie_fils_hlp_container(tpAniSirGlobal pCtx,
					     uint8_t *pBuf,
					     uint8_t ielen,
					     tDot11fIEfils_hlp_container *pDst,
					     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->dest_mac, pBuf, 6);
	pBuf += 6;
	ielen -= (uint8_t)6;
	if (unlikely(ielen < 6)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->src_mac, pBuf, 6);
	pBuf += 6;
	ielen -= (uint8_t)6;
	pDst->num_hlp_packet = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->hlp_packet, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fils_hlp_container. */

#define SigIefils_hlp_container (0x0085)


uint32_t dot11f_unpack_ie_fils_indication(tpAniSirGlobal pCtx,
					  uint8_t *pBuf,
					  uint8_t ielen,
					  tDot11fIEfils_indication *pDst,
					  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint16_t tmp77__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp77__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->public_key_identifiers_cnt = tmp77__ >> 0 & 0x7;
	pDst->realm_identifiers_cnt = tmp77__ >> 3 & 0x7;
	pDst->is_ip_config_supported = tmp77__ >> 6 & 0x1;
	pDst->is_cache_id_present = tmp77__ >> 7 & 0x1;
	pDst->is_hessid_present = tmp77__ >> 8 & 0x1;
	pDst->is_fils_sk_auth_supported = tmp77__ >> 9 & 0x1;
	pDst->is_fils_sk_auth_pfs_supported = tmp77__ >> 10 & 0x1;
	pDst->is_pk_auth_supported = tmp77__ >> 11 & 0x1;
	pDst->reserved = tmp77__ >> 12 & 0xf;
	pDst->num_variable_data = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->variable_data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fils_indication. */

#define SigIefils_indication (0x0086)


uint32_t dot11f_unpack_ie_fils_kde(tpAniSirGlobal pCtx,
				   uint8_t *pBuf,
				   uint8_t ielen,
				   tDot11fIEfils_kde *pDst,
				   bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 8)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->key_rsc, pBuf, 8);
	pBuf += 8;
	ielen -= (uint8_t)8;
	pDst->num_kde_list = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->kde_list, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fils_kde. */

#define SigIefils_kde (0x0087)


uint32_t dot11f_unpack_ie_fils_key_confirmation(tpAniSirGlobal pCtx,
						 uint8_t *pBuf,
						 uint8_t ielen,
						 tDot11fIEfils_key_confirmation *pDst,
						 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_key_auth = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->key_auth, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fils_key_confirmation. */

#define SigIefils_key_confirmation (0x0088)


uint32_t dot11f_unpack_ie_fils_nonce(tpAniSirGlobal pCtx,
				     uint8_t *pBuf,
				     uint8_t ielen,
				     tDot11fIEfils_nonce *pDst,
				     bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 16)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->nonce, pBuf, 16);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fils_nonce. */

#define SigIefils_nonce (0x0089)


uint32_t dot11f_unpack_ie_fils_public_key(tpAniSirGlobal pCtx,
					  uint8_t *pBuf,
					  uint8_t ielen,
					  tDot11fIEfils_public_key *pDst,
					  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->key_type = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	pDst->num_public_key = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->public_key, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fils_public_key. */

#define SigIefils_public_key (0x008a)


uint32_t dot11f_unpack_ie_fils_session(tpAniSirGlobal pCtx,
				       uint8_t *pBuf,
				       uint8_t ielen,
				       tDot11fIEfils_session *pDst,
				       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 8)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->session, pBuf, 8);
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fils_session. */

#define SigIefils_session (0x008b)


uint32_t dot11f_unpack_ie_fils_wrapped_data(tpAniSirGlobal pCtx,
					    uint8_t *pBuf,
					    uint8_t ielen,
					    tDot11fIEfils_wrapped_data *pDst,
					    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_wrapped_data = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->wrapped_data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fils_wrapped_data. */

#define SigIefils_wrapped_data (0x008c)


uint32_t dot11f_unpack_ie_fragment_ie(tpAniSirGlobal pCtx,
				      uint8_t *pBuf,
				      uint8_t ielen,
				      tDot11fIEfragment_ie *pDst,
				      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_data = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_fragment_ie. */

#define SigIefragment_ie (0x008d)


uint32_t dot11f_unpack_ie_he_6ghz_band_cap(tpAniSirGlobal pCtx,
					   uint8_t *pBuf,
					   uint8_t ielen,
					   tDot11fIEhe_6ghz_band_cap *pDst,
					   bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint16_t tmp78__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp78__, pBuf, 0);
	pDst->min_mpdu_start_spacing = tmp78__ >> 0 & 0x7;
	pDst->max_ampdu_len_exp = tmp78__ >> 3 & 0x7;
	pDst->max_mpdu_len = tmp78__ >> 6 & 0x7;
	pDst->sm_pow_save = tmp78__ >> 9 & 0x3;
	pDst->rd_responder = tmp78__ >> 11 & 0x1;
	pDst->rx_ant_pattern_consistency = tmp78__ >> 12 & 0x1;
	pDst->tx_ant_pattern_consistency = tmp78__ >> 13 & 0x1;
	pDst->reserved = tmp78__ >> 14 & 0x3;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_he_6ghz_band_cap. */

#define SigIehe_6ghz_band_cap (0x008e)


uint32_t dot11f_unpack_ie_he_cap(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIEhe_cap *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t tmp79__;
	uint16_t tmp80__;
	uint32_t tmp81__;
	uint32_t tmp82__;
	uint16_t tmp83__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &tmp79__, pBuf, 0);
	pBuf += 4;
	ielen -= 4;
	pDst->htc_he = tmp79__ >> 0 & 0x1;
	pDst->twt_request = tmp79__ >> 1 & 0x1;
	pDst->twt_responder = tmp79__ >> 2 & 0x1;
	pDst->fragmentation = tmp79__ >> 3 & 0x3;
	pDst->max_num_frag_msdu_amsdu_exp = tmp79__ >> 5 & 0x7;
	pDst->min_frag_size = tmp79__ >> 8 & 0x3;
	pDst->trigger_frm_mac_pad = tmp79__ >> 10 & 0x3;
	pDst->multi_tid_aggr_rx_supp = tmp79__ >> 12 & 0x7;
	pDst->he_link_adaptation = tmp79__ >> 15 & 0x3;
	pDst->all_ack = tmp79__ >> 17 & 0x1;
	pDst->trigd_rsp_sched = tmp79__ >> 18 & 0x1;
	pDst->a_bsr = tmp79__ >> 19 & 0x1;
	pDst->broadcast_twt = tmp79__ >> 20 & 0x1;
	pDst->ba_32bit_bitmap = tmp79__ >> 21 & 0x1;
	pDst->mu_cascade = tmp79__ >> 22 & 0x1;
	pDst->ack_enabled_multitid = tmp79__ >> 23 & 0x1;
	pDst->reserved = tmp79__ >> 24 & 0x1;
	pDst->omi_a_ctrl = tmp79__ >> 25 & 0x1;
	pDst->ofdma_ra = tmp79__ >> 26 & 0x1;
	pDst->max_ampdu_len_exp_ext = tmp79__ >> 27 & 0x3;
	pDst->amsdu_frag = tmp79__ >> 29 & 0x1;
	pDst->flex_twt_sched = tmp79__ >> 30 & 0x1;
	pDst->rx_ctrl_frame = tmp79__ >> 31 & 0x1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp80__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->bsrp_ampdu_aggr = tmp80__ >> 0 & 0x1;
	pDst->qtp = tmp80__ >> 1 & 0x1;
	pDst->a_bqr = tmp80__ >> 2 & 0x1;
	pDst->spatial_reuse_param_rspder = tmp80__ >> 3 & 0x1;
	pDst->ndp_feedback_supp = tmp80__ >> 4 & 0x1;
	pDst->ops_supp = tmp80__ >> 5 & 0x1;
	pDst->amsdu_in_ampdu = tmp80__ >> 6 & 0x1;
	pDst->multi_tid_aggr_tx_supp = tmp80__ >> 7 & 0x7;
	pDst->he_sub_ch_sel_tx_supp = tmp80__ >> 10 & 0x1;
	pDst->ul_2x996_tone_ru_supp = tmp80__ >> 11 & 0x1;
	pDst->om_ctrl_ul_mu_data_dis_rx = tmp80__ >> 12 & 0x1;
	pDst->he_dynamic_smps = tmp80__ >> 13 & 0x1;
	pDst->punctured_sounding_supp = tmp80__ >> 14 & 0x1;
	pDst->ht_vht_trg_frm_rx_supp = tmp80__ >> 15 & 0x1;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &tmp81__, pBuf, 0);
	pBuf += 4;
	ielen -= 4;
	pDst->reserved2 = tmp81__ >> 0 & 0x1;
	pDst->chan_width_0 = tmp81__ >> 1 & 0x1;
	pDst->chan_width_1 = tmp81__ >> 2 & 0x1;
	pDst->chan_width_2 = tmp81__ >> 3 & 0x1;
	pDst->chan_width_3 = tmp81__ >> 4 & 0x1;
	pDst->chan_width_4 = tmp81__ >> 5 & 0x1;
	pDst->chan_width_5 = tmp81__ >> 6 & 0x1;
	pDst->chan_width_6 = tmp81__ >> 7 & 0x1;
	pDst->rx_pream_puncturing = tmp81__ >> 8 & 0xf;
	pDst->device_class = tmp81__ >> 12 & 0x1;
	pDst->ldpc_coding = tmp81__ >> 13 & 0x1;
	pDst->he_1x_ltf_800_gi_ppdu = tmp81__ >> 14 & 0x1;
	pDst->midamble_tx_rx_max_nsts = tmp81__ >> 15 & 0x3;
	pDst->he_4x_ltf_3200_gi_ndp = tmp81__ >> 17 & 0x1;
	pDst->tb_ppdu_tx_stbc_lt_80mhz = tmp81__ >> 18 & 0x1;
	pDst->rx_stbc_lt_80mhz = tmp81__ >> 19 & 0x1;
	pDst->doppler = tmp81__ >> 20 & 0x3;
	pDst->ul_mu = tmp81__ >> 22 & 0x3;
	pDst->dcm_enc_tx = tmp81__ >> 24 & 0x7;
	pDst->dcm_enc_rx = tmp81__ >> 27 & 0x7;
	pDst->ul_he_mu = tmp81__ >> 30 & 0x1;
	pDst->su_beamformer = tmp81__ >> 31 & 0x1;
	if (unlikely(ielen < 4)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohl(pCtx, &tmp82__, pBuf, 0);
	pBuf += 4;
	ielen -= 4;
	pDst->su_beamformee = tmp82__ >> 0 & 0x1;
	pDst->mu_beamformer = tmp82__ >> 1 & 0x1;
	pDst->bfee_sts_lt_80 = tmp82__ >> 2 & 0x7;
	pDst->bfee_sts_gt_80 = tmp82__ >> 5 & 0x7;
	pDst->num_sounding_lt_80 = tmp82__ >> 8 & 0x7;
	pDst->num_sounding_gt_80 = tmp82__ >> 11 & 0x7;
	pDst->su_feedback_tone16 = tmp82__ >> 14 & 0x1;
	pDst->mu_feedback_tone16 = tmp82__ >> 15 & 0x1;
	pDst->codebook_su = tmp82__ >> 16 & 0x1;
	pDst->codebook_mu = tmp82__ >> 17 & 0x1;
	pDst->beamforming_feedback = tmp82__ >> 18 & 0x7;
	pDst->he_er_su_ppdu = tmp82__ >> 21 & 0x1;
	pDst->dl_mu_mimo_part_bw = tmp82__ >> 22 & 0x1;
	pDst->ppet_present = tmp82__ >> 23 & 0x1;
	pDst->srp = tmp82__ >> 24 & 0x1;
	pDst->power_boost = tmp82__ >> 25 & 0x1;
	pDst->he_ltf_800_gi_4x = tmp82__ >> 26 & 0x1;
	pDst->max_nc = tmp82__ >> 27 & 0x7;
	pDst->tb_ppdu_tx_stbc_gt_80mhz = tmp82__ >> 30 & 0x1;
	pDst->rx_stbc_gt_80mhz = tmp82__ >> 31 & 0x1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp83__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->er_he_ltf_800_gi_4x = tmp83__ >> 0 & 0x1;
	pDst->he_ppdu_20_in_40Mhz_2G = tmp83__ >> 1 & 0x1;
	pDst->he_ppdu_20_in_160_80p80Mhz = tmp83__ >> 2 & 0x1;
	pDst->he_ppdu_80_in_160_80p80Mhz = tmp83__ >> 3 & 0x1;
	pDst->er_1x_he_ltf_gi = tmp83__ >> 4 & 0x1;
	pDst->midamble_tx_rx_1x_he_ltf = tmp83__ >> 5 & 0x1;
	pDst->dcm_max_bw = tmp83__ >> 6 & 0x3;
	pDst->longer_than_16_he_sigb_ofdm_sym = tmp83__ >> 8 & 0x1;
	pDst->non_trig_cqi_feedback = tmp83__ >> 9 & 0x1;
	pDst->tx_1024_qam_lt_242_tone_ru = tmp83__ >> 10 & 0x1;
	pDst->rx_1024_qam_lt_242_tone_ru = tmp83__ >> 11 & 0x1;
	pDst->rx_full_bw_su_he_mu_compress_sigb = tmp83__ >> 12 & 0x1;
	pDst->rx_full_bw_su_he_mu_non_cmpr_sigb = tmp83__ >> 13 & 0x1;
	pDst->reserved3 = tmp83__ >> 14 & 0x3;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->reserved4 = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->rx_he_mcs_map_lt_80, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &pDst->tx_he_mcs_map_lt_80, pBuf, 0);
	pBuf += 2;
	ielen -= (uint8_t)2;
	if (unlikely(ielen < pDst->chan_width_2 * 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	if (pDst->chan_width_2 > 1) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->rx_he_mcs_map_160, pBuf, (pDst->chan_width_2 * 2));
	pBuf += (pDst->chan_width_2 * 2);
	ielen -= (pDst->chan_width_2 * 2);
	if (unlikely(ielen < pDst->chan_width_2 * 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	if (pDst->chan_width_2 > 1) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->tx_he_mcs_map_160, pBuf, (pDst->chan_width_2 * 2));
	pBuf += (pDst->chan_width_2 * 2);
	ielen -= (pDst->chan_width_2 * 2);
	if (unlikely(ielen < pDst->chan_width_3 * 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	if (pDst->chan_width_3 > 1) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->rx_he_mcs_map_80_80, pBuf, (pDst->chan_width_3 * 2));
	pBuf += (pDst->chan_width_3 * 2);
	ielen -= (pDst->chan_width_3 * 2);
	if (unlikely(ielen < pDst->chan_width_3 * 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	if (pDst->chan_width_3 > 1) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->tx_he_mcs_map_80_80, pBuf, (pDst->chan_width_3 * 2));
	pBuf += (pDst->chan_width_3 * 2);
	ielen -= (pDst->chan_width_3 * 2);
	switch (pDst->ppet_present) {
	case 1:
		pDst->ppet.ppe_threshold.num_ppe_th = (uint8_t)(ielen);
		if (ielen > 25) {
				pDst->present = 0;
				return DOT11F_SKIPPED_BAD_IE;
		}

		DOT11F_MEMCPY(pCtx, pDst->ppet.ppe_threshold.ppe_th, pBuf, (ielen));
		pBuf += (ielen);
		ielen -= (ielen);
		break;
	}
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_he_cap. */

#define SigIehe_cap (0x008f)


uint32_t dot11f_unpack_ie_he_op(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIEhe_op *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint16_t tmp84__;
	uint8_t tmp85__;
	uint8_t tmp86__;
	uint8_t tmp87__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	framesntohs(pCtx, &tmp84__, pBuf, 0);
	pBuf += 2;
	ielen -= 2;
	pDst->default_pe = tmp84__ >> 0 & 0x7;
	pDst->twt_required = tmp84__ >> 3 & 0x1;
	pDst->txop_rts_threshold = tmp84__ >> 4 & 0x3ff;
	pDst->vht_oper_present = tmp84__ >> 14 & 0x1;
	pDst->co_located_bss = tmp84__ >> 15 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp85__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->er_su_disable = tmp85__ >> 0 & 0x1;
	pDst->oper_info_6g_present = tmp85__ >> 1 & 0x1;
	pDst->reserved2 = tmp85__ >> 2 & 0x3f;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp86__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->bss_color = tmp86__ >> 0 & 0x3f;
	pDst->partial_bss_col = tmp86__ >> 6 & 0x1;
	pDst->bss_col_disabled = tmp86__ >> 7 & 0x1;
	if (unlikely(ielen < 2)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->basic_mcs_nss, pBuf, 2);
	pBuf += 2;
	ielen -= (uint8_t)2;
	switch (pDst->vht_oper_present) {
	case 1:
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->vht_oper.info.chan_width = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->vht_oper.info.center_freq_seg0 = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->vht_oper.info.center_freq_seg1 = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		break;
	}
	switch (pDst->co_located_bss) {
	case 1:
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->maxbssid_ind.info.data = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		break;
	}
	switch (pDst->oper_info_6g_present) {
	case 1:
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->oper_info_6g.info.primary_ch = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		tmp87__ = *pBuf;
		pBuf += 1;
		ielen -= 1;
		pDst->oper_info_6g.info.ch_width = tmp87__ >> 0 & 0x3;
		pDst->oper_info_6g.info.dup_bcon = tmp87__ >> 2 & 0x1;
		pDst->oper_info_6g.info.reg_info = tmp87__ >> 3 & 0x7;
		pDst->oper_info_6g.info.reserved = tmp87__ >> 6 & 0x3;
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->oper_info_6g.info.center_freq_seg0 = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->oper_info_6g.info.center_freq_seg1 = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		if (unlikely(ielen < 1)) {
			pDst->present = 0;
			return DOT11F_INCOMPLETE_IE;
		}

		pDst->oper_info_6g.info.min_rate = *pBuf;
		pBuf += 1;
		ielen -= (uint8_t)1;
		break;
	}
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_he_op. */

#define SigIehe_op (0x0090)


uint32_t dot11f_unpack_ie_hs20vendor_ie(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEhs20vendor_ie *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp88__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp88__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->dgaf_dis = tmp88__ >> 0 & 0x1;
	pDst->hs_id_present = tmp88__ >> 1 & 0x3;
	pDst->reserved = tmp88__ >> 3 & 0x1;
	pDst->release_num = tmp88__ >> 4 & 0xf;
	if (!ielen) {
		return 0U;
	} else {
		switch (pDst->hs_id_present) {
		case 1:
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->hs_id.pps_mo.pps_mo_id, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			break;
		case 2:
			if (unlikely(ielen < 2)) {
				pDst->present = 0;
				return DOT11F_INCOMPLETE_IE;
			}

			framesntohs(pCtx, &pDst->hs_id.anqp_domain.anqp_domain_id, pBuf, 0);
			pBuf += 2;
			ielen -= (uint8_t)2;
			break;
		}
	}
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_hs20vendor_ie. */

#define SigIehs20vendor_ie (0x0091)


uint32_t dot11f_unpack_ie_ht2040_bss_coexistence(tpAniSirGlobal pCtx,
						 uint8_t *pBuf,
						 uint8_t ielen,
						 tDot11fIEht2040_bss_coexistence *pDst,
						 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp89__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp89__ = *pBuf;
	pDst->info_request = tmp89__ >> 0 & 0x1;
	pDst->forty_mhz_intolerant = tmp89__ >> 1 & 0x1;
	pDst->twenty_mhz_bsswidth_req = tmp89__ >> 2 & 0x1;
	pDst->obss_scan_exemption_req = tmp89__ >> 3 & 0x1;
	pDst->obss_scan_exemption_grant = tmp89__ >> 4 & 0x1;
	pDst->unused = tmp89__ >> 5 & 0x7;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ht2040_bss_coexistence. */

#define SigIeht2040_bss_coexistence (0x0092)


uint32_t dot11f_unpack_ie_ht2040_bss_intolerant_report(tpAniSirGlobal pCtx,
						       uint8_t *pBuf,
						       uint8_t ielen,
						       tDot11fIEht2040_bss_intolerant_report *pDst,
						       bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->operating_class = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	pDst->num_channel_list = (uint8_t)(ielen);
	if (ielen > 50) {
		pDst->present = 0;
		return DOT11F_SKIPPED_BAD_IE;
	}

	DOT11F_MEMCPY(pCtx, pDst->channel_list, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_ht2040_bss_intolerant_report. */

#define SigIeht2040_bss_intolerant_report (0x0093)


uint32_t dot11f_unpack_ie_mu_edca_param_set(tpAniSirGlobal pCtx,
					    uint8_t *pBuf,
					    uint8_t ielen,
					    tDot11fIEmu_edca_param_set *pDst,
					    bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint8_t tmp90__;
	uint8_t tmp91__;
	uint8_t tmp92__;
	uint8_t tmp93__;
	uint8_t tmp94__;
	uint8_t tmp95__;
	uint8_t tmp96__;
	uint8_t tmp97__;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->qos = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp90__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acbe_aifsn = tmp90__ >> 0 & 0xf;
	pDst->acbe_acm = tmp90__ >> 4 & 0x1;
	pDst->acbe_aci = tmp90__ >> 5 & 0x3;
	pDst->unused1 = tmp90__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp91__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acbe_acwmin = tmp91__ >> 0 & 0xf;
	pDst->acbe_acwmax = tmp91__ >> 4 & 0xf;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->acbe_muedca_timer = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp92__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acbk_aifsn = tmp92__ >> 0 & 0xf;
	pDst->acbk_acm = tmp92__ >> 4 & 0x1;
	pDst->acbk_aci = tmp92__ >> 5 & 0x3;
	pDst->unused2 = tmp92__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp93__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acbk_acwmin = tmp93__ >> 0 & 0xf;
	pDst->acbk_acwmax = tmp93__ >> 4 & 0xf;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->acbk_muedca_timer = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp94__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acvi_aifsn = tmp94__ >> 0 & 0xf;
	pDst->acvi_acm = tmp94__ >> 4 & 0x1;
	pDst->acvi_aci = tmp94__ >> 5 & 0x3;
	pDst->unused3 = tmp94__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp95__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acvi_acwmin = tmp95__ >> 0 & 0xf;
	pDst->acvi_acwmax = tmp95__ >> 4 & 0xf;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->acvi_muedca_timer = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp96__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acvo_aifsn = tmp96__ >> 0 & 0xf;
	pDst->acvo_acm = tmp96__ >> 4 & 0x1;
	pDst->acvo_aci = tmp96__ >> 5 & 0x3;
	pDst->unused4 = tmp96__ >> 7 & 0x1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	tmp97__ = *pBuf;
	pBuf += 1;
	ielen -= 1;
	pDst->acvo_acwmin = tmp97__ >> 0 & 0xf;
	pDst->acvo_acwmax = tmp97__ >> 4 & 0xf;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->acvo_muedca_timer = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_mu_edca_param_set. */

#define SigIemu_edca_param_set (0x0094)


uint32_t dot11f_unpack_ie_oci(tpAniSirGlobal pCtx,
			      uint8_t *pBuf,
			      uint8_t ielen,
			      tDot11fIEoci *pDst,
			      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->op_class = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->prim_ch_num = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->freq_seg_1_ch_num = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_oci. */

#define SigIeoci (0x0095)


uint32_t dot11f_unpack_ie_osen_ie(tpAniSirGlobal pCtx,
				  uint8_t *pBuf,
				  uint8_t ielen,
				  tDot11fIEosen_ie *pDst,
				  bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_data = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_osen_ie. */

#define SigIeosen_ie (0x0096)


static const tTLVDefn TLVS_qcn_ie[] = {
	{ offsetof(tDot11fIEqcn_ie, qcn_version), offsetof(tDot11fTLVqcn_version,
	present), "qcn_version", SigTlvqcn_version, DOT11F_TLV_QCN_VERSION,
	0, 4, 4, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEqcn_ie, vht_mcs11_attr),
	offsetof(tDot11fTLVvht_mcs11_attr, present), "vht_mcs11_attr",
	SigTlvvht_mcs11_attr, DOT11F_TLV_VHT_MCS11_ATTR, 0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEqcn_ie, he_400ns_sgi_attr),
	offsetof(tDot11fTLVhe_400ns_sgi_attr, present), "he_400ns_sgi_attr",
	SigTlvhe_400ns_sgi_attr, DOT11F_TLV_HE_400NS_SGI_ATTR,
	0, 5, 5, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEqcn_ie, he_2xltf_160mhz_supp),
	offsetof(tDot11fTLVhe_2xltf_160mhz_supp, present),
	"he_2xltf_160mhz_supp", SigTlvhe_2xltf_160mhz_supp,
	DOT11F_TLV_HE_2XLTF_160MHZ_SUPP, 0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEqcn_ie, he_dl_ofdma_attr),
	offsetof(tDot11fTLVhe_dl_ofdma_attr, present), "he_dl_ofdma_attr",
	SigTlvhe_dl_ofdma_attr, DOT11F_TLV_HE_DL_OFDMA_ATTR,
	0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEqcn_ie, trans_reasonp_attr),
	offsetof(tDot11fTLVtrans_reasonp_attr, present), "trans_reasonp_attr",
	SigTlvtrans_reasonp_attr, DOT11F_TLV_TRANS_REASONP_ATTR,
	0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEqcn_ie, trans_rejectp_attr),
	offsetof(tDot11fTLVtrans_rejectp_attr, present), "trans_rejectp_attr",
	SigTlvtrans_rejectp_attr, DOT11F_TLV_TRANS_REJECTP_ATTR,
	0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEqcn_ie, he_dl_mumimo_attr),
	offsetof(tDot11fTLVhe_dl_mumimo_attr, present), "he_dl_mumimo_attr",
	SigTlvhe_dl_mumimo_attr, DOT11F_TLV_HE_DL_MUMIMO_ATTR,
	0, 3, 3, 0, 1, 1, 0, },
	{ offsetof(tDot11fIEqcn_ie, he_mcs13_attr),
	offsetof(tDot11fTLVhe_mcs13_attr, present), "he_mcs13_attr",
	SigTlvhe_mcs13_attr, DOT11F_TLV_HE_MCS13_ATTR, 0, 4, 4, 0, 1, 1, 0, },
	{0, 0, NULL, 0, 0xffff, 0, 0, 0, 0, 0, 0},
};

uint32_t dot11f_unpack_ie_qcn_ie(tpAniSirGlobal pCtx,
				 uint8_t *pBuf,
				 uint8_t ielen,
				 tDot11fIEqcn_ie *pDst,
				 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pBuf; (void)ielen; /* Shutup the compiler */
	pDst->present = 1;
	status = unpack_tlv_core(pCtx, pBuf, ielen,
			TLVS_qcn_ie,
			(uint8_t *)pDst, sizeof(*pDst));
	return status;
} /* End dot11f_unpack_ie_qcn_ie. */

#define SigIeqcn_ie (0x0097)


uint32_t dot11f_unpack_ie_roaming_consortium_sel(tpAniSirGlobal pCtx,
						 uint8_t *pBuf,
						 uint8_t ielen,
						 tDot11fIEroaming_consortium_sel *pDst,
						 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	pDst->num_data = (uint8_t)(ielen);
	DOT11F_MEMCPY(pCtx, pDst->data, pBuf, (ielen));
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_roaming_consortium_sel. */

#define SigIeroaming_consortium_sel (0x0098)


uint32_t dot11f_unpack_ie_sec_chan_offset_ele(tpAniSirGlobal pCtx,
					      uint8_t *pBuf,
					      uint8_t ielen,
					      tDot11fIEsec_chan_offset_ele *pDst,
					      bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->secondaryChannelOffset = *pBuf;
	(void)pCtx;
	return status;
} /* End dot11f_unpack_ie_sec_chan_offset_ele. */

#define SigIesec_chan_offset_ele (0x0099)


static const tFFDefn FFS_vendor_vht_ie[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_vendor_vht_ie[] = {
	{ offsetof(tDot11fIEvendor_vht_ie, VHTCaps), offsetof(tDot11fIEVHTCaps,
	present), 0, "VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fIEvendor_vht_ie, VHTOperation),
	offsetof(tDot11fIEVHTOperation, present), 0, "VHTOperation",
	0, 7, 7, SigIeVHTOperation, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTOPERATION, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },
};

uint32_t dot11f_unpack_ie_vendor_vht_ie(tpAniSirGlobal pCtx,
					 uint8_t *pBuf,
					 uint8_t ielen,
					 tDot11fIEvendor_vht_ie *pDst,
					 bool append_ie)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void) pBuf; (void)ielen; /* Shutup the compiler */
	if (pDst->present)
		return DOT11F_DUPLICATE_IE;
	pDst->present = 1;
	if (unlikely(ielen < 1)) {
		pDst->present = 0;
		return DOT11F_INCOMPLETE_IE;
	}

	pDst->sub_type = *pBuf;
	pBuf += 1;
	ielen -= (uint8_t)1;
	(void)pCtx;
	status |= unpack_core(pCtx,
				pBuf,
				ielen,
				FFS_vendor_vht_ie,
				IES_vendor_vht_ie,
				(uint8_t *)pDst,
				sizeof(*pDst),
				append_ie);
	return status;
} /* End dot11f_unpack_ie_vendor_vht_ie. */

#define SigIevendor_vht_ie (0x009a)


static const tFFDefn FFS_AddTSRequest[] = {
	{ "Category", offsetof(tDot11fAddTSRequest, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fAddTSRequest, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fAddTSRequest, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_AddTSRequest[] = {
	{ offsetof(tDot11fAddTSRequest, TSPEC), offsetof(tDot11fIETSPEC, present),
	0, "TSPEC", 0, 57, 57, SigIeTSPEC, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TSPEC, 0, 1, },
	{ offsetof(tDot11fAddTSRequest, TCLAS), offsetof(tDot11fIETCLAS, present),
	offsetof(tDot11fAddTSRequest, num_TCLAS), "TCLAS", 2, 7, 45, SigIeTCLAS,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_TCLAS, 0, 0, },
	{ offsetof(tDot11fAddTSRequest, TCLASSPROC),
	offsetof(tDot11fIETCLASSPROC, present), 0, "TCLASSPROC",
	0, 3, 3, SigIeTCLASSPROC, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TCLASSPROC, 0, 0, },
	{ offsetof(tDot11fAddTSRequest, WMMTSPEC), offsetof(tDot11fIEWMMTSPEC,
	present), 0, "WMMTSPEC", 0, 63, 63, SigIeWMMTSPEC, {0, 80, 242, 2, 2},
	5, DOT11F_EID_WMMTSPEC, 0, 0, },
	{ offsetof(tDot11fAddTSRequest, WMMTCLAS), offsetof(tDot11fIEWMMTCLAS,
	present), offsetof(tDot11fAddTSRequest, num_WMMTCLAS), "WMMTCLAS",
	2, 13, 51, SigIeWMMTCLAS, {0, 80, 242, 2, 6},
	5, DOT11F_EID_WMMTCLAS, 0, 0, },
	{ offsetof(tDot11fAddTSRequest, WMMTCLASPROC),
	offsetof(tDot11fIEWMMTCLASPROC, present), 0, "WMMTCLASPROC",
	0, 9, 9, SigIeWMMTCLASPROC, {0, 80, 242, 2, 7},
	5, DOT11F_EID_WMMTCLASPROC, 0, 0, },
	{ offsetof(tDot11fAddTSRequest, ESETrafStrmRateSet),
	offsetof(tDot11fIEESETrafStrmRateSet, present), 0, "ESETrafStrmRateSet",
	0, 7, 15, SigIeESETrafStrmRateSet, {0, 64, 150, 8, 0},
	4, DOT11F_EID_ESETRAFSTRMRATESET, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_add_ts_request(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fAddTSRequest *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_AddTSRequest, IES_AddTSRequest,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_add_ts_request. */

static const tFFDefn FFS_AddTSResponse[] = {
	{ "Category", offsetof(tDot11fAddTSResponse, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fAddTSResponse, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fAddTSResponse, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ "Status", offsetof(tDot11fAddTSResponse, Status), SigFfStatus,
	DOT11F_FF_STATUS_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_AddTSResponse[] = {
	{ offsetof(tDot11fAddTSResponse, TSDelay), offsetof(tDot11fIETSDelay,
	present), 0, "TSDelay", 0, 6, 6, SigIeTSDelay, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TSDELAY, 0, 1, },
	{ offsetof(tDot11fAddTSResponse, TSPEC), offsetof(tDot11fIETSPEC,
	present), 0, "TSPEC", 0, 57, 57, SigIeTSPEC, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TSPEC, 0, 1, },
	{ offsetof(tDot11fAddTSResponse, TCLAS), offsetof(tDot11fIETCLAS,
	present), offsetof(tDot11fAddTSResponse, num_TCLAS), "TCLAS",
	2, 7, 45, SigIeTCLAS, {0, 0, 0, 0, 0}, 0, DOT11F_EID_TCLAS, 0, 0, },
	{ offsetof(tDot11fAddTSResponse, TCLASSPROC),
	offsetof(tDot11fIETCLASSPROC, present), 0, "TCLASSPROC",
	0, 3, 3, SigIeTCLASSPROC, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TCLASSPROC, 0, 0, },
	{ offsetof(tDot11fAddTSResponse, Schedule), offsetof(tDot11fIESchedule,
	present), 0, "Schedule", 0, 16, 16, SigIeSchedule, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SCHEDULE, 0, 0, },
	{ offsetof(tDot11fAddTSResponse, WMMTSDelay),
	offsetof(tDot11fIEWMMTSDelay, present), 0, "WMMTSDelay",
	0, 12, 12, SigIeWMMTSDelay, {0, 80, 242, 2, 8},
	5, DOT11F_EID_WMMTSDELAY, 0, 0, },
	{ offsetof(tDot11fAddTSResponse, WMMSchedule),
	offsetof(tDot11fIEWMMSchedule, present), 0, "WMMSchedule",
	0, 22, 22, SigIeWMMSchedule, {0, 80, 242, 2, 9},
	5, DOT11F_EID_WMMSCHEDULE, 0, 0, },
	{ offsetof(tDot11fAddTSResponse, WMMTSPEC), offsetof(tDot11fIEWMMTSPEC,
	present), 0, "WMMTSPEC", 0, 63, 63, SigIeWMMTSPEC, {0, 80, 242, 2, 2},
	5, DOT11F_EID_WMMTSPEC, 0, 0, },
	{ offsetof(tDot11fAddTSResponse, WMMTCLAS), offsetof(tDot11fIEWMMTCLAS,
	present), offsetof(tDot11fAddTSResponse, num_WMMTCLAS), "WMMTCLAS",
	2, 13, 51, SigIeWMMTCLAS, {0, 80, 242, 2, 6},
	5, DOT11F_EID_WMMTCLAS, 0, 0, },
	{ offsetof(tDot11fAddTSResponse, WMMTCLASPROC),
	offsetof(tDot11fIEWMMTCLASPROC, present), 0, "WMMTCLASPROC",
	0, 9, 9, SigIeWMMTCLASPROC, {0, 80, 242, 2, 7},
	5, DOT11F_EID_WMMTCLASPROC, 0, 0, },
	{ offsetof(tDot11fAddTSResponse, ESETrafStrmMet),
	offsetof(tDot11fIEESETrafStrmMet, present), 0, "ESETrafStrmMet",
	0, 10, 10, SigIeESETrafStrmMet, {0, 64, 150, 7, 0},
	4, DOT11F_EID_ESETRAFSTRMMET, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_add_ts_response(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fAddTSResponse *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_AddTSResponse, IES_AddTSResponse,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_add_ts_response. */

static const tFFDefn FFS_AssocRequest[] = {
	{ "Capabilities", offsetof(tDot11fAssocRequest, Capabilities),
	SigFfCapabilities, DOT11F_FF_CAPABILITIES_LEN, },
	{ "ListenInterval", offsetof(tDot11fAssocRequest, ListenInterval),
	SigFfListenInterval, DOT11F_FF_LISTENINTERVAL_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_AssocRequest[] = {
	{ offsetof(tDot11fAssocRequest, SSID), offsetof(tDot11fIESSID, present), 0,
	"SSID", 0, 2, 34, SigIeSSID, {0, 0, 0, 0, 0}, 0, DOT11F_EID_SSID, 0, 1, },
	{ offsetof(tDot11fAssocRequest, SuppRates), offsetof(tDot11fIESuppRates,
	present), 0, "SuppRates", 0, 2, 14, SigIeSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPRATES, 0, 1, },
	{ offsetof(tDot11fAssocRequest, OperatingMode),
	offsetof(tDot11fIEOperatingMode, present), 0, "OperatingMode",
	0, 3, 3, SigIeOperatingMode, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OPERATINGMODE, 0, 0, },
	{ offsetof(tDot11fAssocRequest, PowerCaps), offsetof(tDot11fIEPowerCaps,
	present), 0, "PowerCaps", 0, 4, 4, SigIePowerCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_POWERCAPS, 0, 0, },
	{ offsetof(tDot11fAssocRequest, SuppChannels),
	offsetof(tDot11fIESuppChannels, present), 0, "SuppChannels",
	0, 2, 98, SigIeSuppChannels, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPCHANNELS, 0, 0, },
	{ offsetof(tDot11fAssocRequest, HTCaps), offsetof(tDot11fIEHTCaps,
	present), 0, "HTCaps", 0, 28, 60, SigIeHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fAssocRequest, QOSCapsStation),
	offsetof(tDot11fIEQOSCapsStation, present), 0, "QOSCapsStation",
	0, 3, 3, SigIeQOSCapsStation, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QOSCAPSSTATION, 0, 0, },
	{ offsetof(tDot11fAssocRequest, RSNOpaque), offsetof(tDot11fIERSNOpaque,
	present), 0, "RSNOpaque", 0, 2, 255, SigIeRSNOpaque, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RSNOPAQUE, 0, 0, },
	{ offsetof(tDot11fAssocRequest, ExtSuppRates),
	offsetof(tDot11fIEExtSuppRates, present), 0, "ExtSuppRates",
	0, 3, 14, SigIeExtSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTSUPPRATES, 0, 0, },
	{ offsetof(tDot11fAssocRequest, MobilityDomain),
	offsetof(tDot11fIEMobilityDomain, present), 0, "MobilityDomain",
	0, 5, 5, SigIeMobilityDomain, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MOBILITYDOMAIN, 0, 0, },
	{ offsetof(tDot11fAssocRequest, FTInfo), offsetof(tDot11fIEFTInfo,
	present), 0, "FTInfo", 0, 84, 222, SigIeFTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FTINFO, 0, 0, },
	{ offsetof(tDot11fAssocRequest, SuppOperatingClasses),
	offsetof(tDot11fIESuppOperatingClasses, present), 0,
	"SuppOperatingClasses", 0, 3, 34, SigIeSuppOperatingClasses,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_SUPPOPERATINGCLASSES, 0, 0, },
	{ offsetof(tDot11fAssocRequest, WAPIOpaque),
	offsetof(tDot11fIEWAPIOpaque, present), 0, "WAPIOpaque",
	0, 8, 255, SigIeWAPIOpaque, {0, 0, 0, 0, 0},
	0, DOT11F_EID_WAPIOPAQUE, 0, 0, },
	{ offsetof(tDot11fAssocRequest, WAPI), offsetof(tDot11fIEWAPI, present), 0,
	"WAPI", 0, 14, 112, SigIeWAPI, {0, 0, 0, 0, 0},
	0, DOT11F_EID_WAPI, 0, 0, },
	{ offsetof(tDot11fAssocRequest, RRMEnabledCap),
	offsetof(tDot11fIERRMEnabledCap, present), 0, "RRMEnabledCap",
	0, 7, 7, SigIeRRMEnabledCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RRMENABLEDCAP, 0, 0, },
	{ offsetof(tDot11fAssocRequest, QosMapSet), offsetof(tDot11fIEQosMapSet,
	present), 0, "QosMapSet", 0, 18, 60, SigIeQosMapSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QOSMAPSET, 0, 0, },
	{ offsetof(tDot11fAssocRequest, ExtCap), offsetof(tDot11fIEExtCap,
	present), 0, "ExtCap", 0, 3, 17, SigIeExtCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fAssocRequest, VHTCaps), offsetof(tDot11fIEVHTCaps,
	present), 0, "VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fAssocRequest, fils_session),
	offsetof(tDot11fIEfils_session, present), 0, "fils_session",
	0, 10, 10, SigIefils_session, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_SESSION, 4, 0, },
	{ offsetof(tDot11fAssocRequest, fils_public_key),
	offsetof(tDot11fIEfils_public_key, present), 0, "fils_public_key",
	0, 3, 258, SigIefils_public_key, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_PUBLIC_KEY, 12, 0, },
	{ offsetof(tDot11fAssocRequest, fils_key_confirmation),
	offsetof(tDot11fIEfils_key_confirmation, present), 0,
	"fils_key_confirmation", 0, 2, 257, SigIefils_key_confirmation,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_FILS_KEY_CONFIRMATION, 3, 0, },
	{ offsetof(tDot11fAssocRequest, fils_hlp_container),
	offsetof(tDot11fIEfils_hlp_container, present), 0, "fils_hlp_container",
	0, 14, 269, SigIefils_hlp_container, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_HLP_CONTAINER, 5, 0, },
	{ offsetof(tDot11fAssocRequest, fragment_ie),
	offsetof(tDot11fIEfragment_ie, present), 0, "fragment_ie",
	0, 2, 257, SigIefragment_ie, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FRAGMENT_IE, 0, 0, },
	{ offsetof(tDot11fAssocRequest, dh_parameter_element),
	offsetof(tDot11fIEdh_parameter_element, present), 0,
	"dh_parameter_element", 0, 4, 259, SigIedh_parameter_element,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_DH_PARAMETER_ELEMENT, 32, 0, },
	{ offsetof(tDot11fAssocRequest, WPAOpaque), offsetof(tDot11fIEWPAOpaque,
	present), 0, "WPAOpaque", 0, 8, 255, SigIeWPAOpaque, {0, 80, 242, 1, 0},
	4, DOT11F_EID_WPAOPAQUE, 0, 0, },
	{ offsetof(tDot11fAssocRequest, WMMCaps), offsetof(tDot11fIEWMMCaps,
	present), 0, "WMMCaps", 0, 9, 9, SigIeWMMCaps, {0, 80, 242, 2, 5},
	5, DOT11F_EID_WMMCAPS, 0, 0, },
	{ offsetof(tDot11fAssocRequest, WMMInfoStation),
	offsetof(tDot11fIEWMMInfoStation, present), 0, "WMMInfoStation",
	0, 9, 9, SigIeWMMInfoStation, {0, 80, 242, 2, 0},
	5, DOT11F_EID_WMMINFOSTATION, 0, 0, },
	{ offsetof(tDot11fAssocRequest, WscIEOpaque),
	offsetof(tDot11fIEWscIEOpaque, present), 0, "WscIEOpaque",
	0, 8, 255, SigIeWscIEOpaque, {0, 80, 242, 4, 0},
	4, DOT11F_EID_WSCIEOPAQUE, 0, 0, },
	{ offsetof(tDot11fAssocRequest, ESERadMgmtCap),
	offsetof(tDot11fIEESERadMgmtCap, present), 0, "ESERadMgmtCap",
	0, 8, 8, SigIeESERadMgmtCap, {0, 64, 150, 1, 0},
	4, DOT11F_EID_ESERADMGMTCAP, 0, 0, },
	{ offsetof(tDot11fAssocRequest, ESEVersion),
	offsetof(tDot11fIEESEVersion, present), 0, "ESEVersion",
	0, 7, 7, SigIeESEVersion, {0, 64, 150, 3, 0},
	4, DOT11F_EID_ESEVERSION, 0, 0, },
	{ offsetof(tDot11fAssocRequest, P2PIEOpaque),
	offsetof(tDot11fIEP2PIEOpaque, present), 0, "P2PIEOpaque",
	0, 8, 255, SigIeP2PIEOpaque, {80, 111, 154, 9, 0},
	4, DOT11F_EID_P2PIEOPAQUE, 0, 0, },
	{ offsetof(tDot11fAssocRequest, WFDIEOpaque),
	offsetof(tDot11fIEWFDIEOpaque, present), 0, "WFDIEOpaque",
	0, 8, 255, SigIeWFDIEOpaque, {80, 111, 154, 10, 0},
	4, DOT11F_EID_WFDIEOPAQUE, 0, 0, },
	{ offsetof(tDot11fAssocRequest, vendor_vht_ie),
	offsetof(tDot11fIEvendor_vht_ie, present), 0, "vendor_vht_ie",
	0, 7, 28, SigIevendor_vht_ie, {0, 144, 76, 4, 0},
	4, DOT11F_EID_VENDOR_VHT_IE, 0, 0, },
	{ offsetof(tDot11fAssocRequest, hs20vendor_ie),
	offsetof(tDot11fIEhs20vendor_ie, present), 0, "hs20vendor_ie",
	0, 7, 9, SigIehs20vendor_ie, {80, 111, 154, 16, 0},
	4, DOT11F_EID_HS20VENDOR_IE, 0, 0, },
	{ offsetof(tDot11fAssocRequest, qcn_ie), offsetof(tDot11fIEqcn_ie,
	present), 0, "qcn_ie", 0, 6, 37, SigIeqcn_ie, {140, 253, 240, 1, 0},
	4, DOT11F_EID_QCN_IE, 0, 0, },
	{ offsetof(tDot11fAssocRequest, he_cap), offsetof(tDot11fIEhe_cap,
	present), 0, "he_cap", 0, 23, 56, SigIehe_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_CAP, 35, 0, },
	{ offsetof(tDot11fAssocRequest, he_6ghz_band_cap),
	offsetof(tDot11fIEhe_6ghz_band_cap, present), 0, "he_6ghz_band_cap",
	0, 4, 4, SigIehe_6ghz_band_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_6GHZ_BAND_CAP, 59, 0, },
	{ offsetof(tDot11fAssocRequest, osen_ie), offsetof(tDot11fIEosen_ie,
	present), 0, "osen_ie", 0, 6, 261, SigIeosen_ie, {80, 111, 154, 18, 0},
	4, DOT11F_EID_OSEN_IE, 0, 0, },
	{ offsetof(tDot11fAssocRequest, roaming_consortium_sel),
	offsetof(tDot11fIEroaming_consortium_sel, present), 0,
	"roaming_consortium_sel", 0, 6, 261, SigIeroaming_consortium_sel,
	{80, 111, 154, 29, 0}, 4, DOT11F_EID_ROAMING_CONSORTIUM_SEL, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_assoc_request(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fAssocRequest *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_AssocRequest, IES_AssocRequest,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_assoc_request. */

static const tFFDefn FFS_AssocResponse[] = {
	{ "Capabilities", offsetof(tDot11fAssocResponse, Capabilities),
	SigFfCapabilities, DOT11F_FF_CAPABILITIES_LEN, },
	{ "Status", offsetof(tDot11fAssocResponse, Status), SigFfStatus,
	DOT11F_FF_STATUS_LEN, },
	{ "AID", offsetof(tDot11fAssocResponse, AID), SigFfAID,
	DOT11F_FF_AID_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_AssocResponse[] = {
	{ offsetof(tDot11fAssocResponse, SuppRates), offsetof(tDot11fIESuppRates,
	present), 0, "SuppRates", 0, 2, 14, SigIeSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPRATES, 0, 1, },
	{ offsetof(tDot11fAssocResponse, ExtSuppRates),
	offsetof(tDot11fIEExtSuppRates, present), 0, "ExtSuppRates",
	0, 3, 14, SigIeExtSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTSUPPRATES, 0, 0, },
	{ offsetof(tDot11fAssocResponse, EDCAParamSet),
	offsetof(tDot11fIEEDCAParamSet, present), 0, "EDCAParamSet",
	0, 20, 20, SigIeEDCAParamSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EDCAPARAMSET, 0, 0, },
	{ offsetof(tDot11fAssocResponse, RCPIIE), offsetof(tDot11fIERCPIIE,
	present), 0, "RCPIIE", 0, 3, 3, SigIeRCPIIE, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RCPIIE, 0, 0, },
	{ offsetof(tDot11fAssocResponse, RSNIIE), offsetof(tDot11fIERSNIIE,
	present), 0, "RSNIIE", 0, 3, 3, SigIeRSNIIE, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RSNIIE, 0, 0, },
	{ offsetof(tDot11fAssocResponse, RRMEnabledCap),
	offsetof(tDot11fIERRMEnabledCap, present), 0, "RRMEnabledCap",
	0, 7, 7, SigIeRRMEnabledCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RRMENABLEDCAP, 0, 0, },
	{ offsetof(tDot11fAssocResponse, MobilityDomain),
	offsetof(tDot11fIEMobilityDomain, present), 0, "MobilityDomain",
	0, 5, 5, SigIeMobilityDomain, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MOBILITYDOMAIN, 0, 0, },
	{ offsetof(tDot11fAssocResponse, FTInfo), offsetof(tDot11fIEFTInfo,
	present), 0, "FTInfo", 0, 84, 222, SigIeFTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FTINFO, 0, 0, },
	{ offsetof(tDot11fAssocResponse, RICDataDesc),
	offsetof(tDot11fIERICDataDesc, present),
	offsetof(tDot11fAssocResponse, num_RICDataDesc), "RICDataDesc",
	2, 2, 550, SigIeRICDataDesc, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RICDATADESC, 0, 0, },
	{ offsetof(tDot11fAssocResponse, WPA), offsetof(tDot11fIEWPA, present), 0,
	"WPA", 0, 8, 50, SigIeWPA, {0, 80, 242, 1, 0}, 4, DOT11F_EID_WPA, 0, 0, },
	{ offsetof(tDot11fAssocResponse, TimeoutInterval),
	offsetof(tDot11fIETimeoutInterval, present), 0, "TimeoutInterval",
	0, 7, 7, SigIeTimeoutInterval, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TIMEOUTINTERVAL, 0, 0, },
	{ offsetof(tDot11fAssocResponse, HTCaps), offsetof(tDot11fIEHTCaps,
	present), 0, "HTCaps", 0, 28, 60, SigIeHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fAssocResponse, HTInfo), offsetof(tDot11fIEHTInfo,
	present), 0, "HTInfo", 0, 24, 56, SigIeHTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTINFO, 0, 0, },
	{ offsetof(tDot11fAssocResponse, WMMParams), offsetof(tDot11fIEWMMParams,
	present), 0, "WMMParams", 0, 26, 26, SigIeWMMParams, {0, 80, 242, 2, 1},
	5, DOT11F_EID_WMMPARAMS, 0, 0, },
	{ offsetof(tDot11fAssocResponse, WMMCaps), offsetof(tDot11fIEWMMCaps,
	present), 0, "WMMCaps", 0, 9, 9, SigIeWMMCaps, {0, 80, 242, 2, 5},
	5, DOT11F_EID_WMMCAPS, 0, 0, },
	{ offsetof(tDot11fAssocResponse, ESERadMgmtCap),
	offsetof(tDot11fIEESERadMgmtCap, present), 0, "ESERadMgmtCap",
	0, 8, 8, SigIeESERadMgmtCap, {0, 64, 150, 1, 0},
	4, DOT11F_EID_ESERADMGMTCAP, 0, 0, },
	{ offsetof(tDot11fAssocResponse, ESETrafStrmMet),
	offsetof(tDot11fIEESETrafStrmMet, present), 0, "ESETrafStrmMet",
	0, 10, 10, SigIeESETrafStrmMet, {0, 64, 150, 7, 0},
	4, DOT11F_EID_ESETRAFSTRMMET, 0, 0, },
	{ offsetof(tDot11fAssocResponse, ESETxmitPower),
	offsetof(tDot11fIEESETxmitPower, present), 0, "ESETxmitPower",
	0, 8, 8, SigIeESETxmitPower, {0, 64, 150, 0, 0},
	4, DOT11F_EID_ESETXMITPOWER, 0, 0, },
	{ offsetof(tDot11fAssocResponse, WMMTSPEC), offsetof(tDot11fIEWMMTSPEC,
	present), offsetof(tDot11fAssocResponse, num_WMMTSPEC), "WMMTSPEC",
	4, 63, 63, SigIeWMMTSPEC, {0, 80, 242, 2, 2},
	5, DOT11F_EID_WMMTSPEC, 0, 0, },
	{ offsetof(tDot11fAssocResponse, WscAssocRes),
	offsetof(tDot11fIEWscAssocRes, present), 0, "WscAssocRes",
	0, 6, 37, SigIeWscAssocRes, {0, 80, 242, 4, 0},
	4, DOT11F_EID_WSCASSOCRES, 0, 0, },
	{ offsetof(tDot11fAssocResponse, P2PAssocRes),
	offsetof(tDot11fIEP2PAssocRes, present), 0, "P2PAssocRes",
	0, 6, 17, SigIeP2PAssocRes, {80, 111, 154, 9, 0},
	4, DOT11F_EID_P2PASSOCRES, 0, 0, },
	{ offsetof(tDot11fAssocResponse, VHTCaps), offsetof(tDot11fIEVHTCaps,
	present), 0, "VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fAssocResponse, VHTOperation),
	offsetof(tDot11fIEVHTOperation, present), 0, "VHTOperation",
	0, 7, 7, SigIeVHTOperation, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTOPERATION, 0, 0, },
	{ offsetof(tDot11fAssocResponse, ExtCap), offsetof(tDot11fIEExtCap,
	present), 0, "ExtCap", 0, 3, 17, SigIeExtCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fAssocResponse, OBSSScanParameters),
	offsetof(tDot11fIEOBSSScanParameters, present), 0, "OBSSScanParameters",
	0, 16, 16, SigIeOBSSScanParameters, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OBSSSCANPARAMETERS, 0, 0, },
	{ offsetof(tDot11fAssocResponse, QosMapSet), offsetof(tDot11fIEQosMapSet,
	present), 0, "QosMapSet", 0, 18, 60, SigIeQosMapSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QOSMAPSET, 0, 0, },
	{ offsetof(tDot11fAssocResponse, fils_session),
	offsetof(tDot11fIEfils_session, present), 0, "fils_session",
	0, 10, 10, SigIefils_session, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_SESSION, 4, 0, },
	{ offsetof(tDot11fAssocResponse, fils_public_key),
	offsetof(tDot11fIEfils_public_key, present), 0, "fils_public_key",
	0, 3, 258, SigIefils_public_key, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_PUBLIC_KEY, 12, 0, },
	{ offsetof(tDot11fAssocResponse, fils_key_confirmation),
	offsetof(tDot11fIEfils_key_confirmation, present), 0,
	"fils_key_confirmation", 0, 2, 257, SigIefils_key_confirmation,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_FILS_KEY_CONFIRMATION, 3, 0, },
	{ offsetof(tDot11fAssocResponse, fils_hlp_container),
	offsetof(tDot11fIEfils_hlp_container, present), 0, "fils_hlp_container",
	0, 14, 269, SigIefils_hlp_container, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_HLP_CONTAINER, 5, 0, },
	{ offsetof(tDot11fAssocResponse, fragment_ie),
	offsetof(tDot11fIEfragment_ie, present), 0, "fragment_ie",
	0, 2, 257, SigIefragment_ie, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FRAGMENT_IE, 0, 0, },
	{ offsetof(tDot11fAssocResponse, fils_kde), offsetof(tDot11fIEfils_kde,
	present), 0, "fils_kde", 0, 10, 265, SigIefils_kde, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_KDE, 7, 0, },
	{ offsetof(tDot11fAssocResponse, vendor_vht_ie),
	offsetof(tDot11fIEvendor_vht_ie, present), 0, "vendor_vht_ie",
	0, 7, 28, SigIevendor_vht_ie, {0, 144, 76, 4, 0},
	4, DOT11F_EID_VENDOR_VHT_IE, 0, 0, },
	{ offsetof(tDot11fAssocResponse, qcn_ie), offsetof(tDot11fIEqcn_ie,
	present), 0, "qcn_ie", 0, 6, 37, SigIeqcn_ie, {140, 253, 240, 1, 0},
	4, DOT11F_EID_QCN_IE, 0, 0, },
	{ offsetof(tDot11fAssocResponse, he_cap), offsetof(tDot11fIEhe_cap,
	present), 0, "he_cap", 0, 23, 56, SigIehe_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_CAP, 35, 0, },
	{ offsetof(tDot11fAssocResponse, he_op), offsetof(tDot11fIEhe_op,
	present), 0, "he_op", 0, 8, 17, SigIehe_op, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_OP, 36, 0, },
	{ offsetof(tDot11fAssocResponse, he_6ghz_band_cap),
	offsetof(tDot11fIEhe_6ghz_band_cap, present), 0, "he_6ghz_band_cap",
	0, 4, 4, SigIehe_6ghz_band_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_6GHZ_BAND_CAP, 59, 0, },
	{ offsetof(tDot11fAssocResponse, bss_color_change),
	offsetof(tDot11fIEbss_color_change, present), 0, "bss_color_change",
	0, 4, 4, SigIebss_color_change, {0, 0, 0, 0, 0},
	0, DOT11F_EID_BSS_COLOR_CHANGE, 42, 0, },
	{ offsetof(tDot11fAssocResponse, mu_edca_param_set),
	offsetof(tDot11fIEmu_edca_param_set, present), 0, "mu_edca_param_set",
	0, 15, 15, SigIemu_edca_param_set, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MU_EDCA_PARAM_SET, 38, 0, },
	{ offsetof(tDot11fAssocResponse, MBO_IE), offsetof(tDot11fIEMBO_IE,
	present), 0, "MBO_IE", 0, 6, 295, SigIeMBO_IE, {80, 111, 154, 22, 0},
	4, DOT11F_EID_MBO_IE, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_assoc_response(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fAssocResponse *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_AssocResponse, IES_AssocResponse,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_assoc_response. */

static const tFFDefn FFS_Authentication[] = {
	{ "AuthAlgo", offsetof(tDot11fAuthentication, AuthAlgo), SigFfAuthAlgo,
	DOT11F_FF_AUTHALGO_LEN, },
	{ "AuthSeqNo", offsetof(tDot11fAuthentication, AuthSeqNo), SigFfAuthSeqNo,
	DOT11F_FF_AUTHSEQNO_LEN, },
	{ "Status", offsetof(tDot11fAuthentication, Status), SigFfStatus,
	DOT11F_FF_STATUS_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_Authentication[] = {
	{ offsetof(tDot11fAuthentication, ChallengeText),
	offsetof(tDot11fIEChallengeText, present), 0, "ChallengeText",
	0, 3, 255, SigIeChallengeText, {0, 0, 0, 0, 0},
	0, DOT11F_EID_CHALLENGETEXT, 0, 0, },
	{ offsetof(tDot11fAuthentication, RSNOpaque),
	offsetof(tDot11fIERSNOpaque, present), 0, "RSNOpaque",
	0, 2, 255, SigIeRSNOpaque, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RSNOPAQUE, 0, 0, },
	{ offsetof(tDot11fAuthentication, MobilityDomain),
	offsetof(tDot11fIEMobilityDomain, present), 0, "MobilityDomain",
	0, 5, 5, SigIeMobilityDomain, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MOBILITYDOMAIN, 0, 0, },
	{ offsetof(tDot11fAuthentication, FTInfo), offsetof(tDot11fIEFTInfo,
	present), 0, "FTInfo", 0, 84, 222, SigIeFTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FTINFO, 0, 0, },
	{ offsetof(tDot11fAuthentication, TimeoutInterval),
	offsetof(tDot11fIETimeoutInterval, present), 0, "TimeoutInterval",
	0, 7, 7, SigIeTimeoutInterval, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TIMEOUTINTERVAL, 0, 0, },
	{ offsetof(tDot11fAuthentication, RICDataDesc),
	offsetof(tDot11fIERICDataDesc, present),
	offsetof(tDot11fAuthentication, num_RICDataDesc), "RICDataDesc",
	2, 2, 550, SigIeRICDataDesc, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RICDATADESC, 0, 0, },
	{ offsetof(tDot11fAuthentication, fils_nonce),
	offsetof(tDot11fIEfils_nonce, present), 0, "fils_nonce",
	0, 18, 18, SigIefils_nonce, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_NONCE, 13, 0, },
	{ offsetof(tDot11fAuthentication, fils_session),
	offsetof(tDot11fIEfils_session, present), 0, "fils_session",
	0, 10, 10, SigIefils_session, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_SESSION, 4, 0, },
	{ offsetof(tDot11fAuthentication, fils_wrapped_data),
	offsetof(tDot11fIEfils_wrapped_data, present), 0, "fils_wrapped_data",
	0, 2, 257, SigIefils_wrapped_data, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_WRAPPED_DATA, 8, 0, },
	{ offsetof(tDot11fAuthentication, fils_assoc_delay_info),
	offsetof(tDot11fIEfils_assoc_delay_info, present), 0,
	"fils_assoc_delay_info", 0, 3, 3, SigIefils_assoc_delay_info,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_FILS_ASSOC_DELAY_INFO, 1, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_authentication(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fAuthentication *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_Authentication, IES_Authentication,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_authentication. */

static const tFFDefn FFS_Beacon[] = {
	{ "TimeStamp", offsetof(tDot11fBeacon, TimeStamp), SigFfTimeStamp,
	DOT11F_FF_TIMESTAMP_LEN, },
	{ "BeaconInterval", offsetof(tDot11fBeacon, BeaconInterval),
	SigFfBeaconInterval, DOT11F_FF_BEACONINTERVAL_LEN, },
	{ "Capabilities", offsetof(tDot11fBeacon, Capabilities),
	SigFfCapabilities, DOT11F_FF_CAPABILITIES_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_Beacon[] = {
	{ offsetof(tDot11fBeacon, SSID), offsetof(tDot11fIESSID, present), 0,
	"SSID", 0, 2, 34, SigIeSSID, {0, 0, 0, 0, 0}, 0, DOT11F_EID_SSID, 0, 1, },
	{ offsetof(tDot11fBeacon, SuppRates), offsetof(tDot11fIESuppRates,
	present), 0, "SuppRates", 0, 2, 14, SigIeSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPRATES, 0, 1, },
	{ offsetof(tDot11fBeacon, FHParamSet), offsetof(tDot11fIEFHParamSet,
	present), 0, "FHParamSet", 0, 7, 7, SigIeFHParamSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FHPARAMSET, 0, 0, },
	{ offsetof(tDot11fBeacon, DSParams), offsetof(tDot11fIEDSParams, present),
	0, "DSParams", 0, 3, 3, SigIeDSParams, {0, 0, 0, 0, 0},
	0, DOT11F_EID_DSPARAMS, 0, 0, },
	{ offsetof(tDot11fBeacon, CFParams), offsetof(tDot11fIECFParams, present),
	0, "CFParams", 0, 8, 8, SigIeCFParams, {0, 0, 0, 0, 0},
	0, DOT11F_EID_CFPARAMS, 0, 0, },
	{ offsetof(tDot11fBeacon, TIM), offsetof(tDot11fIETIM, present), 0, "TIM",
	0, 6, 256, SigIeTIM, {0, 0, 0, 0, 0}, 0, DOT11F_EID_TIM, 0, 0, },
	{ offsetof(tDot11fBeacon, Country), offsetof(tDot11fIECountry, present), 0,
	"Country", 0, 8, 248, SigIeCountry, {0, 0, 0, 0, 0},
	0, DOT11F_EID_COUNTRY, 0, 0, },
	{ offsetof(tDot11fBeacon, FHParams), offsetof(tDot11fIEFHParams, present),
	0, "FHParams", 0, 4, 4, SigIeFHParams, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FHPARAMS, 0, 0, },
	{ offsetof(tDot11fBeacon, FHPattTable), offsetof(tDot11fIEFHPattTable,
	present), 0, "FHPattTable", 0, 6, 257, SigIeFHPattTable, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FHPATTTABLE, 0, 0, },
	{ offsetof(tDot11fBeacon, PowerConstraints),
	offsetof(tDot11fIEPowerConstraints, present), 0, "PowerConstraints",
	0, 3, 3, SigIePowerConstraints, {0, 0, 0, 0, 0},
	0, DOT11F_EID_POWERCONSTRAINTS, 0, 0, },
	{ offsetof(tDot11fBeacon, ChanSwitchAnn),
	offsetof(tDot11fIEChanSwitchAnn, present), 0, "ChanSwitchAnn",
	0, 5, 5, SigIeChanSwitchAnn, {0, 0, 0, 0, 0},
	0, DOT11F_EID_CHANSWITCHANN, 0, 0, },
	{ offsetof(tDot11fBeacon, ext_chan_switch_ann),
	offsetof(tDot11fIEext_chan_switch_ann, present), 0, "ext_chan_switch_ann",
	0, 6, 6, SigIeext_chan_switch_ann, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXT_CHAN_SWITCH_ANN, 0, 0, },
	{ offsetof(tDot11fBeacon, SuppOperatingClasses),
	offsetof(tDot11fIESuppOperatingClasses, present), 0,
	"SuppOperatingClasses", 0, 3, 34, SigIeSuppOperatingClasses,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_SUPPOPERATINGCLASSES, 0, 0, },
	{ offsetof(tDot11fBeacon, Quiet), offsetof(tDot11fIEQuiet, present), 0,
	"Quiet", 0, 8, 8, SigIeQuiet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QUIET, 0, 0, },
	{ offsetof(tDot11fBeacon, TPCReport), offsetof(tDot11fIETPCReport,
	present), 0, "TPCReport", 0, 4, 4, SigIeTPCReport, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TPCREPORT, 0, 0, },
	{ offsetof(tDot11fBeacon, ERPInfo), offsetof(tDot11fIEERPInfo, present), 0,
	"ERPInfo", 0, 3, 3, SigIeERPInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_ERPINFO, 0, 0, },
	{ offsetof(tDot11fBeacon, ExtSuppRates), offsetof(tDot11fIEExtSuppRates,
	present), 0, "ExtSuppRates", 0, 3, 14, SigIeExtSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTSUPPRATES, 0, 0, },
	{ offsetof(tDot11fBeacon, RSN), offsetof(tDot11fIERSN, present), 0, "RSN",
	0, 4, 132, SigIeRSN, {0, 0, 0, 0, 0}, 0, DOT11F_EID_RSN, 0, 0, },
	{ offsetof(tDot11fBeacon, QBSSLoad), offsetof(tDot11fIEQBSSLoad, present),
	0, "QBSSLoad", 0, 7, 7, SigIeQBSSLoad, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QBSSLOAD, 0, 0, },
	{ offsetof(tDot11fBeacon, EDCAParamSet), offsetof(tDot11fIEEDCAParamSet,
	present), 0, "EDCAParamSet", 0, 20, 20, SigIeEDCAParamSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EDCAPARAMSET, 0, 0, },
	{ offsetof(tDot11fBeacon, QOSCapsAp), offsetof(tDot11fIEQOSCapsAp,
	present), 0, "QOSCapsAp", 0, 3, 3, SigIeQOSCapsAp, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QOSCAPSAP, 0, 0, },
	{ offsetof(tDot11fBeacon, APChannelReport),
	offsetof(tDot11fIEAPChannelReport, present), 0, "APChannelReport",
	0, 3, 53, SigIeAPChannelReport, {0, 0, 0, 0, 0},
	0, DOT11F_EID_APCHANNELREPORT, 0, 0, },
	{ offsetof(tDot11fBeacon, RRMEnabledCap),
	offsetof(tDot11fIERRMEnabledCap, present), 0, "RRMEnabledCap",
	0, 7, 7, SigIeRRMEnabledCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RRMENABLEDCAP, 0, 0, },
	{ offsetof(tDot11fBeacon, MobilityDomain),
	offsetof(tDot11fIEMobilityDomain, present), 0, "MobilityDomain",
	0, 5, 5, SigIeMobilityDomain, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MOBILITYDOMAIN, 0, 0, },
	{ offsetof(tDot11fBeacon, WPA), offsetof(tDot11fIEWPA, present), 0, "WPA",
	0, 8, 50, SigIeWPA, {0, 80, 242, 1, 0}, 4, DOT11F_EID_WPA, 0, 0, },
	{ offsetof(tDot11fBeacon, HTCaps), offsetof(tDot11fIEHTCaps, present), 0,
	"HTCaps", 0, 28, 60, SigIeHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fBeacon, HTInfo), offsetof(tDot11fIEHTInfo, present), 0,
	"HTInfo", 0, 24, 56, SigIeHTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTINFO, 0, 0, },
	{ offsetof(tDot11fBeacon, sec_chan_offset_ele),
	offsetof(tDot11fIEsec_chan_offset_ele, present), 0, "sec_chan_offset_ele",
	0, 3, 3, SigIesec_chan_offset_ele, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SEC_CHAN_OFFSET_ELE, 0, 0, },
	{ offsetof(tDot11fBeacon, WMMInfoAp), offsetof(tDot11fIEWMMInfoAp,
	present), 0, "WMMInfoAp", 0, 9, 9, SigIeWMMInfoAp, {0, 80, 242, 2, 0},
	5, DOT11F_EID_WMMINFOAP, 0, 0, },
	{ offsetof(tDot11fBeacon, WMMParams), offsetof(tDot11fIEWMMParams,
	present), 0, "WMMParams", 0, 26, 26, SigIeWMMParams, {0, 80, 242, 2, 1},
	5, DOT11F_EID_WMMPARAMS, 0, 0, },
	{ offsetof(tDot11fBeacon, WMMCaps), offsetof(tDot11fIEWMMCaps, present), 0,
	"WMMCaps", 0, 9, 9, SigIeWMMCaps, {0, 80, 242, 2, 5},
	5, DOT11F_EID_WMMCAPS, 0, 0, },
	{ offsetof(tDot11fBeacon, WAPI), offsetof(tDot11fIEWAPI, present), 0,
	"WAPI", 0, 14, 112, SigIeWAPI, {0, 0, 0, 0, 0},
	0, DOT11F_EID_WAPI, 0, 0, },
	{ offsetof(tDot11fBeacon, ESERadMgmtCap),
	offsetof(tDot11fIEESERadMgmtCap, present), 0, "ESERadMgmtCap",
	0, 8, 8, SigIeESERadMgmtCap, {0, 64, 150, 1, 0},
	4, DOT11F_EID_ESERADMGMTCAP, 0, 0, },
	{ offsetof(tDot11fBeacon, ESETrafStrmMet),
	offsetof(tDot11fIEESETrafStrmMet, present), 0, "ESETrafStrmMet",
	0, 10, 10, SigIeESETrafStrmMet, {0, 64, 150, 7, 0},
	4, DOT11F_EID_ESETRAFSTRMMET, 0, 0, },
	{ offsetof(tDot11fBeacon, ESETxmitPower),
	offsetof(tDot11fIEESETxmitPower, present), 0, "ESETxmitPower",
	0, 8, 8, SigIeESETxmitPower, {0, 64, 150, 0, 0},
	4, DOT11F_EID_ESETXMITPOWER, 0, 0, },
	{ offsetof(tDot11fBeacon, WscBeacon), offsetof(tDot11fIEWscBeacon,
	present), 0, "WscBeacon", 0, 6, 84, SigIeWscBeacon, {0, 80, 242, 4, 0},
	4, DOT11F_EID_WSCBEACON, 0, 0, },
	{ offsetof(tDot11fBeacon, P2PBeacon), offsetof(tDot11fIEP2PBeacon,
	present), 0, "P2PBeacon", 0, 6, 61, SigIeP2PBeacon, {80, 111, 154, 9, 0},
	4, DOT11F_EID_P2PBEACON, 0, 0, },
	{ offsetof(tDot11fBeacon, VHTCaps), offsetof(tDot11fIEVHTCaps, present), 0,
	"VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fBeacon, VHTOperation), offsetof(tDot11fIEVHTOperation,
	present), 0, "VHTOperation", 0, 7, 7, SigIeVHTOperation, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTOPERATION, 0, 0, },
	{ offsetof(tDot11fBeacon, transmit_power_env),
	offsetof(tDot11fIEtransmit_power_env, present),
	offsetof(tDot11fBeacon, num_transmit_power_env), "transmit_power_env",
	8, 4, 11, SigIetransmit_power_env, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TRANSMIT_POWER_ENV, 0, 0, },
	{ offsetof(tDot11fBeacon, VHTExtBssLoad),
	offsetof(tDot11fIEVHTExtBssLoad, present), 0, "VHTExtBssLoad",
	0, 7, 7, SigIeVHTExtBssLoad, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTEXTBSSLOAD, 0, 0, },
	{ offsetof(tDot11fBeacon, ExtCap), offsetof(tDot11fIEExtCap, present), 0,
	"ExtCap", 0, 3, 17, SigIeExtCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fBeacon, OperatingMode),
	offsetof(tDot11fIEOperatingMode, present), 0, "OperatingMode",
	0, 3, 3, SigIeOperatingMode, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OPERATINGMODE, 0, 0, },
	{ offsetof(tDot11fBeacon, WiderBWChanSwitchAnn),
	offsetof(tDot11fIEWiderBWChanSwitchAnn, present), 0,
	"WiderBWChanSwitchAnn", 0, 5, 5, SigIeWiderBWChanSwitchAnn,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_WIDERBWCHANSWITCHANN, 0, 0, },
	{ offsetof(tDot11fBeacon, OBSSScanParameters),
	offsetof(tDot11fIEOBSSScanParameters, present), 0, "OBSSScanParameters",
	0, 16, 16, SigIeOBSSScanParameters, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OBSSSCANPARAMETERS, 0, 0, },
	{ offsetof(tDot11fBeacon, fils_indication),
	offsetof(tDot11fIEfils_indication, present), 0, "fils_indication",
	0, 6, 259, SigIefils_indication, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_INDICATION, 0, 0, },
	{ offsetof(tDot11fBeacon, Vendor1IE), offsetof(tDot11fIEVendor1IE,
	present), 0, "Vendor1IE", 0, 5, 5, SigIeVendor1IE, {0, 16, 24, 0, 0},
	3, DOT11F_EID_VENDOR1IE, 0, 0, },
	{ offsetof(tDot11fBeacon, vendor_vht_ie),
	offsetof(tDot11fIEvendor_vht_ie, present), 0, "vendor_vht_ie",
	0, 7, 28, SigIevendor_vht_ie, {0, 144, 76, 4, 0},
	4, DOT11F_EID_VENDOR_VHT_IE, 0, 0, },
	{ offsetof(tDot11fBeacon, Vendor3IE), offsetof(tDot11fIEVendor3IE,
	present), 0, "Vendor3IE", 0, 5, 5, SigIeVendor3IE, {0, 22, 50, 0, 0},
	3, DOT11F_EID_VENDOR3IE, 0, 0, },
	{ offsetof(tDot11fBeacon, hs20vendor_ie),
	offsetof(tDot11fIEhs20vendor_ie, present), 0, "hs20vendor_ie",
	0, 7, 9, SigIehs20vendor_ie, {80, 111, 154, 16, 0},
	4, DOT11F_EID_HS20VENDOR_IE, 0, 0, },
	{ offsetof(tDot11fBeacon, ChannelSwitchWrapper),
	offsetof(tDot11fIEChannelSwitchWrapper, present), 0,
	"ChannelSwitchWrapper", 0, 2, 18, SigIeChannelSwitchWrapper,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_CHANNELSWITCHWRAPPER, 0, 0, },
	{ offsetof(tDot11fBeacon, QComVendorIE), offsetof(tDot11fIEQComVendorIE,
	present), 0, "QComVendorIE", 0, 7, 7, SigIeQComVendorIE,
	{0, 160, 198, 0, 0}, 3, DOT11F_EID_QCOMVENDORIE, 0, 0, },
	{ offsetof(tDot11fBeacon, ESEVersion), offsetof(tDot11fIEESEVersion,
	present), 0, "ESEVersion", 0, 7, 7, SigIeESEVersion, {0, 64, 150, 3, 0},
	4, DOT11F_EID_ESEVERSION, 0, 0, },
	{ offsetof(tDot11fBeacon, MBO_IE), offsetof(tDot11fIEMBO_IE, present), 0,
	"MBO_IE", 0, 6, 295, SigIeMBO_IE, {80, 111, 154, 22, 0},
	4, DOT11F_EID_MBO_IE, 0, 0, },
	{ offsetof(tDot11fBeacon, qcn_ie), offsetof(tDot11fIEqcn_ie, present), 0,
	"qcn_ie", 0, 6, 37, SigIeqcn_ie, {140, 253, 240, 1, 0},
	4, DOT11F_EID_QCN_IE, 0, 0, },
	{ offsetof(tDot11fBeacon, he_cap), offsetof(tDot11fIEhe_cap, present), 0,
	"he_cap", 0, 23, 56, SigIehe_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_CAP, 35, 0, },
	{ offsetof(tDot11fBeacon, he_op), offsetof(tDot11fIEhe_op, present), 0,
	"he_op", 0, 8, 17, SigIehe_op, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_OP, 36, 0, },
	{ offsetof(tDot11fBeacon, he_6ghz_band_cap),
	offsetof(tDot11fIEhe_6ghz_band_cap, present), 0, "he_6ghz_band_cap",
	0, 4, 4, SigIehe_6ghz_band_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_6GHZ_BAND_CAP, 59, 0, },
	{ offsetof(tDot11fBeacon, bss_color_change),
	offsetof(tDot11fIEbss_color_change, present), 0, "bss_color_change",
	0, 4, 4, SigIebss_color_change, {0, 0, 0, 0, 0},
	0, DOT11F_EID_BSS_COLOR_CHANGE, 42, 0, },
	{ offsetof(tDot11fBeacon, mu_edca_param_set),
	offsetof(tDot11fIEmu_edca_param_set, present), 0, "mu_edca_param_set",
	0, 15, 15, SigIemu_edca_param_set, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MU_EDCA_PARAM_SET, 38, 0, },
	{ offsetof(tDot11fBeacon, esp_information),
	offsetof(tDot11fIEesp_information, present), 0, "esp_information",
	0, 2, 98, SigIeesp_information, {0, 0, 0, 0, 0},
	0, DOT11F_EID_ESP_INFORMATION, 11, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_beacon(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fBeacon *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_Beacon, IES_Beacon,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_beacon. */

static const tFFDefn FFS_Beacon1[] = {
	{ "TimeStamp", offsetof(tDot11fBeacon1, TimeStamp), SigFfTimeStamp,
	DOT11F_FF_TIMESTAMP_LEN, },
	{ "BeaconInterval", offsetof(tDot11fBeacon1, BeaconInterval),
	SigFfBeaconInterval, DOT11F_FF_BEACONINTERVAL_LEN, },
	{ "Capabilities", offsetof(tDot11fBeacon1, Capabilities),
	SigFfCapabilities, DOT11F_FF_CAPABILITIES_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_Beacon1[] = {
	{ offsetof(tDot11fBeacon1, SSID), offsetof(tDot11fIESSID, present), 0,
	"SSID", 0, 2, 34, SigIeSSID, {0, 0, 0, 0, 0}, 0, DOT11F_EID_SSID, 0, 1, },
	{ offsetof(tDot11fBeacon1, SuppRates), offsetof(tDot11fIESuppRates,
	present), 0, "SuppRates", 0, 2, 14, SigIeSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPRATES, 0, 1, },
	{ offsetof(tDot11fBeacon1, DSParams), offsetof(tDot11fIEDSParams,
	present), 0, "DSParams", 0, 3, 3, SigIeDSParams, {0, 0, 0, 0, 0},
	0, DOT11F_EID_DSPARAMS, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_beacon1(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fBeacon1 *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_Beacon1, IES_Beacon1,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_beacon1. */

static const tFFDefn FFS_Beacon2[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_Beacon2[] = {
	{ offsetof(tDot11fBeacon2, Country), offsetof(tDot11fIECountry, present),
	0, "Country", 0, 8, 248, SigIeCountry, {0, 0, 0, 0, 0},
	0, DOT11F_EID_COUNTRY, 0, 0, },
	{ offsetof(tDot11fBeacon2, PowerConstraints),
	offsetof(tDot11fIEPowerConstraints, present), 0, "PowerConstraints",
	0, 3, 3, SigIePowerConstraints, {0, 0, 0, 0, 0},
	0, DOT11F_EID_POWERCONSTRAINTS, 0, 0, },
	{ offsetof(tDot11fBeacon2, ChanSwitchAnn),
	offsetof(tDot11fIEChanSwitchAnn, present), 0, "ChanSwitchAnn",
	0, 5, 5, SigIeChanSwitchAnn, {0, 0, 0, 0, 0},
	0, DOT11F_EID_CHANSWITCHANN, 0, 0, },
	{ offsetof(tDot11fBeacon2, ext_chan_switch_ann),
	offsetof(tDot11fIEext_chan_switch_ann, present), 0, "ext_chan_switch_ann",
	0, 6, 6, SigIeext_chan_switch_ann, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXT_CHAN_SWITCH_ANN, 0, 0, },
	{ offsetof(tDot11fBeacon2, SuppOperatingClasses),
	offsetof(tDot11fIESuppOperatingClasses, present), 0,
	"SuppOperatingClasses", 0, 3, 34, SigIeSuppOperatingClasses,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_SUPPOPERATINGCLASSES, 0, 0, },
	{ offsetof(tDot11fBeacon2, Quiet), offsetof(tDot11fIEQuiet, present), 0,
	"Quiet", 0, 8, 8, SigIeQuiet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QUIET, 0, 0, },
	{ offsetof(tDot11fBeacon2, TPCReport), offsetof(tDot11fIETPCReport,
	present), 0, "TPCReport", 0, 4, 4, SigIeTPCReport, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TPCREPORT, 0, 0, },
	{ offsetof(tDot11fBeacon2, ERPInfo), offsetof(tDot11fIEERPInfo, present),
	0, "ERPInfo", 0, 3, 3, SigIeERPInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_ERPINFO, 0, 0, },
	{ offsetof(tDot11fBeacon2, ExtSuppRates), offsetof(tDot11fIEExtSuppRates,
	present), 0, "ExtSuppRates", 0, 3, 14, SigIeExtSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTSUPPRATES, 0, 0, },
	{ offsetof(tDot11fBeacon2, RSNOpaque), offsetof(tDot11fIERSNOpaque,
	present), 0, "RSNOpaque", 0, 2, 255, SigIeRSNOpaque, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RSNOPAQUE, 0, 0, },
	{ offsetof(tDot11fBeacon2, EDCAParamSet), offsetof(tDot11fIEEDCAParamSet,
	present), 0, "EDCAParamSet", 0, 20, 20, SigIeEDCAParamSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EDCAPARAMSET, 0, 0, },
	{ offsetof(tDot11fBeacon2, APChannelReport),
	offsetof(tDot11fIEAPChannelReport, present), 0, "APChannelReport",
	0, 3, 53, SigIeAPChannelReport, {0, 0, 0, 0, 0},
	0, DOT11F_EID_APCHANNELREPORT, 0, 0, },
	{ offsetof(tDot11fBeacon2, RRMEnabledCap),
	offsetof(tDot11fIERRMEnabledCap, present), 0, "RRMEnabledCap",
	0, 7, 7, SigIeRRMEnabledCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RRMENABLEDCAP, 0, 0, },
	{ offsetof(tDot11fBeacon2, MobilityDomain),
	offsetof(tDot11fIEMobilityDomain, present), 0, "MobilityDomain",
	0, 5, 5, SigIeMobilityDomain, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MOBILITYDOMAIN, 0, 0, },
	{ offsetof(tDot11fBeacon2, WPA), offsetof(tDot11fIEWPA, present), 0, "WPA",
	0, 8, 50, SigIeWPA, {0, 80, 242, 1, 0}, 4, DOT11F_EID_WPA, 0, 0, },
	{ offsetof(tDot11fBeacon2, HTCaps), offsetof(tDot11fIEHTCaps, present), 0,
	"HTCaps", 0, 28, 60, SigIeHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fBeacon2, HTInfo), offsetof(tDot11fIEHTInfo, present), 0,
	"HTInfo", 0, 24, 56, SigIeHTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTINFO, 0, 0, },
	{ offsetof(tDot11fBeacon2, sec_chan_offset_ele),
	offsetof(tDot11fIEsec_chan_offset_ele, present), 0, "sec_chan_offset_ele",
	0, 3, 3, SigIesec_chan_offset_ele, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SEC_CHAN_OFFSET_ELE, 0, 0, },
	{ offsetof(tDot11fBeacon2, WMMInfoAp), offsetof(tDot11fIEWMMInfoAp,
	present), 0, "WMMInfoAp", 0, 9, 9, SigIeWMMInfoAp, {0, 80, 242, 2, 0},
	5, DOT11F_EID_WMMINFOAP, 0, 0, },
	{ offsetof(tDot11fBeacon2, WMMParams), offsetof(tDot11fIEWMMParams,
	present), 0, "WMMParams", 0, 26, 26, SigIeWMMParams, {0, 80, 242, 2, 1},
	5, DOT11F_EID_WMMPARAMS, 0, 0, },
	{ offsetof(tDot11fBeacon2, WMMCaps), offsetof(tDot11fIEWMMCaps, present),
	0, "WMMCaps", 0, 9, 9, SigIeWMMCaps, {0, 80, 242, 2, 5},
	5, DOT11F_EID_WMMCAPS, 0, 0, },
	{ offsetof(tDot11fBeacon2, WscBeacon), offsetof(tDot11fIEWscBeacon,
	present), 0, "WscBeacon", 0, 6, 84, SigIeWscBeacon, {0, 80, 242, 4, 0},
	4, DOT11F_EID_WSCBEACON, 0, 0, },
	{ offsetof(tDot11fBeacon2, WAPI), offsetof(tDot11fIEWAPI, present), 0,
	"WAPI", 0, 14, 112, SigIeWAPI, {0, 0, 0, 0, 0},
	0, DOT11F_EID_WAPI, 0, 0, },
	{ offsetof(tDot11fBeacon2, ESERadMgmtCap),
	offsetof(tDot11fIEESERadMgmtCap, present), 0, "ESERadMgmtCap",
	0, 8, 8, SigIeESERadMgmtCap, {0, 64, 150, 1, 0},
	4, DOT11F_EID_ESERADMGMTCAP, 0, 0, },
	{ offsetof(tDot11fBeacon2, ESETrafStrmMet),
	offsetof(tDot11fIEESETrafStrmMet, present), 0, "ESETrafStrmMet",
	0, 10, 10, SigIeESETrafStrmMet, {0, 64, 150, 7, 0},
	4, DOT11F_EID_ESETRAFSTRMMET, 0, 0, },
	{ offsetof(tDot11fBeacon2, ESETxmitPower),
	offsetof(tDot11fIEESETxmitPower, present), 0, "ESETxmitPower",
	0, 8, 8, SigIeESETxmitPower, {0, 64, 150, 0, 0},
	4, DOT11F_EID_ESETXMITPOWER, 0, 0, },
	{ offsetof(tDot11fBeacon2, P2PBeacon), offsetof(tDot11fIEP2PBeacon,
	present), 0, "P2PBeacon", 0, 6, 61, SigIeP2PBeacon, {80, 111, 154, 9, 0},
	4, DOT11F_EID_P2PBEACON, 0, 0, },
	{ offsetof(tDot11fBeacon2, VHTCaps), offsetof(tDot11fIEVHTCaps, present),
	0, "VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fBeacon2, VHTOperation), offsetof(tDot11fIEVHTOperation,
	present), 0, "VHTOperation", 0, 7, 7, SigIeVHTOperation, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTOPERATION, 0, 0, },
	{ offsetof(tDot11fBeacon2, transmit_power_env),
	offsetof(tDot11fIEtransmit_power_env, present),
	offsetof(tDot11fBeacon2, num_transmit_power_env), "transmit_power_env",
	8, 4, 11, SigIetransmit_power_env, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TRANSMIT_POWER_ENV, 0, 0, },
	{ offsetof(tDot11fBeacon2, ChannelSwitchWrapper),
	offsetof(tDot11fIEChannelSwitchWrapper, present), 0,
	"ChannelSwitchWrapper", 0, 2, 18, SigIeChannelSwitchWrapper,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_CHANNELSWITCHWRAPPER, 0, 0, },
	{ offsetof(tDot11fBeacon2, VHTExtBssLoad),
	offsetof(tDot11fIEVHTExtBssLoad, present), 0, "VHTExtBssLoad",
	0, 7, 7, SigIeVHTExtBssLoad, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTEXTBSSLOAD, 0, 0, },
	{ offsetof(tDot11fBeacon2, ExtCap), offsetof(tDot11fIEExtCap, present), 0,
	"ExtCap", 0, 3, 17, SigIeExtCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fBeacon2, OperatingMode),
	offsetof(tDot11fIEOperatingMode, present), 0, "OperatingMode",
	0, 3, 3, SigIeOperatingMode, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OPERATINGMODE, 0, 0, },
	{ offsetof(tDot11fBeacon2, WiderBWChanSwitchAnn),
	offsetof(tDot11fIEWiderBWChanSwitchAnn, present), 0,
	"WiderBWChanSwitchAnn", 0, 5, 5, SigIeWiderBWChanSwitchAnn,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_WIDERBWCHANSWITCHANN, 0, 0, },
	{ offsetof(tDot11fBeacon2, OBSSScanParameters),
	offsetof(tDot11fIEOBSSScanParameters, present), 0, "OBSSScanParameters",
	0, 16, 16, SigIeOBSSScanParameters, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OBSSSCANPARAMETERS, 0, 0, },
	{ offsetof(tDot11fBeacon2, fils_indication),
	offsetof(tDot11fIEfils_indication, present), 0, "fils_indication",
	0, 6, 259, SigIefils_indication, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_INDICATION, 0, 0, },
	{ offsetof(tDot11fBeacon2, Vendor1IE), offsetof(tDot11fIEVendor1IE,
	present), 0, "Vendor1IE", 0, 5, 5, SigIeVendor1IE, {0, 16, 24, 0, 0},
	3, DOT11F_EID_VENDOR1IE, 0, 0, },
	{ offsetof(tDot11fBeacon2, vendor_vht_ie),
	offsetof(tDot11fIEvendor_vht_ie, present), 0, "vendor_vht_ie",
	0, 7, 28, SigIevendor_vht_ie, {0, 144, 76, 4, 0},
	4, DOT11F_EID_VENDOR_VHT_IE, 0, 0, },
	{ offsetof(tDot11fBeacon2, Vendor3IE), offsetof(tDot11fIEVendor3IE,
	present), 0, "Vendor3IE", 0, 5, 5, SigIeVendor3IE, {0, 22, 50, 0, 0},
	3, DOT11F_EID_VENDOR3IE, 0, 0, },
	{ offsetof(tDot11fBeacon2, hs20vendor_ie),
	offsetof(tDot11fIEhs20vendor_ie, present), 0, "hs20vendor_ie",
	0, 7, 9, SigIehs20vendor_ie, {80, 111, 154, 16, 0},
	4, DOT11F_EID_HS20VENDOR_IE, 0, 0, },
	{ offsetof(tDot11fBeacon2, QComVendorIE), offsetof(tDot11fIEQComVendorIE,
	present), 0, "QComVendorIE", 0, 7, 7, SigIeQComVendorIE,
	{0, 160, 198, 0, 0}, 3, DOT11F_EID_QCOMVENDORIE, 0, 0, },
	{ offsetof(tDot11fBeacon2, ESEVersion), offsetof(tDot11fIEESEVersion,
	present), 0, "ESEVersion", 0, 7, 7, SigIeESEVersion, {0, 64, 150, 3, 0},
	4, DOT11F_EID_ESEVERSION, 0, 0, },
	{ offsetof(tDot11fBeacon2, qcn_ie), offsetof(tDot11fIEqcn_ie, present), 0,
	"qcn_ie", 0, 6, 37, SigIeqcn_ie, {140, 253, 240, 1, 0},
	4, DOT11F_EID_QCN_IE, 0, 0, },
	{ offsetof(tDot11fBeacon2, he_cap), offsetof(tDot11fIEhe_cap, present), 0,
	"he_cap", 0, 23, 56, SigIehe_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_CAP, 35, 0, },
	{ offsetof(tDot11fBeacon2, he_op), offsetof(tDot11fIEhe_op, present), 0,
	"he_op", 0, 8, 17, SigIehe_op, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_OP, 36, 0, },
	{ offsetof(tDot11fBeacon2, he_6ghz_band_cap),
	offsetof(tDot11fIEhe_6ghz_band_cap, present), 0, "he_6ghz_band_cap",
	0, 4, 4, SigIehe_6ghz_band_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_6GHZ_BAND_CAP, 59, 0, },
	{ offsetof(tDot11fBeacon2, bss_color_change),
	offsetof(tDot11fIEbss_color_change, present), 0, "bss_color_change",
	0, 4, 4, SigIebss_color_change, {0, 0, 0, 0, 0},
	0, DOT11F_EID_BSS_COLOR_CHANGE, 42, 0, },
	{ offsetof(tDot11fBeacon2, mu_edca_param_set),
	offsetof(tDot11fIEmu_edca_param_set, present), 0, "mu_edca_param_set",
	0, 15, 15, SigIemu_edca_param_set, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MU_EDCA_PARAM_SET, 38, 0, },
	{ offsetof(tDot11fBeacon2, esp_information),
	offsetof(tDot11fIEesp_information, present), 0, "esp_information",
	0, 2, 98, SigIeesp_information, {0, 0, 0, 0, 0},
	0, DOT11F_EID_ESP_INFORMATION, 11, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_beacon2(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fBeacon2 *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_Beacon2, IES_Beacon2,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_beacon2. */

static const tFFDefn FFS_BeaconIEs[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_BeaconIEs[] = {
	{ offsetof(tDot11fBeaconIEs, SSID), offsetof(tDot11fIESSID, present), 0,
	"SSID", 0, 2, 34, SigIeSSID, {0, 0, 0, 0, 0}, 0, DOT11F_EID_SSID, 0, 1, },
	{ offsetof(tDot11fBeaconIEs, SuppRates), offsetof(tDot11fIESuppRates,
	present), 0, "SuppRates", 0, 2, 14, SigIeSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPRATES, 0, 1, },
	{ offsetof(tDot11fBeaconIEs, FHParamSet), offsetof(tDot11fIEFHParamSet,
	present), 0, "FHParamSet", 0, 7, 7, SigIeFHParamSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FHPARAMSET, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, DSParams), offsetof(tDot11fIEDSParams,
	present), 0, "DSParams", 0, 3, 3, SigIeDSParams, {0, 0, 0, 0, 0},
	0, DOT11F_EID_DSPARAMS, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, CFParams), offsetof(tDot11fIECFParams,
	present), 0, "CFParams", 0, 8, 8, SigIeCFParams, {0, 0, 0, 0, 0},
	0, DOT11F_EID_CFPARAMS, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, TIM), offsetof(tDot11fIETIM, present), 0,
	"TIM", 0, 6, 256, SigIeTIM, {0, 0, 0, 0, 0}, 0, DOT11F_EID_TIM, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, Country), offsetof(tDot11fIECountry,
	present), 0, "Country", 0, 8, 248, SigIeCountry, {0, 0, 0, 0, 0},
	0, DOT11F_EID_COUNTRY, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, FHParams), offsetof(tDot11fIEFHParams,
	present), 0, "FHParams", 0, 4, 4, SigIeFHParams, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FHPARAMS, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, FHPattTable), offsetof(tDot11fIEFHPattTable,
	present), 0, "FHPattTable", 0, 6, 257, SigIeFHPattTable, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FHPATTTABLE, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, PowerConstraints),
	offsetof(tDot11fIEPowerConstraints, present), 0, "PowerConstraints",
	0, 3, 3, SigIePowerConstraints, {0, 0, 0, 0, 0},
	0, DOT11F_EID_POWERCONSTRAINTS, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, ChanSwitchAnn),
	offsetof(tDot11fIEChanSwitchAnn, present), 0, "ChanSwitchAnn",
	0, 5, 5, SigIeChanSwitchAnn, {0, 0, 0, 0, 0},
	0, DOT11F_EID_CHANSWITCHANN, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, ext_chan_switch_ann),
	offsetof(tDot11fIEext_chan_switch_ann, present), 0, "ext_chan_switch_ann",
	0, 6, 6, SigIeext_chan_switch_ann, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXT_CHAN_SWITCH_ANN, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, SuppOperatingClasses),
	offsetof(tDot11fIESuppOperatingClasses, present), 0,
	"SuppOperatingClasses", 0, 3, 34, SigIeSuppOperatingClasses,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_SUPPOPERATINGCLASSES, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, Quiet), offsetof(tDot11fIEQuiet, present), 0,
	"Quiet", 0, 8, 8, SigIeQuiet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QUIET, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, TPCReport), offsetof(tDot11fIETPCReport,
	present), 0, "TPCReport", 0, 4, 4, SigIeTPCReport, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TPCREPORT, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, ERPInfo), offsetof(tDot11fIEERPInfo,
	present), 0, "ERPInfo", 0, 3, 3, SigIeERPInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_ERPINFO, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, ExtSuppRates),
	offsetof(tDot11fIEExtSuppRates, present), 0, "ExtSuppRates",
	0, 3, 14, SigIeExtSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTSUPPRATES, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, RSN), offsetof(tDot11fIERSN, present), 0,
	"RSN", 0, 4, 132, SigIeRSN, {0, 0, 0, 0, 0}, 0, DOT11F_EID_RSN, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, QBSSLoad), offsetof(tDot11fIEQBSSLoad,
	present), 0, "QBSSLoad", 0, 7, 7, SigIeQBSSLoad, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QBSSLOAD, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, EDCAParamSet),
	offsetof(tDot11fIEEDCAParamSet, present), 0, "EDCAParamSet",
	0, 20, 20, SigIeEDCAParamSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EDCAPARAMSET, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, QOSCapsAp), offsetof(tDot11fIEQOSCapsAp,
	present), 0, "QOSCapsAp", 0, 3, 3, SigIeQOSCapsAp, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QOSCAPSAP, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, APChannelReport),
	offsetof(tDot11fIEAPChannelReport, present), 0, "APChannelReport",
	0, 3, 53, SigIeAPChannelReport, {0, 0, 0, 0, 0},
	0, DOT11F_EID_APCHANNELREPORT, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, RRMEnabledCap),
	offsetof(tDot11fIERRMEnabledCap, present), 0, "RRMEnabledCap",
	0, 7, 7, SigIeRRMEnabledCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RRMENABLEDCAP, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, MobilityDomain),
	offsetof(tDot11fIEMobilityDomain, present), 0, "MobilityDomain",
	0, 5, 5, SigIeMobilityDomain, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MOBILITYDOMAIN, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, WPA), offsetof(tDot11fIEWPA, present), 0,
	"WPA", 0, 8, 50, SigIeWPA, {0, 80, 242, 1, 0}, 4, DOT11F_EID_WPA, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, HTCaps), offsetof(tDot11fIEHTCaps, present),
	0, "HTCaps", 0, 28, 60, SigIeHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, HTInfo), offsetof(tDot11fIEHTInfo, present),
	0, "HTInfo", 0, 24, 56, SigIeHTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTINFO, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, sec_chan_offset_ele),
	offsetof(tDot11fIEsec_chan_offset_ele, present), 0, "sec_chan_offset_ele",
	0, 3, 3, SigIesec_chan_offset_ele, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SEC_CHAN_OFFSET_ELE, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, WMMInfoAp), offsetof(tDot11fIEWMMInfoAp,
	present), 0, "WMMInfoAp", 0, 9, 9, SigIeWMMInfoAp, {0, 80, 242, 2, 0},
	5, DOT11F_EID_WMMINFOAP, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, WMMParams), offsetof(tDot11fIEWMMParams,
	present), 0, "WMMParams", 0, 26, 26, SigIeWMMParams, {0, 80, 242, 2, 1},
	5, DOT11F_EID_WMMPARAMS, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, WMMCaps), offsetof(tDot11fIEWMMCaps,
	present), 0, "WMMCaps", 0, 9, 9, SigIeWMMCaps, {0, 80, 242, 2, 5},
	5, DOT11F_EID_WMMCAPS, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, WAPI), offsetof(tDot11fIEWAPI, present), 0,
	"WAPI", 0, 14, 112, SigIeWAPI, {0, 0, 0, 0, 0},
	0, DOT11F_EID_WAPI, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, ESEVersion), offsetof(tDot11fIEESEVersion,
	present), 0, "ESEVersion", 0, 7, 7, SigIeESEVersion, {0, 64, 150, 3, 0},
	4, DOT11F_EID_ESEVERSION, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, ESERadMgmtCap),
	offsetof(tDot11fIEESERadMgmtCap, present), 0, "ESERadMgmtCap",
	0, 8, 8, SigIeESERadMgmtCap, {0, 64, 150, 1, 0},
	4, DOT11F_EID_ESERADMGMTCAP, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, ESETrafStrmMet),
	offsetof(tDot11fIEESETrafStrmMet, present), 0, "ESETrafStrmMet",
	0, 10, 10, SigIeESETrafStrmMet, {0, 64, 150, 7, 0},
	4, DOT11F_EID_ESETRAFSTRMMET, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, ESETxmitPower),
	offsetof(tDot11fIEESETxmitPower, present), 0, "ESETxmitPower",
	0, 8, 8, SigIeESETxmitPower, {0, 64, 150, 0, 0},
	4, DOT11F_EID_ESETXMITPOWER, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, WscBeaconProbeRes),
	offsetof(tDot11fIEWscBeaconProbeRes, present), 0, "WscBeaconProbeRes",
	0, 6, 319, SigIeWscBeaconProbeRes, {0, 80, 242, 4, 0},
	4, DOT11F_EID_WSCBEACONPROBERES, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, P2PBeaconProbeRes),
	offsetof(tDot11fIEP2PBeaconProbeRes, present), 0, "P2PBeaconProbeRes",
	0, 6, 1150, SigIeP2PBeaconProbeRes, {80, 111, 154, 9, 0},
	4, DOT11F_EID_P2PBEACONPROBERES, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, VHTCaps), offsetof(tDot11fIEVHTCaps,
	present), 0, "VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, VHTOperation),
	offsetof(tDot11fIEVHTOperation, present), 0, "VHTOperation",
	0, 7, 7, SigIeVHTOperation, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTOPERATION, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, transmit_power_env),
	offsetof(tDot11fIEtransmit_power_env, present),
	offsetof(tDot11fBeaconIEs, num_transmit_power_env),
	"transmit_power_env", 8, 4, 11, SigIetransmit_power_env, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TRANSMIT_POWER_ENV, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, VHTExtBssLoad),
	offsetof(tDot11fIEVHTExtBssLoad, present), 0, "VHTExtBssLoad",
	0, 7, 7, SigIeVHTExtBssLoad, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTEXTBSSLOAD, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, ExtCap), offsetof(tDot11fIEExtCap, present),
	0, "ExtCap", 0, 3, 17, SigIeExtCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, OperatingMode),
	offsetof(tDot11fIEOperatingMode, present), 0, "OperatingMode",
	0, 3, 3, SigIeOperatingMode, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OPERATINGMODE, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, WiderBWChanSwitchAnn),
	offsetof(tDot11fIEWiderBWChanSwitchAnn, present), 0,
	"WiderBWChanSwitchAnn", 0, 5, 5, SigIeWiderBWChanSwitchAnn,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_WIDERBWCHANSWITCHANN, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, OBSSScanParameters),
	offsetof(tDot11fIEOBSSScanParameters, present), 0, "OBSSScanParameters",
	0, 16, 16, SigIeOBSSScanParameters, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OBSSSCANPARAMETERS, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, fils_indication),
	offsetof(tDot11fIEfils_indication, present), 0, "fils_indication",
	0, 6, 259, SigIefils_indication, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_INDICATION, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, Vendor1IE), offsetof(tDot11fIEVendor1IE,
	present), 0, "Vendor1IE", 0, 5, 5, SigIeVendor1IE, {0, 16, 24, 0, 0},
	3, DOT11F_EID_VENDOR1IE, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, vendor_vht_ie),
	offsetof(tDot11fIEvendor_vht_ie, present), 0, "vendor_vht_ie",
	0, 7, 28, SigIevendor_vht_ie, {0, 144, 76, 4, 0},
	4, DOT11F_EID_VENDOR_VHT_IE, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, Vendor3IE), offsetof(tDot11fIEVendor3IE,
	present), 0, "Vendor3IE", 0, 5, 5, SigIeVendor3IE, {0, 22, 50, 0, 0},
	3, DOT11F_EID_VENDOR3IE, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, hs20vendor_ie),
	offsetof(tDot11fIEhs20vendor_ie, present), 0, "hs20vendor_ie",
	0, 7, 9, SigIehs20vendor_ie, {80, 111, 154, 16, 0},
	4, DOT11F_EID_HS20VENDOR_IE, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, ChannelSwitchWrapper),
	offsetof(tDot11fIEChannelSwitchWrapper, present), 0,
	"ChannelSwitchWrapper", 0, 2, 18, SigIeChannelSwitchWrapper,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_CHANNELSWITCHWRAPPER, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, QComVendorIE),
	offsetof(tDot11fIEQComVendorIE, present), 0, "QComVendorIE",
	0, 7, 7, SigIeQComVendorIE, {0, 160, 198, 0, 0},
	3, DOT11F_EID_QCOMVENDORIE, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, MBO_IE), offsetof(tDot11fIEMBO_IE, present),
	0, "MBO_IE", 0, 6, 295, SigIeMBO_IE, {80, 111, 154, 22, 0},
	4, DOT11F_EID_MBO_IE, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, qcn_ie), offsetof(tDot11fIEqcn_ie, present),
	0, "qcn_ie", 0, 6, 37, SigIeqcn_ie, {140, 253, 240, 1, 0},
	4, DOT11F_EID_QCN_IE, 0, 0, },
	{ offsetof(tDot11fBeaconIEs, he_cap), offsetof(tDot11fIEhe_cap, present),
	0, "he_cap", 0, 23, 56, SigIehe_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_CAP, 35, 0, },
	{ offsetof(tDot11fBeaconIEs, he_op), offsetof(tDot11fIEhe_op, present), 0,
	"he_op", 0, 8, 17, SigIehe_op, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_OP, 36, 0, },
	{ offsetof(tDot11fBeaconIEs, he_6ghz_band_cap),
	offsetof(tDot11fIEhe_6ghz_band_cap, present), 0, "he_6ghz_band_cap",
	0, 4, 4, SigIehe_6ghz_band_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_6GHZ_BAND_CAP, 59, 0, },
	{ offsetof(tDot11fBeaconIEs, bss_color_change),
	offsetof(tDot11fIEbss_color_change, present), 0, "bss_color_change",
	0, 4, 4, SigIebss_color_change, {0, 0, 0, 0, 0},
	0, DOT11F_EID_BSS_COLOR_CHANGE, 42, 0, },
	{ offsetof(tDot11fBeaconIEs, mu_edca_param_set),
	offsetof(tDot11fIEmu_edca_param_set, present), 0, "mu_edca_param_set",
	0, 15, 15, SigIemu_edca_param_set, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MU_EDCA_PARAM_SET, 38, 0, },
	{ offsetof(tDot11fBeaconIEs, esp_information),
	offsetof(tDot11fIEesp_information, present), 0, "esp_information",
	0, 2, 98, SigIeesp_information, {0, 0, 0, 0, 0},
	0, DOT11F_EID_ESP_INFORMATION, 11, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_beacon_i_es(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fBeaconIEs *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_BeaconIEs, IES_BeaconIEs,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_beacon_i_es. */

static const tFFDefn FFS_ChannelSwitch[] = {
	{ "Category", offsetof(tDot11fChannelSwitch, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fChannelSwitch, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_ChannelSwitch[] = {
	{ offsetof(tDot11fChannelSwitch, ChanSwitchAnn),
	offsetof(tDot11fIEChanSwitchAnn, present), 0, "ChanSwitchAnn",
	0, 5, 5, SigIeChanSwitchAnn, {0, 0, 0, 0, 0},
	0, DOT11F_EID_CHANSWITCHANN, 0, 1, },
	{ offsetof(tDot11fChannelSwitch, sec_chan_offset_ele),
	offsetof(tDot11fIEsec_chan_offset_ele, present), 0, "sec_chan_offset_ele",
	0, 3, 3, SigIesec_chan_offset_ele, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SEC_CHAN_OFFSET_ELE, 0, 0, },
	{ offsetof(tDot11fChannelSwitch, WiderBWChanSwitchAnn),
	offsetof(tDot11fIEWiderBWChanSwitchAnn, present), 0,
	"WiderBWChanSwitchAnn", 0, 5, 5, SigIeWiderBWChanSwitchAnn,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_WIDERBWCHANSWITCHANN, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_channel_switch(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fChannelSwitch *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_ChannelSwitch, IES_ChannelSwitch,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_channel_switch. */

static const tFFDefn FFS_DeAuth[] = {
	{ "Reason", offsetof(tDot11fDeAuth, Reason), SigFfReason,
	DOT11F_FF_REASON_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_DeAuth[] = {
	{ offsetof(tDot11fDeAuth, P2PDeAuth), offsetof(tDot11fIEP2PDeAuth,
	present), 0, "P2PDeAuth", 0, 6, 10, SigIeP2PDeAuth, {80, 111, 154, 9, 0},
	4, DOT11F_EID_P2PDEAUTH, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_de_auth(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fDeAuth *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_DeAuth, IES_DeAuth,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_de_auth. */

static const tFFDefn FFS_DelTS[] = {
	{ "Category", offsetof(tDot11fDelTS, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fDelTS, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "TSInfo", offsetof(tDot11fDelTS, TSInfo), SigFfTSInfo,
	DOT11F_FF_TSINFO_LEN, },
	{ "Reason", offsetof(tDot11fDelTS, Reason), SigFfReason,
	DOT11F_FF_REASON_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_DelTS[] = {
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_del_ts(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fDelTS *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_DelTS, IES_DelTS,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_del_ts. */

static const tFFDefn FFS_Disassociation[] = {
	{ "Reason", offsetof(tDot11fDisassociation, Reason), SigFfReason,
	DOT11F_FF_REASON_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_Disassociation[] = {
	{ offsetof(tDot11fDisassociation, P2PDisAssoc),
	offsetof(tDot11fIEP2PDisAssoc, present), 0, "P2PDisAssoc",
	0, 6, 10, SigIeP2PDisAssoc, {80, 111, 154, 9, 0},
	4, DOT11F_EID_P2PDISASSOC, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_disassociation(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fDisassociation *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_Disassociation, IES_Disassociation,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_disassociation. */

static const tFFDefn FFS_LinkMeasurementReport[] = {
	{ "Category", offsetof(tDot11fLinkMeasurementReport, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fLinkMeasurementReport, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fLinkMeasurementReport, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ "TPCEleID", offsetof(tDot11fLinkMeasurementReport, TPCEleID),
	SigFfTPCEleID, DOT11F_FF_TPCELEID_LEN, },
	{ "TPCEleLen", offsetof(tDot11fLinkMeasurementReport, TPCEleLen),
	SigFfTPCEleLen, DOT11F_FF_TPCELELEN_LEN, },
	{ "TxPower", offsetof(tDot11fLinkMeasurementReport, TxPower),
	SigFfTxPower, DOT11F_FF_TXPOWER_LEN, },
	{ "LinkMargin", offsetof(tDot11fLinkMeasurementReport, LinkMargin),
	SigFfLinkMargin, DOT11F_FF_LINKMARGIN_LEN, },
	{ "RxAntennaId", offsetof(tDot11fLinkMeasurementReport, RxAntennaId),
	SigFfRxAntennaId, DOT11F_FF_RXANTENNAID_LEN, },
	{ "TxAntennaId", offsetof(tDot11fLinkMeasurementReport, TxAntennaId),
	SigFfTxAntennaId, DOT11F_FF_TXANTENNAID_LEN, },
	{ "RCPI", offsetof(tDot11fLinkMeasurementReport, RCPI), SigFfRCPI,
	DOT11F_FF_RCPI_LEN, },
	{ "RSNI", offsetof(tDot11fLinkMeasurementReport, RSNI), SigFfRSNI,
	DOT11F_FF_RSNI_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_LinkMeasurementReport[] = {
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_link_measurement_report(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fLinkMeasurementReport *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_LinkMeasurementReport, IES_LinkMeasurementReport,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_link_measurement_report. */

static const tFFDefn FFS_LinkMeasurementRequest[] = {
	{ "Category", offsetof(tDot11fLinkMeasurementRequest, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fLinkMeasurementRequest, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fLinkMeasurementRequest, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ "TxPower", offsetof(tDot11fLinkMeasurementRequest, TxPower),
	SigFfTxPower, DOT11F_FF_TXPOWER_LEN, },
	{ "MaxTxPower", offsetof(tDot11fLinkMeasurementRequest, MaxTxPower),
	SigFfMaxTxPower, DOT11F_FF_MAXTXPOWER_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_LinkMeasurementRequest[] = {
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_link_measurement_request(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fLinkMeasurementRequest *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_LinkMeasurementRequest, IES_LinkMeasurementRequest,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_link_measurement_request. */

static const tFFDefn FFS_MeasurementReport[] = {
	{ "Category", offsetof(tDot11fMeasurementReport, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fMeasurementReport, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fMeasurementReport, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_MeasurementReport[] = {
	{ offsetof(tDot11fMeasurementReport, MeasurementReport),
	offsetof(tDot11fIEMeasurementReport, present), 0, "MeasurementReport",
	0, 5, 31, SigIeMeasurementReport, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MEASUREMENTREPORT, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_measurement_report(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fMeasurementReport *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_MeasurementReport, IES_MeasurementReport,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_measurement_report. */

static const tFFDefn FFS_MeasurementRequest[] = {
	{ "Category", offsetof(tDot11fMeasurementRequest, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fMeasurementRequest, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fMeasurementRequest, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_MeasurementRequest[] = {
	{ offsetof(tDot11fMeasurementRequest, MeasurementRequest),
	offsetof(tDot11fIEMeasurementRequest, present),
	offsetof(tDot11fMeasurementRequest, num_MeasurementRequest),
	"MeasurementRequest", 4, 6, 18, SigIeMeasurementRequest, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MEASUREMENTREQUEST, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_measurement_request(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fMeasurementRequest *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_MeasurementRequest, IES_MeasurementRequest,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_measurement_request. */

static const tFFDefn FFS_NeighborReportRequest[] = {
	{ "Category", offsetof(tDot11fNeighborReportRequest, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fNeighborReportRequest, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fNeighborReportRequest, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_NeighborReportRequest[] = {
	{ offsetof(tDot11fNeighborReportRequest, SSID), offsetof(tDot11fIESSID,
	present), 0, "SSID", 0, 2, 34, SigIeSSID, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SSID, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_neighbor_report_request(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fNeighborReportRequest *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_NeighborReportRequest, IES_NeighborReportRequest,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_neighbor_report_request. */

static const tFFDefn FFS_NeighborReportResponse[] = {
	{ "Category", offsetof(tDot11fNeighborReportResponse, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fNeighborReportResponse, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fNeighborReportResponse, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_NeighborReportResponse[] = {
	{ offsetof(tDot11fNeighborReportResponse, NeighborReport),
	offsetof(tDot11fIENeighborReport, present),
	offsetof(tDot11fNeighborReportResponse, num_NeighborReport),
	"NeighborReport", 15, 15, 548, SigIeNeighborReport, {0, 0, 0, 0, 0},
	0, DOT11F_EID_NEIGHBORREPORT, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_neighbor_report_response(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fNeighborReportResponse *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_NeighborReportResponse, IES_NeighborReportResponse,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_neighbor_report_response. */

static const tFFDefn FFS_OperatingMode[] = {
	{ "Category", offsetof(tDot11fOperatingMode, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fOperatingMode, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "OperatingMode", offsetof(tDot11fOperatingMode, OperatingMode),
	SigFfOperatingMode, DOT11F_FF_OPERATINGMODE_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_OperatingMode[] = {
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_operating_mode(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fOperatingMode *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_OperatingMode, IES_OperatingMode,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_operating_mode. */

static const tFFDefn FFS_ProbeRequest[] = {
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_ProbeRequest[] = {
	{ offsetof(tDot11fProbeRequest, SSID), offsetof(tDot11fIESSID, present), 0,
	"SSID", 0, 2, 34, SigIeSSID, {0, 0, 0, 0, 0}, 0, DOT11F_EID_SSID, 0, 1, },
	{ offsetof(tDot11fProbeRequest, SuppRates), offsetof(tDot11fIESuppRates,
	present), 0, "SuppRates", 0, 2, 14, SigIeSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPRATES, 0, 1, },
	{ offsetof(tDot11fProbeRequest, RequestedInfo),
	offsetof(tDot11fIERequestedInfo, present), 0, "RequestedInfo",
	0, 2, 257, SigIeRequestedInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_REQUESTEDINFO, 0, 0, },
	{ offsetof(tDot11fProbeRequest, ExtSuppRates),
	offsetof(tDot11fIEExtSuppRates, present), 0, "ExtSuppRates",
	0, 3, 14, SigIeExtSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTSUPPRATES, 0, 0, },
	{ offsetof(tDot11fProbeRequest, DSParams), offsetof(tDot11fIEDSParams,
	present), 0, "DSParams", 0, 3, 3, SigIeDSParams, {0, 0, 0, 0, 0},
	0, DOT11F_EID_DSPARAMS, 0, 0, },
	{ offsetof(tDot11fProbeRequest, HTCaps), offsetof(tDot11fIEHTCaps,
	present), 0, "HTCaps", 0, 28, 60, SigIeHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fProbeRequest, WscProbeReq),
	offsetof(tDot11fIEWscProbeReq, present), 0, "WscProbeReq",
	0, 6, 286, SigIeWscProbeReq, {0, 80, 242, 4, 0},
	4, DOT11F_EID_WSCPROBEREQ, 0, 0, },
	{ offsetof(tDot11fProbeRequest, WFATPC), offsetof(tDot11fIEWFATPC,
	present), 0, "WFATPC", 0, 9, 9, SigIeWFATPC, {0, 80, 242, 8, 0},
	5, DOT11F_EID_WFATPC, 0, 0, },
	{ offsetof(tDot11fProbeRequest, P2PProbeReq),
	offsetof(tDot11fIEP2PProbeReq, present), 0, "P2PProbeReq",
	0, 6, 43, SigIeP2PProbeReq, {80, 111, 154, 9, 0},
	4, DOT11F_EID_P2PPROBEREQ, 0, 0, },
	{ offsetof(tDot11fProbeRequest, VHTCaps), offsetof(tDot11fIEVHTCaps,
	present), 0, "VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fProbeRequest, ExtCap), offsetof(tDot11fIEExtCap,
	present), 0, "ExtCap", 0, 3, 17, SigIeExtCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fProbeRequest, qcn_ie), offsetof(tDot11fIEqcn_ie,
	present), 0, "qcn_ie", 0, 6, 37, SigIeqcn_ie, {140, 253, 240, 1, 0},
	4, DOT11F_EID_QCN_IE, 0, 0, },
	{ offsetof(tDot11fProbeRequest, he_cap), offsetof(tDot11fIEhe_cap,
	present), 0, "he_cap", 0, 23, 56, SigIehe_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_CAP, 35, 0, },
	{ offsetof(tDot11fProbeRequest, he_6ghz_band_cap),
	offsetof(tDot11fIEhe_6ghz_band_cap, present), 0, "he_6ghz_band_cap",
	0, 4, 4, SigIehe_6ghz_band_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_6GHZ_BAND_CAP, 59, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_probe_request(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fProbeRequest *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_ProbeRequest, IES_ProbeRequest,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_probe_request. */

static const tFFDefn FFS_ProbeResponse[] = {
	{ "TimeStamp", offsetof(tDot11fProbeResponse, TimeStamp), SigFfTimeStamp,
	DOT11F_FF_TIMESTAMP_LEN, },
	{ "BeaconInterval", offsetof(tDot11fProbeResponse, BeaconInterval),
	SigFfBeaconInterval, DOT11F_FF_BEACONINTERVAL_LEN, },
	{ "Capabilities", offsetof(tDot11fProbeResponse, Capabilities),
	SigFfCapabilities, DOT11F_FF_CAPABILITIES_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_ProbeResponse[] = {
	{ offsetof(tDot11fProbeResponse, SSID), offsetof(tDot11fIESSID, present),
	0, "SSID", 0, 2, 34, SigIeSSID, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SSID, 0, 1, },
	{ offsetof(tDot11fProbeResponse, SuppRates), offsetof(tDot11fIESuppRates,
	present), 0, "SuppRates", 0, 2, 14, SigIeSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPRATES, 0, 1, },
	{ offsetof(tDot11fProbeResponse, FHParamSet),
	offsetof(tDot11fIEFHParamSet, present), 0, "FHParamSet",
	0, 7, 7, SigIeFHParamSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FHPARAMSET, 0, 0, },
	{ offsetof(tDot11fProbeResponse, DSParams), offsetof(tDot11fIEDSParams,
	present), 0, "DSParams", 0, 3, 3, SigIeDSParams, {0, 0, 0, 0, 0},
	0, DOT11F_EID_DSPARAMS, 0, 0, },
	{ offsetof(tDot11fProbeResponse, CFParams), offsetof(tDot11fIECFParams,
	present), 0, "CFParams", 0, 8, 8, SigIeCFParams, {0, 0, 0, 0, 0},
	0, DOT11F_EID_CFPARAMS, 0, 0, },
	{ offsetof(tDot11fProbeResponse, Country), offsetof(tDot11fIECountry,
	present), 0, "Country", 0, 8, 248, SigIeCountry, {0, 0, 0, 0, 0},
	0, DOT11F_EID_COUNTRY, 0, 0, },
	{ offsetof(tDot11fProbeResponse, FHParams), offsetof(tDot11fIEFHParams,
	present), 0, "FHParams", 0, 4, 4, SigIeFHParams, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FHPARAMS, 0, 0, },
	{ offsetof(tDot11fProbeResponse, FHPattTable),
	offsetof(tDot11fIEFHPattTable, present), 0, "FHPattTable",
	0, 6, 257, SigIeFHPattTable, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FHPATTTABLE, 0, 0, },
	{ offsetof(tDot11fProbeResponse, PowerConstraints),
	offsetof(tDot11fIEPowerConstraints, present), 0, "PowerConstraints",
	0, 3, 3, SigIePowerConstraints, {0, 0, 0, 0, 0},
	0, DOT11F_EID_POWERCONSTRAINTS, 0, 0, },
	{ offsetof(tDot11fProbeResponse, ChanSwitchAnn),
	offsetof(tDot11fIEChanSwitchAnn, present), 0, "ChanSwitchAnn",
	0, 5, 5, SigIeChanSwitchAnn, {0, 0, 0, 0, 0},
	0, DOT11F_EID_CHANSWITCHANN, 0, 0, },
	{ offsetof(tDot11fProbeResponse, ext_chan_switch_ann),
	offsetof(tDot11fIEext_chan_switch_ann, present), 0, "ext_chan_switch_ann",
	0, 6, 6, SigIeext_chan_switch_ann, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXT_CHAN_SWITCH_ANN, 0, 0, },
	{ offsetof(tDot11fProbeResponse, SuppOperatingClasses),
	offsetof(tDot11fIESuppOperatingClasses, present), 0,
	"SuppOperatingClasses", 0, 3, 34, SigIeSuppOperatingClasses,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_SUPPOPERATINGCLASSES, 0, 0, },
	{ offsetof(tDot11fProbeResponse, Quiet), offsetof(tDot11fIEQuiet,
	present), 0, "Quiet", 0, 8, 8, SigIeQuiet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QUIET, 0, 0, },
	{ offsetof(tDot11fProbeResponse, TPCReport), offsetof(tDot11fIETPCReport,
	present), 0, "TPCReport", 0, 4, 4, SigIeTPCReport, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TPCREPORT, 0, 0, },
	{ offsetof(tDot11fProbeResponse, ERPInfo), offsetof(tDot11fIEERPInfo,
	present), 0, "ERPInfo", 0, 3, 3, SigIeERPInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_ERPINFO, 0, 0, },
	{ offsetof(tDot11fProbeResponse, ExtSuppRates),
	offsetof(tDot11fIEExtSuppRates, present), 0, "ExtSuppRates",
	0, 3, 14, SigIeExtSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTSUPPRATES, 0, 0, },
	{ offsetof(tDot11fProbeResponse, RSNOpaque), offsetof(tDot11fIERSNOpaque,
	present), 0, "RSNOpaque", 0, 2, 255, SigIeRSNOpaque, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RSNOPAQUE, 0, 0, },
	{ offsetof(tDot11fProbeResponse, QBSSLoad), offsetof(tDot11fIEQBSSLoad,
	present), 0, "QBSSLoad", 0, 7, 7, SigIeQBSSLoad, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QBSSLOAD, 0, 0, },
	{ offsetof(tDot11fProbeResponse, EDCAParamSet),
	offsetof(tDot11fIEEDCAParamSet, present), 0, "EDCAParamSet",
	0, 20, 20, SigIeEDCAParamSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EDCAPARAMSET, 0, 0, },
	{ offsetof(tDot11fProbeResponse, RRMEnabledCap),
	offsetof(tDot11fIERRMEnabledCap, present), 0, "RRMEnabledCap",
	0, 7, 7, SigIeRRMEnabledCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RRMENABLEDCAP, 0, 0, },
	{ offsetof(tDot11fProbeResponse, APChannelReport),
	offsetof(tDot11fIEAPChannelReport, present), 0, "APChannelReport",
	0, 3, 53, SigIeAPChannelReport, {0, 0, 0, 0, 0},
	0, DOT11F_EID_APCHANNELREPORT, 0, 0, },
	{ offsetof(tDot11fProbeResponse, MobilityDomain),
	offsetof(tDot11fIEMobilityDomain, present), 0, "MobilityDomain",
	0, 5, 5, SigIeMobilityDomain, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MOBILITYDOMAIN, 0, 0, },
	{ offsetof(tDot11fProbeResponse, WPA), offsetof(tDot11fIEWPA, present), 0,
	"WPA", 0, 8, 50, SigIeWPA, {0, 80, 242, 1, 0}, 4, DOT11F_EID_WPA, 0, 0, },
	{ offsetof(tDot11fProbeResponse, HTCaps), offsetof(tDot11fIEHTCaps,
	present), 0, "HTCaps", 0, 28, 60, SigIeHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fProbeResponse, HTInfo), offsetof(tDot11fIEHTInfo,
	present), 0, "HTInfo", 0, 24, 56, SigIeHTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTINFO, 0, 0, },
	{ offsetof(tDot11fProbeResponse, sec_chan_offset_ele),
	offsetof(tDot11fIEsec_chan_offset_ele, present), 0, "sec_chan_offset_ele",
	0, 3, 3, SigIesec_chan_offset_ele, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SEC_CHAN_OFFSET_ELE, 0, 0, },
	{ offsetof(tDot11fProbeResponse, WMMInfoAp), offsetof(tDot11fIEWMMInfoAp,
	present), 0, "WMMInfoAp", 0, 9, 9, SigIeWMMInfoAp, {0, 80, 242, 2, 0},
	5, DOT11F_EID_WMMINFOAP, 0, 0, },
	{ offsetof(tDot11fProbeResponse, WMMParams), offsetof(tDot11fIEWMMParams,
	present), 0, "WMMParams", 0, 26, 26, SigIeWMMParams, {0, 80, 242, 2, 1},
	5, DOT11F_EID_WMMPARAMS, 0, 0, },
	{ offsetof(tDot11fProbeResponse, WMMCaps), offsetof(tDot11fIEWMMCaps,
	present), 0, "WMMCaps", 0, 9, 9, SigIeWMMCaps, {0, 80, 242, 2, 5},
	5, DOT11F_EID_WMMCAPS, 0, 0, },
	{ offsetof(tDot11fProbeResponse, WAPI), offsetof(tDot11fIEWAPI, present),
	0, "WAPI", 0, 14, 112, SigIeWAPI, {0, 0, 0, 0, 0},
	0, DOT11F_EID_WAPI, 0, 0, },
	{ offsetof(tDot11fProbeResponse, ESERadMgmtCap),
	offsetof(tDot11fIEESERadMgmtCap, present), 0, "ESERadMgmtCap",
	0, 8, 8, SigIeESERadMgmtCap, {0, 64, 150, 1, 0},
	4, DOT11F_EID_ESERADMGMTCAP, 0, 0, },
	{ offsetof(tDot11fProbeResponse, ESETrafStrmMet),
	offsetof(tDot11fIEESETrafStrmMet, present), 0, "ESETrafStrmMet",
	0, 10, 10, SigIeESETrafStrmMet, {0, 64, 150, 7, 0},
	4, DOT11F_EID_ESETRAFSTRMMET, 0, 0, },
	{ offsetof(tDot11fProbeResponse, ESETxmitPower),
	offsetof(tDot11fIEESETxmitPower, present), 0, "ESETxmitPower",
	0, 8, 8, SigIeESETxmitPower, {0, 64, 150, 0, 0},
	4, DOT11F_EID_ESETXMITPOWER, 0, 0, },
	{ offsetof(tDot11fProbeResponse, WscProbeRes),
	offsetof(tDot11fIEWscProbeRes, present), 0, "WscProbeRes",
	0, 6, 319, SigIeWscProbeRes, {0, 80, 242, 4, 0},
	4, DOT11F_EID_WSCPROBERES, 0, 0, },
	{ offsetof(tDot11fProbeResponse, P2PProbeRes),
	offsetof(tDot11fIEP2PProbeRes, present), 0, "P2PProbeRes",
	0, 6, 1141, SigIeP2PProbeRes, {80, 111, 154, 9, 0},
	4, DOT11F_EID_P2PPROBERES, 0, 0, },
	{ offsetof(tDot11fProbeResponse, VHTCaps), offsetof(tDot11fIEVHTCaps,
	present), 0, "VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fProbeResponse, VHTOperation),
	offsetof(tDot11fIEVHTOperation, present), 0, "VHTOperation",
	0, 7, 7, SigIeVHTOperation, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTOPERATION, 0, 0, },
	{ offsetof(tDot11fProbeResponse, transmit_power_env),
	offsetof(tDot11fIEtransmit_power_env, present),
	offsetof(tDot11fProbeResponse, num_transmit_power_env),
	"transmit_power_env", 8, 4, 11, SigIetransmit_power_env, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TRANSMIT_POWER_ENV, 0, 0, },
	{ offsetof(tDot11fProbeResponse, ChannelSwitchWrapper),
	offsetof(tDot11fIEChannelSwitchWrapper, present), 0,
	"ChannelSwitchWrapper", 0, 2, 18, SigIeChannelSwitchWrapper,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_CHANNELSWITCHWRAPPER, 0, 0, },
	{ offsetof(tDot11fProbeResponse, VHTExtBssLoad),
	offsetof(tDot11fIEVHTExtBssLoad, present), 0, "VHTExtBssLoad",
	0, 7, 7, SigIeVHTExtBssLoad, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTEXTBSSLOAD, 0, 0, },
	{ offsetof(tDot11fProbeResponse, ExtCap), offsetof(tDot11fIEExtCap,
	present), 0, "ExtCap", 0, 3, 17, SigIeExtCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fProbeResponse, OBSSScanParameters),
	offsetof(tDot11fIEOBSSScanParameters, present), 0, "OBSSScanParameters",
	0, 16, 16, SigIeOBSSScanParameters, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OBSSSCANPARAMETERS, 0, 0, },
	{ offsetof(tDot11fProbeResponse, fils_indication),
	offsetof(tDot11fIEfils_indication, present), 0, "fils_indication",
	0, 6, 259, SigIefils_indication, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FILS_INDICATION, 0, 0, },
	{ offsetof(tDot11fProbeResponse, Vendor1IE), offsetof(tDot11fIEVendor1IE,
	present), 0, "Vendor1IE", 0, 5, 5, SigIeVendor1IE, {0, 16, 24, 0, 0},
	3, DOT11F_EID_VENDOR1IE, 0, 0, },
	{ offsetof(tDot11fProbeResponse, vendor_vht_ie),
	offsetof(tDot11fIEvendor_vht_ie, present), 0, "vendor_vht_ie",
	0, 7, 28, SigIevendor_vht_ie, {0, 144, 76, 4, 0},
	4, DOT11F_EID_VENDOR_VHT_IE, 0, 0, },
	{ offsetof(tDot11fProbeResponse, Vendor3IE), offsetof(tDot11fIEVendor3IE,
	present), 0, "Vendor3IE", 0, 5, 5, SigIeVendor3IE, {0, 22, 50, 0, 0},
	3, DOT11F_EID_VENDOR3IE, 0, 0, },
	{ offsetof(tDot11fProbeResponse, hs20vendor_ie),
	offsetof(tDot11fIEhs20vendor_ie, present), 0, "hs20vendor_ie",
	0, 7, 9, SigIehs20vendor_ie, {80, 111, 154, 16, 0},
	4, DOT11F_EID_HS20VENDOR_IE, 0, 0, },
	{ offsetof(tDot11fProbeResponse, QComVendorIE),
	offsetof(tDot11fIEQComVendorIE, present), 0, "QComVendorIE",
	0, 7, 7, SigIeQComVendorIE, {0, 160, 198, 0, 0},
	3, DOT11F_EID_QCOMVENDORIE, 0, 0, },
	{ offsetof(tDot11fProbeResponse, ESEVersion),
	offsetof(tDot11fIEESEVersion, present), 0, "ESEVersion",
	0, 7, 7, SigIeESEVersion, {0, 64, 150, 3, 0},
	4, DOT11F_EID_ESEVERSION, 0, 0, },
	{ offsetof(tDot11fProbeResponse, MBO_IE), offsetof(tDot11fIEMBO_IE,
	present), 0, "MBO_IE", 0, 6, 295, SigIeMBO_IE, {80, 111, 154, 22, 0},
	4, DOT11F_EID_MBO_IE, 0, 0, },
	{ offsetof(tDot11fProbeResponse, qcn_ie), offsetof(tDot11fIEqcn_ie,
	present), 0, "qcn_ie", 0, 6, 37, SigIeqcn_ie, {140, 253, 240, 1, 0},
	4, DOT11F_EID_QCN_IE, 0, 0, },
	{ offsetof(tDot11fProbeResponse, he_cap), offsetof(tDot11fIEhe_cap,
	present), 0, "he_cap", 0, 23, 56, SigIehe_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_CAP, 35, 0, },
	{ offsetof(tDot11fProbeResponse, he_op), offsetof(tDot11fIEhe_op,
	present), 0, "he_op", 0, 8, 17, SigIehe_op, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_OP, 36, 0, },
	{ offsetof(tDot11fProbeResponse, he_6ghz_band_cap),
	offsetof(tDot11fIEhe_6ghz_band_cap, present), 0, "he_6ghz_band_cap",
	0, 4, 4, SigIehe_6ghz_band_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_6GHZ_BAND_CAP, 59, 0, },
	{ offsetof(tDot11fProbeResponse, bss_color_change),
	offsetof(tDot11fIEbss_color_change, present), 0, "bss_color_change",
	0, 4, 4, SigIebss_color_change, {0, 0, 0, 0, 0},
	0, DOT11F_EID_BSS_COLOR_CHANGE, 42, 0, },
	{ offsetof(tDot11fProbeResponse, mu_edca_param_set),
	offsetof(tDot11fIEmu_edca_param_set, present), 0, "mu_edca_param_set",
	0, 15, 15, SigIemu_edca_param_set, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MU_EDCA_PARAM_SET, 38, 0, },
	{ offsetof(tDot11fProbeResponse, esp_information),
	offsetof(tDot11fIEesp_information, present), 0, "esp_information",
	0, 2, 98, SigIeesp_information, {0, 0, 0, 0, 0},
	0, DOT11F_EID_ESP_INFORMATION, 11, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_probe_response(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fProbeResponse *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_ProbeResponse, IES_ProbeResponse,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_probe_response. */

static const tFFDefn FFS_QosMapConfigure[] = {
	{ "Category", offsetof(tDot11fQosMapConfigure, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fQosMapConfigure, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_QosMapConfigure[] = {
	{ offsetof(tDot11fQosMapConfigure, QosMapSet),
	offsetof(tDot11fIEQosMapSet, present), 0, "QosMapSet",
	0, 18, 60, SigIeQosMapSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QOSMAPSET, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_qos_map_configure(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fQosMapConfigure *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_QosMapConfigure, IES_QosMapConfigure,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_qos_map_configure. */

static const tFFDefn FFS_RadioMeasurementReport[] = {
	{ "Category", offsetof(tDot11fRadioMeasurementReport, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fRadioMeasurementReport, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fRadioMeasurementReport, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_RadioMeasurementReport[] = {
	{ offsetof(tDot11fRadioMeasurementReport, MeasurementReport),
	offsetof(tDot11fIEMeasurementReport, present),
	offsetof(tDot11fRadioMeasurementReport, num_MeasurementReport),
	"MeasurementReport", 1, 5, 31, SigIeMeasurementReport, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MEASUREMENTREPORT, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_radio_measurement_report(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fRadioMeasurementReport *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_RadioMeasurementReport, IES_RadioMeasurementReport,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_radio_measurement_report. */

static const tFFDefn FFS_RadioMeasurementRequest[] = {
	{ "Category", offsetof(tDot11fRadioMeasurementRequest, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fRadioMeasurementRequest, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fRadioMeasurementRequest, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ "NumOfRepetitions", offsetof(tDot11fRadioMeasurementRequest,
	NumOfRepetitions), SigFfNumOfRepetitions,
	DOT11F_FF_NUMOFREPETITIONS_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_RadioMeasurementRequest[] = {
	{ offsetof(tDot11fRadioMeasurementRequest, MeasurementRequest),
	offsetof(tDot11fIEMeasurementRequest, present),
	offsetof(tDot11fRadioMeasurementRequest, num_MeasurementRequest),
	"MeasurementRequest", 5, 6, 18, SigIeMeasurementRequest, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MEASUREMENTREQUEST, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_radio_measurement_request(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fRadioMeasurementRequest *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_RadioMeasurementRequest, IES_RadioMeasurementRequest,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_radio_measurement_request. */

static const tFFDefn FFS_ReAssocRequest[] = {
	{ "Capabilities", offsetof(tDot11fReAssocRequest, Capabilities),
	SigFfCapabilities, DOT11F_FF_CAPABILITIES_LEN, },
	{ "ListenInterval", offsetof(tDot11fReAssocRequest, ListenInterval),
	SigFfListenInterval, DOT11F_FF_LISTENINTERVAL_LEN, },
	{ "CurrentAPAddress", offsetof(tDot11fReAssocRequest, CurrentAPAddress),
	SigFfCurrentAPAddress, DOT11F_FF_CURRENTAPADDRESS_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_ReAssocRequest[] = {
	{ offsetof(tDot11fReAssocRequest, SSID), offsetof(tDot11fIESSID, present),
	0, "SSID", 0, 2, 34, SigIeSSID, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SSID, 0, 1, },
	{ offsetof(tDot11fReAssocRequest, SuppRates),
	offsetof(tDot11fIESuppRates, present), 0, "SuppRates",
	0, 2, 14, SigIeSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPRATES, 0, 1, },
	{ offsetof(tDot11fReAssocRequest, ExtSuppRates),
	offsetof(tDot11fIEExtSuppRates, present), 0, "ExtSuppRates",
	0, 3, 14, SigIeExtSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTSUPPRATES, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, PowerCaps),
	offsetof(tDot11fIEPowerCaps, present), 0, "PowerCaps",
	0, 4, 4, SigIePowerCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_POWERCAPS, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, SuppChannels),
	offsetof(tDot11fIESuppChannels, present), 0, "SuppChannels",
	0, 2, 98, SigIeSuppChannels, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPCHANNELS, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, RSNOpaque),
	offsetof(tDot11fIERSNOpaque, present), 0, "RSNOpaque",
	0, 2, 255, SigIeRSNOpaque, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RSNOPAQUE, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, QOSCapsStation),
	offsetof(tDot11fIEQOSCapsStation, present), 0, "QOSCapsStation",
	0, 3, 3, SigIeQOSCapsStation, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QOSCAPSSTATION, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, RRMEnabledCap),
	offsetof(tDot11fIERRMEnabledCap, present), 0, "RRMEnabledCap",
	0, 7, 7, SigIeRRMEnabledCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RRMENABLEDCAP, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, MobilityDomain),
	offsetof(tDot11fIEMobilityDomain, present), 0, "MobilityDomain",
	0, 5, 5, SigIeMobilityDomain, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MOBILITYDOMAIN, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, FTInfo), offsetof(tDot11fIEFTInfo,
	present), 0, "FTInfo", 0, 84, 222, SigIeFTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FTINFO, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, RICDataDesc),
	offsetof(tDot11fIERICDataDesc, present),
	offsetof(tDot11fReAssocRequest, num_RICDataDesc), "RICDataDesc",
	2, 2, 550, SigIeRICDataDesc, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RICDATADESC, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, SuppOperatingClasses),
	offsetof(tDot11fIESuppOperatingClasses, present), 0,
	"SuppOperatingClasses", 0, 3, 34, SigIeSuppOperatingClasses,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_SUPPOPERATINGCLASSES, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, WPAOpaque),
	offsetof(tDot11fIEWPAOpaque, present), 0, "WPAOpaque",
	0, 8, 255, SigIeWPAOpaque, {0, 80, 242, 1, 0},
	4, DOT11F_EID_WPAOPAQUE, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, HTCaps), offsetof(tDot11fIEHTCaps,
	present), 0, "HTCaps", 0, 28, 60, SigIeHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, WMMCaps), offsetof(tDot11fIEWMMCaps,
	present), 0, "WMMCaps", 0, 9, 9, SigIeWMMCaps, {0, 80, 242, 2, 5},
	5, DOT11F_EID_WMMCAPS, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, WMMInfoStation),
	offsetof(tDot11fIEWMMInfoStation, present), 0, "WMMInfoStation",
	0, 9, 9, SigIeWMMInfoStation, {0, 80, 242, 2, 0},
	5, DOT11F_EID_WMMINFOSTATION, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, WscIEOpaque),
	offsetof(tDot11fIEWscIEOpaque, present), 0, "WscIEOpaque",
	0, 8, 255, SigIeWscIEOpaque, {0, 80, 242, 4, 0},
	4, DOT11F_EID_WSCIEOPAQUE, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, WAPIOpaque),
	offsetof(tDot11fIEWAPIOpaque, present), 0, "WAPIOpaque",
	0, 8, 255, SigIeWAPIOpaque, {0, 0, 0, 0, 0},
	0, DOT11F_EID_WAPIOPAQUE, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, WAPI), offsetof(tDot11fIEWAPI, present),
	0, "WAPI", 0, 14, 112, SigIeWAPI, {0, 0, 0, 0, 0},
	0, DOT11F_EID_WAPI, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, ESERadMgmtCap),
	offsetof(tDot11fIEESERadMgmtCap, present), 0, "ESERadMgmtCap",
	0, 8, 8, SigIeESERadMgmtCap, {0, 64, 150, 1, 0},
	4, DOT11F_EID_ESERADMGMTCAP, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, ESEVersion),
	offsetof(tDot11fIEESEVersion, present), 0, "ESEVersion",
	0, 7, 7, SigIeESEVersion, {0, 64, 150, 3, 0},
	4, DOT11F_EID_ESEVERSION, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, ESECckmOpaque),
	offsetof(tDot11fIEESECckmOpaque, present), 0, "ESECckmOpaque",
	0, 12, 26, SigIeESECckmOpaque, {0, 64, 150, 0, 0},
	4, DOT11F_EID_ESECCKMOPAQUE, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, WMMTSPEC), offsetof(tDot11fIEWMMTSPEC,
	present), offsetof(tDot11fReAssocRequest, num_WMMTSPEC), "WMMTSPEC",
	4, 63, 63, SigIeWMMTSPEC, {0, 80, 242, 2, 2},
	5, DOT11F_EID_WMMTSPEC, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, ESETrafStrmRateSet),
	offsetof(tDot11fIEESETrafStrmRateSet, present), 0, "ESETrafStrmRateSet",
	0, 7, 15, SigIeESETrafStrmRateSet, {0, 64, 150, 8, 0},
	4, DOT11F_EID_ESETRAFSTRMRATESET, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, P2PIEOpaque),
	offsetof(tDot11fIEP2PIEOpaque, present), 0, "P2PIEOpaque",
	0, 8, 255, SigIeP2PIEOpaque, {80, 111, 154, 9, 0},
	4, DOT11F_EID_P2PIEOPAQUE, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, WFDIEOpaque),
	offsetof(tDot11fIEWFDIEOpaque, present), 0, "WFDIEOpaque",
	0, 8, 255, SigIeWFDIEOpaque, {80, 111, 154, 10, 0},
	4, DOT11F_EID_WFDIEOPAQUE, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, VHTCaps), offsetof(tDot11fIEVHTCaps,
	present), 0, "VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, ExtCap), offsetof(tDot11fIEExtCap,
	present), 0, "ExtCap", 0, 3, 17, SigIeExtCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, OperatingMode),
	offsetof(tDot11fIEOperatingMode, present), 0, "OperatingMode",
	0, 3, 3, SigIeOperatingMode, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OPERATINGMODE, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, QosMapSet),
	offsetof(tDot11fIEQosMapSet, present), 0, "QosMapSet",
	0, 18, 60, SigIeQosMapSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QOSMAPSET, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, vendor_vht_ie),
	offsetof(tDot11fIEvendor_vht_ie, present), 0, "vendor_vht_ie",
	0, 7, 28, SigIevendor_vht_ie, {0, 144, 76, 4, 0},
	4, DOT11F_EID_VENDOR_VHT_IE, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, hs20vendor_ie),
	offsetof(tDot11fIEhs20vendor_ie, present), 0, "hs20vendor_ie",
	0, 7, 9, SigIehs20vendor_ie, {80, 111, 154, 16, 0},
	4, DOT11F_EID_HS20VENDOR_IE, 0, 0, },
	{ offsetof(tDot11fReAssocRequest, he_cap), offsetof(tDot11fIEhe_cap,
	present), 0, "he_cap", 0, 23, 56, SigIehe_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_CAP, 35, 0, },
	{ offsetof(tDot11fReAssocRequest, he_6ghz_band_cap),
	offsetof(tDot11fIEhe_6ghz_band_cap, present), 0, "he_6ghz_band_cap",
	0, 4, 4, SigIehe_6ghz_band_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_6GHZ_BAND_CAP, 59, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_re_assoc_request(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fReAssocRequest *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_ReAssocRequest, IES_ReAssocRequest,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_re_assoc_request. */

static const tFFDefn FFS_ReAssocResponse[] = {
	{ "Capabilities", offsetof(tDot11fReAssocResponse, Capabilities),
	SigFfCapabilities, DOT11F_FF_CAPABILITIES_LEN, },
	{ "Status", offsetof(tDot11fReAssocResponse, Status), SigFfStatus,
	DOT11F_FF_STATUS_LEN, },
	{ "AID", offsetof(tDot11fReAssocResponse, AID), SigFfAID,
	DOT11F_FF_AID_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_ReAssocResponse[] = {
	{ offsetof(tDot11fReAssocResponse, SuppRates),
	offsetof(tDot11fIESuppRates, present), 0, "SuppRates",
	0, 2, 14, SigIeSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPRATES, 0, 1, },
	{ offsetof(tDot11fReAssocResponse, ExtSuppRates),
	offsetof(tDot11fIEExtSuppRates, present), 0, "ExtSuppRates",
	0, 3, 14, SigIeExtSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTSUPPRATES, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, EDCAParamSet),
	offsetof(tDot11fIEEDCAParamSet, present), 0, "EDCAParamSet",
	0, 20, 20, SigIeEDCAParamSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EDCAPARAMSET, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, RCPIIE), offsetof(tDot11fIERCPIIE,
	present), 0, "RCPIIE", 0, 3, 3, SigIeRCPIIE, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RCPIIE, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, RSNIIE), offsetof(tDot11fIERSNIIE,
	present), 0, "RSNIIE", 0, 3, 3, SigIeRSNIIE, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RSNIIE, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, RRMEnabledCap),
	offsetof(tDot11fIERRMEnabledCap, present), 0, "RRMEnabledCap",
	0, 7, 7, SigIeRRMEnabledCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RRMENABLEDCAP, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, RSNOpaque),
	offsetof(tDot11fIERSNOpaque, present), 0, "RSNOpaque",
	0, 2, 255, SigIeRSNOpaque, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RSNOPAQUE, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, MobilityDomain),
	offsetof(tDot11fIEMobilityDomain, present), 0, "MobilityDomain",
	0, 5, 5, SigIeMobilityDomain, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MOBILITYDOMAIN, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, FTInfo), offsetof(tDot11fIEFTInfo,
	present), 0, "FTInfo", 0, 84, 222, SigIeFTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FTINFO, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, RICDataDesc),
	offsetof(tDot11fIERICDataDesc, present),
	offsetof(tDot11fReAssocResponse, num_RICDataDesc), "RICDataDesc",
	2, 2, 550, SigIeRICDataDesc, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RICDATADESC, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, WPA), offsetof(tDot11fIEWPA, present),
	0, "WPA", 0, 8, 50, SigIeWPA, {0, 80, 242, 1, 0},
	4, DOT11F_EID_WPA, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, TimeoutInterval),
	offsetof(tDot11fIETimeoutInterval, present), 0, "TimeoutInterval",
	0, 7, 7, SigIeTimeoutInterval, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TIMEOUTINTERVAL, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, HTCaps), offsetof(tDot11fIEHTCaps,
	present), 0, "HTCaps", 0, 28, 60, SigIeHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, HTInfo), offsetof(tDot11fIEHTInfo,
	present), 0, "HTInfo", 0, 24, 56, SigIeHTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTINFO, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, WMMParams),
	offsetof(tDot11fIEWMMParams, present), 0, "WMMParams",
	0, 26, 26, SigIeWMMParams, {0, 80, 242, 2, 1},
	5, DOT11F_EID_WMMPARAMS, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, ESERadMgmtCap),
	offsetof(tDot11fIEESERadMgmtCap, present), 0, "ESERadMgmtCap",
	0, 8, 8, SigIeESERadMgmtCap, {0, 64, 150, 1, 0},
	4, DOT11F_EID_ESERADMGMTCAP, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, ESETrafStrmMet),
	offsetof(tDot11fIEESETrafStrmMet, present), 0, "ESETrafStrmMet",
	0, 10, 10, SigIeESETrafStrmMet, {0, 64, 150, 7, 0},
	4, DOT11F_EID_ESETRAFSTRMMET, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, ESETxmitPower),
	offsetof(tDot11fIEESETxmitPower, present), 0, "ESETxmitPower",
	0, 8, 8, SigIeESETxmitPower, {0, 64, 150, 0, 0},
	4, DOT11F_EID_ESETXMITPOWER, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, WMMTSPEC), offsetof(tDot11fIEWMMTSPEC,
	present), offsetof(tDot11fReAssocResponse, num_WMMTSPEC), "WMMTSPEC",
	4, 63, 63, SigIeWMMTSPEC, {0, 80, 242, 2, 2},
	5, DOT11F_EID_WMMTSPEC, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, ESETrafStrmRateSet),
	offsetof(tDot11fIEESETrafStrmRateSet, present), 0, "ESETrafStrmRateSet",
	0, 7, 15, SigIeESETrafStrmRateSet, {0, 64, 150, 8, 0},
	4, DOT11F_EID_ESETRAFSTRMRATESET, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, WscReassocRes),
	offsetof(tDot11fIEWscReassocRes, present), 0, "WscReassocRes",
	0, 6, 37, SigIeWscReassocRes, {0, 80, 242, 4, 0},
	4, DOT11F_EID_WSCREASSOCRES, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, P2PAssocRes),
	offsetof(tDot11fIEP2PAssocRes, present), 0, "P2PAssocRes",
	0, 6, 17, SigIeP2PAssocRes, {80, 111, 154, 9, 0},
	4, DOT11F_EID_P2PASSOCRES, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, VHTCaps), offsetof(tDot11fIEVHTCaps,
	present), 0, "VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, VHTOperation),
	offsetof(tDot11fIEVHTOperation, present), 0, "VHTOperation",
	0, 7, 7, SigIeVHTOperation, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTOPERATION, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, ExtCap), offsetof(tDot11fIEExtCap,
	present), 0, "ExtCap", 0, 3, 17, SigIeExtCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, OBSSScanParameters),
	offsetof(tDot11fIEOBSSScanParameters, present), 0, "OBSSScanParameters",
	0, 16, 16, SigIeOBSSScanParameters, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OBSSSCANPARAMETERS, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, QosMapSet),
	offsetof(tDot11fIEQosMapSet, present), 0, "QosMapSet",
	0, 18, 60, SigIeQosMapSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QOSMAPSET, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, vendor_vht_ie),
	offsetof(tDot11fIEvendor_vht_ie, present), 0, "vendor_vht_ie",
	0, 7, 28, SigIevendor_vht_ie, {0, 144, 76, 4, 0},
	4, DOT11F_EID_VENDOR_VHT_IE, 0, 0, },
	{ offsetof(tDot11fReAssocResponse, he_cap), offsetof(tDot11fIEhe_cap,
	present), 0, "he_cap", 0, 23, 56, SigIehe_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_CAP, 35, 0, },
	{ offsetof(tDot11fReAssocResponse, he_op), offsetof(tDot11fIEhe_op,
	present), 0, "he_op", 0, 8, 17, SigIehe_op, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_OP, 36, 0, },
	{ offsetof(tDot11fReAssocResponse, he_6ghz_band_cap),
	offsetof(tDot11fIEhe_6ghz_band_cap, present), 0, "he_6ghz_band_cap",
	0, 4, 4, SigIehe_6ghz_band_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_6GHZ_BAND_CAP, 59, 0, },
	{ offsetof(tDot11fReAssocResponse, bss_color_change),
	offsetof(tDot11fIEbss_color_change, present), 0, "bss_color_change",
	0, 4, 4, SigIebss_color_change, {0, 0, 0, 0, 0},
	0, DOT11F_EID_BSS_COLOR_CHANGE, 42, 0, },
	{ offsetof(tDot11fReAssocResponse, mu_edca_param_set),
	offsetof(tDot11fIEmu_edca_param_set, present), 0, "mu_edca_param_set",
	0, 15, 15, SigIemu_edca_param_set, {0, 0, 0, 0, 0},
	0, DOT11F_EID_MU_EDCA_PARAM_SET, 38, 0, },
	{ offsetof(tDot11fReAssocResponse, MBO_IE), offsetof(tDot11fIEMBO_IE,
	present), 0, "MBO_IE", 0, 6, 295, SigIeMBO_IE, {80, 111, 154, 22, 0},
	4, DOT11F_EID_MBO_IE, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_re_assoc_response(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fReAssocResponse *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_ReAssocResponse, IES_ReAssocResponse,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_re_assoc_response. */

static const tFFDefn FFS_SMPowerSave[] = {
	{ "Category", offsetof(tDot11fSMPowerSave, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fSMPowerSave, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "SMPowerModeSet", offsetof(tDot11fSMPowerSave, SMPowerModeSet),
	SigFfSMPowerModeSet, DOT11F_FF_SMPOWERMODESET_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_SMPowerSave[] = {
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_sm_power_save(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fSMPowerSave *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_SMPowerSave, IES_SMPowerSave,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_sm_power_save. */

static const tFFDefn FFS_SaQueryReq[] = {
	{ "Category", offsetof(tDot11fSaQueryReq, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fSaQueryReq, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "TransactionId", offsetof(tDot11fSaQueryReq, TransactionId),
	SigFfTransactionId, DOT11F_FF_TRANSACTIONID_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_SaQueryReq[] = {
	{ offsetof(tDot11fSaQueryReq, oci), offsetof(tDot11fIEoci, present), 0,
	"oci", 0, 5, 5, SigIeoci, {0, 0, 0, 0, 0}, 0, DOT11F_EID_OCI, 54, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_sa_query_req(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fSaQueryReq *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_SaQueryReq, IES_SaQueryReq,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_sa_query_req. */

static const tFFDefn FFS_SaQueryRsp[] = {
	{ "Category", offsetof(tDot11fSaQueryRsp, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fSaQueryRsp, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "TransactionId", offsetof(tDot11fSaQueryRsp, TransactionId),
	SigFfTransactionId, DOT11F_FF_TRANSACTIONID_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_SaQueryRsp[] = {
	{ offsetof(tDot11fSaQueryRsp, oci), offsetof(tDot11fIEoci, present), 0,
	"oci", 0, 5, 5, SigIeoci, {0, 0, 0, 0, 0}, 0, DOT11F_EID_OCI, 54, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_sa_query_rsp(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fSaQueryRsp *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_SaQueryRsp, IES_SaQueryRsp,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_sa_query_rsp. */

static const tFFDefn FFS_TDLSDisReq[] = {
	{ "Category", offsetof(tDot11fTDLSDisReq, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fTDLSDisReq, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fTDLSDisReq, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_TDLSDisReq[] = {
	{ offsetof(tDot11fTDLSDisReq, LinkIdentifier),
	offsetof(tDot11fIELinkIdentifier, present), 0, "LinkIdentifier",
	0, 20, 20, SigIeLinkIdentifier, {0, 0, 0, 0, 0},
	0, DOT11F_EID_LINKIDENTIFIER, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_tdls_dis_req(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fTDLSDisReq *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_TDLSDisReq, IES_TDLSDisReq,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_tdls_dis_req. */

static const tFFDefn FFS_TDLSDisRsp[] = {
	{ "Category", offsetof(tDot11fTDLSDisRsp, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fTDLSDisRsp, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fTDLSDisRsp, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ "Capabilities", offsetof(tDot11fTDLSDisRsp, Capabilities),
	SigFfCapabilities, DOT11F_FF_CAPABILITIES_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_TDLSDisRsp[] = {
	{ offsetof(tDot11fTDLSDisRsp, SuppRates), offsetof(tDot11fIESuppRates,
	present), 0, "SuppRates", 0, 2, 14, SigIeSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPRATES, 0, 1, },
	{ offsetof(tDot11fTDLSDisRsp, ExtSuppRates),
	offsetof(tDot11fIEExtSuppRates, present), 0, "ExtSuppRates",
	0, 3, 14, SigIeExtSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTSUPPRATES, 0, 0, },
	{ offsetof(tDot11fTDLSDisRsp, SuppChannels),
	offsetof(tDot11fIESuppChannels, present), 0, "SuppChannels",
	0, 2, 98, SigIeSuppChannels, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPCHANNELS, 0, 0, },
	{ offsetof(tDot11fTDLSDisRsp, SuppOperatingClasses),
	offsetof(tDot11fIESuppOperatingClasses, present), 0,
	"SuppOperatingClasses", 0, 3, 34, SigIeSuppOperatingClasses,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_SUPPOPERATINGCLASSES, 0, 0, },
	{ offsetof(tDot11fTDLSDisRsp, RSN), offsetof(tDot11fIERSN, present), 0,
	"RSN", 0, 4, 132, SigIeRSN, {0, 0, 0, 0, 0}, 0, DOT11F_EID_RSN, 0, 0, },
	{ offsetof(tDot11fTDLSDisRsp, ExtCap), offsetof(tDot11fIEExtCap, present),
	0, "ExtCap", 0, 3, 17, SigIeExtCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fTDLSDisRsp, FTInfo), offsetof(tDot11fIEFTInfo, present),
	0, "FTInfo", 0, 84, 222, SigIeFTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FTINFO, 0, 0, },
	{ offsetof(tDot11fTDLSDisRsp, TimeoutInterval),
	offsetof(tDot11fIETimeoutInterval, present), 0, "TimeoutInterval",
	0, 7, 7, SigIeTimeoutInterval, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TIMEOUTINTERVAL, 0, 0, },
	{ offsetof(tDot11fTDLSDisRsp, RICData), offsetof(tDot11fIERICData,
	present), 0, "RICData", 0, 6, 6, SigIeRICData, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RICDATA, 0, 0, },
	{ offsetof(tDot11fTDLSDisRsp, HTCaps), offsetof(tDot11fIEHTCaps, present),
	0, "HTCaps", 0, 28, 60, SigIeHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fTDLSDisRsp, ht2040_bss_coexistence),
	offsetof(tDot11fIEht2040_bss_coexistence, present), 0,
	"ht2040_bss_coexistence", 0, 3, 3, SigIeht2040_bss_coexistence,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_HT2040_BSS_COEXISTENCE, 0, 0, },
	{ offsetof(tDot11fTDLSDisRsp, LinkIdentifier),
	offsetof(tDot11fIELinkIdentifier, present), 0, "LinkIdentifier",
	0, 20, 20, SigIeLinkIdentifier, {0, 0, 0, 0, 0},
	0, DOT11F_EID_LINKIDENTIFIER, 0, 1, },
	{ offsetof(tDot11fTDLSDisRsp, VHTCaps), offsetof(tDot11fIEVHTCaps,
	present), 0, "VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fTDLSDisRsp, he_cap), offsetof(tDot11fIEhe_cap, present),
	0, "he_cap", 0, 23, 56, SigIehe_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_CAP, 35, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_tdls_dis_rsp(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fTDLSDisRsp *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_TDLSDisRsp, IES_TDLSDisRsp,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_tdls_dis_rsp. */

static const tFFDefn FFS_TDLSPeerTrafficInd[] = {
	{ "Category", offsetof(tDot11fTDLSPeerTrafficInd, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fTDLSPeerTrafficInd, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fTDLSPeerTrafficInd, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_TDLSPeerTrafficInd[] = {
	{ offsetof(tDot11fTDLSPeerTrafficInd, LinkIdentifier),
	offsetof(tDot11fIELinkIdentifier, present), 0, "LinkIdentifier",
	0, 20, 20, SigIeLinkIdentifier, {0, 0, 0, 0, 0},
	0, DOT11F_EID_LINKIDENTIFIER, 0, 1, },
	{ offsetof(tDot11fTDLSPeerTrafficInd, PTIControl),
	offsetof(tDot11fIEPTIControl, present), 0, "PTIControl",
	0, 5, 5, SigIePTIControl, {0, 0, 0, 0, 0},
	0, DOT11F_EID_PTICONTROL, 0, 0, },
	{ offsetof(tDot11fTDLSPeerTrafficInd, PUBufferStatus),
	offsetof(tDot11fIEPUBufferStatus, present), 0, "PUBufferStatus",
	0, 3, 3, SigIePUBufferStatus, {0, 0, 0, 0, 0},
	0, DOT11F_EID_PUBUFFERSTATUS, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_tdls_peer_traffic_ind(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fTDLSPeerTrafficInd *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_TDLSPeerTrafficInd, IES_TDLSPeerTrafficInd,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_tdls_peer_traffic_ind. */

static const tFFDefn FFS_TDLSPeerTrafficRsp[] = {
	{ "Category", offsetof(tDot11fTDLSPeerTrafficRsp, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fTDLSPeerTrafficRsp, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fTDLSPeerTrafficRsp, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_TDLSPeerTrafficRsp[] = {
	{ offsetof(tDot11fTDLSPeerTrafficRsp, LinkIdentifier),
	offsetof(tDot11fIELinkIdentifier, present), 0, "LinkIdentifier",
	0, 20, 20, SigIeLinkIdentifier, {0, 0, 0, 0, 0},
	0, DOT11F_EID_LINKIDENTIFIER, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_tdls_peer_traffic_rsp(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fTDLSPeerTrafficRsp *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_TDLSPeerTrafficRsp, IES_TDLSPeerTrafficRsp,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_tdls_peer_traffic_rsp. */

static const tFFDefn FFS_TDLSSetupCnf[] = {
	{ "Category", offsetof(tDot11fTDLSSetupCnf, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fTDLSSetupCnf, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "Status", offsetof(tDot11fTDLSSetupCnf, Status), SigFfStatus,
	DOT11F_FF_STATUS_LEN, },
	{ "DialogToken", offsetof(tDot11fTDLSSetupCnf, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_TDLSSetupCnf[] = {
	{ offsetof(tDot11fTDLSSetupCnf, RSN), offsetof(tDot11fIERSN, present), 0,
	"RSN", 0, 4, 132, SigIeRSN, {0, 0, 0, 0, 0}, 0, DOT11F_EID_RSN, 0, 0, },
	{ offsetof(tDot11fTDLSSetupCnf, EDCAParamSet),
	offsetof(tDot11fIEEDCAParamSet, present), 0, "EDCAParamSet",
	0, 20, 20, SigIeEDCAParamSet, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EDCAPARAMSET, 0, 0, },
	{ offsetof(tDot11fTDLSSetupCnf, FTInfo), offsetof(tDot11fIEFTInfo,
	present), 0, "FTInfo", 0, 84, 222, SigIeFTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FTINFO, 0, 0, },
	{ offsetof(tDot11fTDLSSetupCnf, TimeoutInterval),
	offsetof(tDot11fIETimeoutInterval, present), 0, "TimeoutInterval",
	0, 7, 7, SigIeTimeoutInterval, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TIMEOUTINTERVAL, 0, 0, },
	{ offsetof(tDot11fTDLSSetupCnf, HTInfo), offsetof(tDot11fIEHTInfo,
	present), 0, "HTInfo", 0, 24, 56, SigIeHTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTINFO, 0, 0, },
	{ offsetof(tDot11fTDLSSetupCnf, LinkIdentifier),
	offsetof(tDot11fIELinkIdentifier, present), 0, "LinkIdentifier",
	0, 20, 20, SigIeLinkIdentifier, {0, 0, 0, 0, 0},
	0, DOT11F_EID_LINKIDENTIFIER, 0, 0, },
	{ offsetof(tDot11fTDLSSetupCnf, WMMParams), offsetof(tDot11fIEWMMParams,
	present), 0, "WMMParams", 0, 26, 26, SigIeWMMParams, {0, 80, 242, 2, 1},
	5, DOT11F_EID_WMMPARAMS, 0, 0, },
	{ offsetof(tDot11fTDLSSetupCnf, VHTOperation),
	offsetof(tDot11fIEVHTOperation, present), 0, "VHTOperation",
	0, 7, 7, SigIeVHTOperation, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTOPERATION, 0, 0, },
	{ offsetof(tDot11fTDLSSetupCnf, OperatingMode),
	offsetof(tDot11fIEOperatingMode, present), 0, "OperatingMode",
	0, 3, 3, SigIeOperatingMode, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OPERATINGMODE, 0, 0, },
	{ offsetof(tDot11fTDLSSetupCnf, he_op), offsetof(tDot11fIEhe_op, present),
	0, "he_op", 0, 8, 17, SigIehe_op, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_OP, 36, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_tdls_setup_cnf(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fTDLSSetupCnf *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_TDLSSetupCnf, IES_TDLSSetupCnf,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_tdls_setup_cnf. */

static const tFFDefn FFS_TDLSSetupReq[] = {
	{ "Category", offsetof(tDot11fTDLSSetupReq, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fTDLSSetupReq, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fTDLSSetupReq, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ "Capabilities", offsetof(tDot11fTDLSSetupReq, Capabilities),
	SigFfCapabilities, DOT11F_FF_CAPABILITIES_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_TDLSSetupReq[] = {
	{ offsetof(tDot11fTDLSSetupReq, SuppRates), offsetof(tDot11fIESuppRates,
	present), 0, "SuppRates", 0, 2, 14, SigIeSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPRATES, 0, 1, },
	{ offsetof(tDot11fTDLSSetupReq, Country), offsetof(tDot11fIECountry,
	present), 0, "Country", 0, 8, 248, SigIeCountry, {0, 0, 0, 0, 0},
	0, DOT11F_EID_COUNTRY, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, ExtSuppRates),
	offsetof(tDot11fIEExtSuppRates, present), 0, "ExtSuppRates",
	0, 3, 14, SigIeExtSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTSUPPRATES, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, SuppChannels),
	offsetof(tDot11fIESuppChannels, present), 0, "SuppChannels",
	0, 2, 98, SigIeSuppChannels, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPCHANNELS, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, RSN), offsetof(tDot11fIERSN, present), 0,
	"RSN", 0, 4, 132, SigIeRSN, {0, 0, 0, 0, 0}, 0, DOT11F_EID_RSN, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, ExtCap), offsetof(tDot11fIEExtCap,
	present), 0, "ExtCap", 0, 3, 17, SigIeExtCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, SuppOperatingClasses),
	offsetof(tDot11fIESuppOperatingClasses, present), 0,
	"SuppOperatingClasses", 0, 3, 34, SigIeSuppOperatingClasses,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_SUPPOPERATINGCLASSES, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, QOSCapsStation),
	offsetof(tDot11fIEQOSCapsStation, present), 0, "QOSCapsStation",
	0, 3, 3, SigIeQOSCapsStation, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QOSCAPSSTATION, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, FTInfo), offsetof(tDot11fIEFTInfo,
	present), 0, "FTInfo", 0, 84, 222, SigIeFTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FTINFO, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, TimeoutInterval),
	offsetof(tDot11fIETimeoutInterval, present), 0, "TimeoutInterval",
	0, 7, 7, SigIeTimeoutInterval, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TIMEOUTINTERVAL, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, RICData), offsetof(tDot11fIERICData,
	present), 0, "RICData", 0, 6, 6, SigIeRICData, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RICDATA, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, HTCaps), offsetof(tDot11fIEHTCaps,
	present), 0, "HTCaps", 0, 28, 60, SigIeHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, ht2040_bss_coexistence),
	offsetof(tDot11fIEht2040_bss_coexistence, present), 0,
	"ht2040_bss_coexistence", 0, 3, 3, SigIeht2040_bss_coexistence,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_HT2040_BSS_COEXISTENCE, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, LinkIdentifier),
	offsetof(tDot11fIELinkIdentifier, present), 0, "LinkIdentifier",
	0, 20, 20, SigIeLinkIdentifier, {0, 0, 0, 0, 0},
	0, DOT11F_EID_LINKIDENTIFIER, 0, 1, },
	{ offsetof(tDot11fTDLSSetupReq, WMMInfoStation),
	offsetof(tDot11fIEWMMInfoStation, present), 0, "WMMInfoStation",
	0, 9, 9, SigIeWMMInfoStation, {0, 80, 242, 2, 0},
	5, DOT11F_EID_WMMINFOSTATION, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, AID), offsetof(tDot11fIEAID, present), 0,
	"AID", 0, 4, 4, SigIeAID, {0, 0, 0, 0, 0}, 0, DOT11F_EID_AID, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, VHTCaps), offsetof(tDot11fIEVHTCaps,
	present), 0, "VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fTDLSSetupReq, he_cap), offsetof(tDot11fIEhe_cap,
	present), 0, "he_cap", 0, 23, 56, SigIehe_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_CAP, 35, 0, },
	{ offsetof(tDot11fTDLSSetupReq, he_6ghz_band_cap),
	offsetof(tDot11fIEhe_6ghz_band_cap, present), 0, "he_6ghz_band_cap",
	0, 4, 4, SigIehe_6ghz_band_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_6GHZ_BAND_CAP, 59, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_tdls_setup_req(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fTDLSSetupReq *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_TDLSSetupReq, IES_TDLSSetupReq,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_tdls_setup_req. */

static const tFFDefn FFS_TDLSSetupRsp[] = {
	{ "Category", offsetof(tDot11fTDLSSetupRsp, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fTDLSSetupRsp, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "Status", offsetof(tDot11fTDLSSetupRsp, Status), SigFfStatus,
	DOT11F_FF_STATUS_LEN, },
	{ "DialogToken", offsetof(tDot11fTDLSSetupRsp, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ "Capabilities", offsetof(tDot11fTDLSSetupRsp, Capabilities),
	SigFfCapabilities, DOT11F_FF_CAPABILITIES_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_TDLSSetupRsp[] = {
	{ offsetof(tDot11fTDLSSetupRsp, SuppRates), offsetof(tDot11fIESuppRates,
	present), 0, "SuppRates", 0, 2, 14, SigIeSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPRATES, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, Country), offsetof(tDot11fIECountry,
	present), 0, "Country", 0, 8, 248, SigIeCountry, {0, 0, 0, 0, 0},
	0, DOT11F_EID_COUNTRY, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, ExtSuppRates),
	offsetof(tDot11fIEExtSuppRates, present), 0, "ExtSuppRates",
	0, 3, 14, SigIeExtSuppRates, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTSUPPRATES, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, SuppChannels),
	offsetof(tDot11fIESuppChannels, present), 0, "SuppChannels",
	0, 2, 98, SigIeSuppChannels, {0, 0, 0, 0, 0},
	0, DOT11F_EID_SUPPCHANNELS, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, RSN), offsetof(tDot11fIERSN, present), 0,
	"RSN", 0, 4, 132, SigIeRSN, {0, 0, 0, 0, 0}, 0, DOT11F_EID_RSN, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, ExtCap), offsetof(tDot11fIEExtCap,
	present), 0, "ExtCap", 0, 3, 17, SigIeExtCap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, SuppOperatingClasses),
	offsetof(tDot11fIESuppOperatingClasses, present), 0,
	"SuppOperatingClasses", 0, 3, 34, SigIeSuppOperatingClasses,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_SUPPOPERATINGCLASSES, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, QOSCapsStation),
	offsetof(tDot11fIEQOSCapsStation, present), 0, "QOSCapsStation",
	0, 3, 3, SigIeQOSCapsStation, {0, 0, 0, 0, 0},
	0, DOT11F_EID_QOSCAPSSTATION, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, FTInfo), offsetof(tDot11fIEFTInfo,
	present), 0, "FTInfo", 0, 84, 222, SigIeFTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FTINFO, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, TimeoutInterval),
	offsetof(tDot11fIETimeoutInterval, present), 0, "TimeoutInterval",
	0, 7, 7, SigIeTimeoutInterval, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TIMEOUTINTERVAL, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, RICData), offsetof(tDot11fIERICData,
	present), 0, "RICData", 0, 6, 6, SigIeRICData, {0, 0, 0, 0, 0},
	0, DOT11F_EID_RICDATA, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, HTCaps), offsetof(tDot11fIEHTCaps,
	present), 0, "HTCaps", 0, 28, 60, SigIeHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, ht2040_bss_coexistence),
	offsetof(tDot11fIEht2040_bss_coexistence, present), 0,
	"ht2040_bss_coexistence", 0, 3, 3, SigIeht2040_bss_coexistence,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_HT2040_BSS_COEXISTENCE, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, LinkIdentifier),
	offsetof(tDot11fIELinkIdentifier, present), 0, "LinkIdentifier",
	0, 20, 20, SigIeLinkIdentifier, {0, 0, 0, 0, 0},
	0, DOT11F_EID_LINKIDENTIFIER, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, WMMInfoStation),
	offsetof(tDot11fIEWMMInfoStation, present), 0, "WMMInfoStation",
	0, 9, 9, SigIeWMMInfoStation, {0, 80, 242, 2, 0},
	5, DOT11F_EID_WMMINFOSTATION, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, AID), offsetof(tDot11fIEAID, present), 0,
	"AID", 0, 4, 4, SigIeAID, {0, 0, 0, 0, 0}, 0, DOT11F_EID_AID, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, VHTCaps), offsetof(tDot11fIEVHTCaps,
	present), 0, "VHTCaps", 0, 14, 14, SigIeVHTCaps, {0, 0, 0, 0, 0},
	0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, OperatingMode),
	offsetof(tDot11fIEOperatingMode, present), 0, "OperatingMode",
	0, 3, 3, SigIeOperatingMode, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OPERATINGMODE, 0, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, he_cap), offsetof(tDot11fIEhe_cap,
	present), 0, "he_cap", 0, 23, 56, SigIehe_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_CAP, 35, 0, },
	{ offsetof(tDot11fTDLSSetupRsp, he_6ghz_band_cap),
	offsetof(tDot11fIEhe_6ghz_band_cap, present), 0, "he_6ghz_band_cap",
	0, 4, 4, SigIehe_6ghz_band_cap, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HE_6GHZ_BAND_CAP, 59, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_tdls_setup_rsp(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fTDLSSetupRsp *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_TDLSSetupRsp, IES_TDLSSetupRsp,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_tdls_setup_rsp. */

static const tFFDefn FFS_TDLSTeardown[] = {
	{ "Category", offsetof(tDot11fTDLSTeardown, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fTDLSTeardown, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "Reason", offsetof(tDot11fTDLSTeardown, Reason), SigFfReason,
	DOT11F_FF_REASON_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_TDLSTeardown[] = {
	{ offsetof(tDot11fTDLSTeardown, FTInfo), offsetof(tDot11fIEFTInfo,
	present), 0, "FTInfo", 0, 84, 222, SigIeFTInfo, {0, 0, 0, 0, 0},
	0, DOT11F_EID_FTINFO, 0, 0, },
	{ offsetof(tDot11fTDLSTeardown, LinkIdentifier),
	offsetof(tDot11fIELinkIdentifier, present), 0, "LinkIdentifier",
	0, 20, 20, SigIeLinkIdentifier, {0, 0, 0, 0, 0},
	0, DOT11F_EID_LINKIDENTIFIER, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_tdls_teardown(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fTDLSTeardown *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_TDLSTeardown, IES_TDLSTeardown,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_tdls_teardown. */

static const tFFDefn FFS_TPCReport[] = {
	{ "Category", offsetof(tDot11fTPCReport, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fTPCReport, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fTPCReport, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_TPCReport[] = {
	{ offsetof(tDot11fTPCReport, TPCReport), offsetof(tDot11fIETPCReport,
	present), 0, "TPCReport", 0, 4, 4, SigIeTPCReport, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TPCREPORT, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_tpc_report(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fTPCReport *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_TPCReport, IES_TPCReport,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_tpc_report. */

static const tFFDefn FFS_TPCRequest[] = {
	{ "Category", offsetof(tDot11fTPCRequest, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fTPCRequest, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fTPCRequest, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_TPCRequest[] = {
	{ offsetof(tDot11fTPCRequest, TPCRequest), offsetof(tDot11fIETPCRequest,
	present), 0, "TPCRequest", 0, 2, 2, SigIeTPCRequest, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TPCREQUEST, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_tpc_request(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fTPCRequest *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_TPCRequest, IES_TPCRequest,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_tpc_request. */

static const tFFDefn FFS_TimingAdvertisementFrame[] = {
	{ "TimeStamp", offsetof(tDot11fTimingAdvertisementFrame, TimeStamp),
	SigFfTimeStamp, DOT11F_FF_TIMESTAMP_LEN, },
	{ "Capabilities", offsetof(tDot11fTimingAdvertisementFrame,
	Capabilities), SigFfCapabilities, DOT11F_FF_CAPABILITIES_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_TimingAdvertisementFrame[] = {
	{ offsetof(tDot11fTimingAdvertisementFrame, Country),
	offsetof(tDot11fIECountry, present), 0, "Country", 0, 8, 248, SigIeCountry,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_COUNTRY, 0, 0, },
	{ offsetof(tDot11fTimingAdvertisementFrame, PowerConstraints),
	offsetof(tDot11fIEPowerConstraints, present), 0, "PowerConstraints",
	0, 3, 3, SigIePowerConstraints, {0, 0, 0, 0, 0},
	0, DOT11F_EID_POWERCONSTRAINTS, 0, 0, },
	{ offsetof(tDot11fTimingAdvertisementFrame, TimeAdvertisement),
	offsetof(tDot11fIETimeAdvertisement, present), 0, "TimeAdvertisement",
	0, 18, 18, SigIeTimeAdvertisement, {0, 0, 0, 0, 0},
	0, DOT11F_EID_TIMEADVERTISEMENT, 0, 0, },
	{ offsetof(tDot11fTimingAdvertisementFrame, ExtCap),
	offsetof(tDot11fIEExtCap, present), 0, "ExtCap", 0, 3, 17, SigIeExtCap,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_EXTCAP, 0, 0, },
	{ offsetof(tDot11fTimingAdvertisementFrame, Vendor1IE),
	offsetof(tDot11fIEVendor1IE, present), 0, "Vendor1IE",
	0, 5, 5, SigIeVendor1IE, {0, 16, 24, 0, 0},
	3, DOT11F_EID_VENDOR1IE, 0, 0, },
	{ offsetof(tDot11fTimingAdvertisementFrame, Vendor3IE),
	offsetof(tDot11fIEVendor3IE, present), 0, "Vendor3IE",
	0, 5, 5, SigIeVendor3IE, {0, 22, 50, 0, 0},
	3, DOT11F_EID_VENDOR3IE, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_timing_advertisement_frame(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fTimingAdvertisementFrame *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_TimingAdvertisementFrame, IES_TimingAdvertisementFrame,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_timing_advertisement_frame. */

static const tFFDefn FFS_VHTGidManagementActionFrame[] = {
	{ "Category", offsetof(tDot11fVHTGidManagementActionFrame, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fVHTGidManagementActionFrame, Action),
	SigFfAction, DOT11F_FF_ACTION_LEN, },
	{ "VhtMembershipStatusArray",
	offsetof(tDot11fVHTGidManagementActionFrame, VhtMembershipStatusArray),
	SigFfVhtMembershipStatusArray,
	DOT11F_FF_VHTMEMBERSHIPSTATUSARRAY_LEN, },
	{ "VhtUserPositionArray", offsetof(tDot11fVHTGidManagementActionFrame,
	VhtUserPositionArray), SigFfVhtUserPositionArray,
	DOT11F_FF_VHTUSERPOSITIONARRAY_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_VHTGidManagementActionFrame[] = {
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_vht_gid_management_action_frame(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fVHTGidManagementActionFrame *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_VHTGidManagementActionFrame, IES_VHTGidManagementActionFrame,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_vht_gid_management_action_frame. */

static const tFFDefn FFS_WMMAddTSRequest[] = {
	{ "Category", offsetof(tDot11fWMMAddTSRequest, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fWMMAddTSRequest, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fWMMAddTSRequest, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ "StatusCode", offsetof(tDot11fWMMAddTSRequest, StatusCode),
	SigFfStatusCode, DOT11F_FF_STATUSCODE_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_WMMAddTSRequest[] = {
	{ offsetof(tDot11fWMMAddTSRequest, WMMTSPEC), offsetof(tDot11fIEWMMTSPEC,
	present), 0, "WMMTSPEC", 0, 63, 63, SigIeWMMTSPEC, {0, 80, 242, 2, 2},
	5, DOT11F_EID_WMMTSPEC, 0, 1, },
	{ offsetof(tDot11fWMMAddTSRequest, ESETrafStrmRateSet),
	offsetof(tDot11fIEESETrafStrmRateSet, present), 0, "ESETrafStrmRateSet",
	0, 7, 15, SigIeESETrafStrmRateSet, {0, 64, 150, 8, 0},
	4, DOT11F_EID_ESETRAFSTRMRATESET, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_wmm_add_ts_request(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fWMMAddTSRequest *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_WMMAddTSRequest, IES_WMMAddTSRequest,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_wmm_add_ts_request. */

static const tFFDefn FFS_WMMAddTSResponse[] = {
	{ "Category", offsetof(tDot11fWMMAddTSResponse, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fWMMAddTSResponse, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fWMMAddTSResponse, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ "StatusCode", offsetof(tDot11fWMMAddTSResponse, StatusCode),
	SigFfStatusCode, DOT11F_FF_STATUSCODE_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_WMMAddTSResponse[] = {
	{ offsetof(tDot11fWMMAddTSResponse, WMMTSPEC),
	offsetof(tDot11fIEWMMTSPEC, present), 0, "WMMTSPEC",
	0, 63, 63, SigIeWMMTSPEC, {0, 80, 242, 2, 2},
	5, DOT11F_EID_WMMTSPEC, 0, 0, },
	{ offsetof(tDot11fWMMAddTSResponse, ESETrafStrmMet),
	offsetof(tDot11fIEESETrafStrmMet, present), 0, "ESETrafStrmMet",
	0, 10, 10, SigIeESETrafStrmMet, {0, 64, 150, 7, 0},
	4, DOT11F_EID_ESETRAFSTRMMET, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_wmm_add_ts_response(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fWMMAddTSResponse *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_WMMAddTSResponse, IES_WMMAddTSResponse,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_wmm_add_ts_response. */

static const tFFDefn FFS_WMMDelTS[] = {
	{ "Category", offsetof(tDot11fWMMDelTS, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fWMMDelTS, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fWMMDelTS, DialogToken), SigFfDialogToken,
	DOT11F_FF_DIALOGTOKEN_LEN, },
	{ "StatusCode", offsetof(tDot11fWMMDelTS, StatusCode), SigFfStatusCode,
	DOT11F_FF_STATUSCODE_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_WMMDelTS[] = {
	{ offsetof(tDot11fWMMDelTS, WMMTSPEC), offsetof(tDot11fIEWMMTSPEC,
	present), 0, "WMMTSPEC", 0, 63, 63, SigIeWMMTSPEC, {0, 80, 242, 2, 2},
	5, DOT11F_EID_WMMTSPEC, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_wmm_del_ts(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fWMMDelTS *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_WMMDelTS, IES_WMMDelTS,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_wmm_del_ts. */

static const tFFDefn FFS_addba_req[] = {
	{ "Category", offsetof(tDot11faddba_req, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11faddba_req, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11faddba_req, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ "addba_param_set", offsetof(tDot11faddba_req, addba_param_set),
	SigFfaddba_param_set, DOT11F_FF_ADDBA_PARAM_SET_LEN, },
	{ "ba_timeout", offsetof(tDot11faddba_req, ba_timeout), SigFfba_timeout,
	DOT11F_FF_BA_TIMEOUT_LEN, },
	{ "ba_start_seq_ctrl", offsetof(tDot11faddba_req, ba_start_seq_ctrl),
	SigFfba_start_seq_ctrl, DOT11F_FF_BA_START_SEQ_CTRL_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_addba_req[] = {
	{ offsetof(tDot11faddba_req, addba_extn_element),
	offsetof(tDot11fIEaddba_extn_element, present), 0, "addba_extn_element",
	0, 3, 3, SigIeaddba_extn_element, {0, 0, 0, 0, 0},
	0, DOT11F_EID_ADDBA_EXTN_ELEMENT, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_addba_req(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11faddba_req *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_addba_req, IES_addba_req,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_addba_req. */

static const tFFDefn FFS_addba_rsp[] = {
	{ "Category", offsetof(tDot11faddba_rsp, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11faddba_rsp, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11faddba_rsp, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ "Status", offsetof(tDot11faddba_rsp, Status), SigFfStatus,
	DOT11F_FF_STATUS_LEN, },
	{ "addba_param_set", offsetof(tDot11faddba_rsp, addba_param_set),
	SigFfaddba_param_set, DOT11F_FF_ADDBA_PARAM_SET_LEN, },
	{ "ba_timeout", offsetof(tDot11faddba_rsp, ba_timeout), SigFfba_timeout,
	DOT11F_FF_BA_TIMEOUT_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_addba_rsp[] = {
	{ offsetof(tDot11faddba_rsp, addba_extn_element),
	offsetof(tDot11fIEaddba_extn_element, present), 0, "addba_extn_element",
	0, 3, 3, SigIeaddba_extn_element, {0, 0, 0, 0, 0},
	0, DOT11F_EID_ADDBA_EXTN_ELEMENT, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_addba_rsp(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11faddba_rsp *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_addba_rsp, IES_addba_rsp,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_addba_rsp. */

static const tFFDefn FFS_delba_req[] = {
	{ "Category", offsetof(tDot11fdelba_req, Category), SigFfCategory,
	DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fdelba_req, Action), SigFfAction,
	DOT11F_FF_ACTION_LEN, },
	{ "delba_param_set", offsetof(tDot11fdelba_req, delba_param_set),
	SigFfdelba_param_set, DOT11F_FF_DELBA_PARAM_SET_LEN, },
	{ "Reason", offsetof(tDot11fdelba_req, Reason), SigFfReason,
	DOT11F_FF_REASON_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_delba_req[] = {
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_delba_req(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fdelba_req *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_delba_req, IES_delba_req,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_delba_req. */

static const tFFDefn FFS_ext_channel_switch_action_frame[] = {
	{ "Category", offsetof(tDot11fext_channel_switch_action_frame, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fext_channel_switch_action_frame, Action),
	SigFfAction, DOT11F_FF_ACTION_LEN, },
	{ "ext_chan_switch_ann_action",
	offsetof(tDot11fext_channel_switch_action_frame,
	ext_chan_switch_ann_action), SigFfext_chan_switch_ann_action,
	DOT11F_FF_EXT_CHAN_SWITCH_ANN_ACTION_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_ext_channel_switch_action_frame[] = {
	{ offsetof(tDot11fext_channel_switch_action_frame,
	WiderBWChanSwitchAnn), offsetof(tDot11fIEWiderBWChanSwitchAnn, present),
	0, "WiderBWChanSwitchAnn", 0, 5, 5, SigIeWiderBWChanSwitchAnn,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_WIDERBWCHANSWITCHANN, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_ext_channel_switch_action_frame(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fext_channel_switch_action_frame *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_ext_channel_switch_action_frame, IES_ext_channel_switch_action_frame,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_ext_channel_switch_action_frame. */

static const tFFDefn FFS_ht2040_bss_coexistence_mgmt_action_frame[] = {
	{ "Category", offsetof(tDot11fht2040_bss_coexistence_mgmt_action_frame,
	Category), SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fht2040_bss_coexistence_mgmt_action_frame,
	Action), SigFfAction, DOT11F_FF_ACTION_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_ht2040_bss_coexistence_mgmt_action_frame[] = {
	{ offsetof(tDot11fht2040_bss_coexistence_mgmt_action_frame,
	ht2040_bss_coexistence), offsetof(tDot11fIEht2040_bss_coexistence,
	present), 0, "ht2040_bss_coexistence",
	0, 3, 3, SigIeht2040_bss_coexistence, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HT2040_BSS_COEXISTENCE, 0, 1, },
	{ offsetof(tDot11fht2040_bss_coexistence_mgmt_action_frame,
	ht2040_bss_intolerant_report),
	offsetof(tDot11fIEht2040_bss_intolerant_report, present), 0,
	"ht2040_bss_intolerant_report",
	0, 3, 53, SigIeht2040_bss_intolerant_report, {0, 0, 0, 0, 0},
	0, DOT11F_EID_HT2040_BSS_INTOLERANT_REPORT, 0, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_ht2040_bss_coexistence_mgmt_action_frame(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fht2040_bss_coexistence_mgmt_action_frame *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_ht2040_bss_coexistence_mgmt_action_frame, IES_ht2040_bss_coexistence_mgmt_action_frame,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_ht2040_bss_coexistence_mgmt_action_frame. */

static const tFFDefn FFS_mscs_request_action_frame[] = {
	{ "Category", offsetof(tDot11fmscs_request_action_frame, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "Action", offsetof(tDot11fmscs_request_action_frame, Action),
	SigFfAction, DOT11F_FF_ACTION_LEN, },
	{ "DialogToken", offsetof(tDot11fmscs_request_action_frame, DialogToken),
	SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_mscs_request_action_frame[] = {
	{ offsetof(tDot11fmscs_request_action_frame, decriptor_element),
	offsetof(tDot11fIEdecriptor_element, present), 0, "decriptor_element",
	0, 9, 32, SigIedecriptor_element, {0, 0, 0, 0, 0},
	0, DOT11F_EID_DECRIPTOR_ELEMENT, 88, 1, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_mscs_request_action_frame(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fmscs_request_action_frame *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_mscs_request_action_frame, IES_mscs_request_action_frame,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_mscs_request_action_frame. */

static const tFFDefn FFS_p2p_oper_chan_change_confirm[] = {
	{ "Category", offsetof(tDot11fp2p_oper_chan_change_confirm, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "p2p_action_oui", offsetof(tDot11fp2p_oper_chan_change_confirm,
	p2p_action_oui), SigFfp2p_action_oui, DOT11F_FF_P2P_ACTION_OUI_LEN, },
	{ "p2p_action_subtype", offsetof(tDot11fp2p_oper_chan_change_confirm,
	p2p_action_subtype), SigFfp2p_action_subtype,
	DOT11F_FF_P2P_ACTION_SUBTYPE_LEN, },
	{ "DialogToken", offsetof(tDot11fp2p_oper_chan_change_confirm,
	DialogToken), SigFfDialogToken, DOT11F_FF_DIALOGTOKEN_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_p2p_oper_chan_change_confirm[] = {
	{ offsetof(tDot11fp2p_oper_chan_change_confirm, HTCaps),
	offsetof(tDot11fIEHTCaps, present), 0, "HTCaps", 0, 28, 60, SigIeHTCaps,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_HTCAPS, 0, 0, },
	{ offsetof(tDot11fp2p_oper_chan_change_confirm, VHTCaps),
	offsetof(tDot11fIEVHTCaps, present), 0, "VHTCaps", 0, 14, 14, SigIeVHTCaps,
	{0, 0, 0, 0, 0}, 0, DOT11F_EID_VHTCAPS, 0, 0, },
	{ offsetof(tDot11fp2p_oper_chan_change_confirm, OperatingMode),
	offsetof(tDot11fIEOperatingMode, present), 0, "OperatingMode",
	0, 3, 3, SigIeOperatingMode, {0, 0, 0, 0, 0},
	0, DOT11F_EID_OPERATINGMODE, 0, 0, },
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_p2p_oper_chan_change_confirm(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fp2p_oper_chan_change_confirm *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_p2p_oper_chan_change_confirm, IES_p2p_oper_chan_change_confirm,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_p2p_oper_chan_change_confirm. */

static const tFFDefn FFS_vendor_action_frame[] = {
	{ "Category", offsetof(tDot11fvendor_action_frame, Category),
	SigFfCategory, DOT11F_FF_CATEGORY_LEN, },
	{ "vendor_oui", offsetof(tDot11fvendor_action_frame, vendor_oui),
	SigFfvendor_oui, DOT11F_FF_VENDOR_OUI_LEN, },
	{ "vendor_action_subtype", offsetof(tDot11fvendor_action_frame,
	vendor_action_subtype), SigFfvendor_action_subtype,
	DOT11F_FF_VENDOR_ACTION_SUBTYPE_LEN, },
	{ NULL, 0, 0, 0,},
};

static const tIEDefn IES_vendor_action_frame[] = {
	{0, 0, 0, NULL, 0, 0, 0, 0, {0, 0, 0, 0, 0}, 0, 0xff, 0, },};

uint32_t dot11f_unpack_vendor_action_frame(tpAniSirGlobal pCtx,
		uint8_t *pBuf, uint32_t nBuf,
		tDot11fvendor_action_frame *pFrm, bool append_ie)
{
	uint32_t i = 0;
	uint32_t status = 0;
	status = unpack_core(pCtx, pBuf, nBuf,
		      FFS_vendor_action_frame, IES_vendor_action_frame,
		      (uint8_t *)pFrm, sizeof(*pFrm), append_ie);

	(void)i;
	return status;

} /* End dot11f_unpack_vendor_action_frame. */

/**
 * Note: If @append_ie is set TRUE, pFrm will not be reset to zero,
 * but parsed IE's would be populated to pFrm with already
 * populated IE's in pFrm
 */
static uint32_t unpack_core(tpAniSirGlobal pCtx,
			    uint8_t *pBuf,
			    uint32_t nBuf,
			    const tFFDefn  FFs[],
			    const tIEDefn  IEs[],
			    uint8_t *pFrm,
			    size_t nFrm,
			    bool append_ie)
{
	const tFFDefn *pFf;
	const tIEDefn *pIe;
	uint8_t   *pBufRemaining;
	uint32_t  nBufRemaining, status;
	uint8_t   eid, len, extn_eid;
	tFRAMES_BOOL  *pfFound;
	uint32_t  countOffset = 0;

	DOT11F_PARAMETER_CHECK(pBuf, nBuf, pFrm, nFrm);
	(void)nFrm;

	(void)pCtx;
	status = DOT11F_PARSE_SUCCESS;
	pBufRemaining = pBuf;
	nBufRemaining = nBuf;

	pIe = &IEs[0];
	while (!append_ie && (0xff != pIe->eid || pIe->extn_eid)) {
		pfFound = (tFRAMES_BOOL *)(pFrm + pIe->offset +
				   pIe->presenceOffset);
		*pfFound = 0U;
		if (pIe->countOffset)
			*(uint16_t *)(pFrm + pIe->countOffset) = 0U;
		++pIe;
	}

	pFf = &FFs[0];
	while (!append_ie && pFf->size) {
		if (pFf->size > nBufRemaining) {
			FRAMES_LOG3(pCtx, FRLOGE, FRFL("Fixed field %s is %d"
					  "bytes in size, but there are only %d bytes left i"
					  "n this frame.\n"), pFf->name, pFf->size,
					  nBufRemaining);
			FRAMES_DBG_BREAK();
			return DOT11F_MISSING_FIXED_FIELD;
		}

		switch (pFf->sig) {

		case SigFfAID:
			dot11f_unpack_ff_common_func(pCtx,
			    pBufRemaining, (uint16_t *)&(((tDot11fFfAID *)
			    (pFrm + pFf->offset))->associd));
			break;
		case SigFfAction:
			dot11f_unpack_ff_action(pCtx,
			    pBufRemaining, (tDot11fFfAction *)
			    (pFrm + pFf->offset));
			break;
		case SigFfAuthAlgo:
			dot11f_unpack_ff_common_func(pCtx,
			    pBufRemaining, (uint16_t *)&(((tDot11fFfAuthAlgo *)
			    (pFrm + pFf->offset))->algo));
			break;
		case SigFfAuthSeqNo:
			dot11f_unpack_ff_common_func(pCtx,
			    pBufRemaining, (uint16_t *)&(((tDot11fFfAuthSeqNo *)
			    (pFrm + pFf->offset))->no));
			break;
		case SigFfBeaconInterval:
			dot11f_unpack_ff_common_func(pCtx,
			    pBufRemaining, (uint16_t *)&(((tDot11fFfBeaconInterval *)
			    (pFrm + pFf->offset))->interval));
			break;
		case SigFfCapabilities:
			dot11f_unpack_ff_capabilities(pCtx,
			    pBufRemaining, (tDot11fFfCapabilities *)
			    (pFrm + pFf->offset));
			break;
		case SigFfCategory:
			dot11f_unpack_ff_category(pCtx,
			    pBufRemaining, (tDot11fFfCategory *)
			    (pFrm + pFf->offset));
			break;
		case SigFfCurrentAPAddress:
			dot11f_unpack_ff_current_ap_address(pCtx,
			    pBufRemaining, (tDot11fFfCurrentAPAddress *)
			    (pFrm + pFf->offset));
			break;
		case SigFfDialogToken:
			dot11f_unpack_ff_dialog_token(pCtx,
			    pBufRemaining, (tDot11fFfDialogToken *)
			    (pFrm + pFf->offset));
			break;
		case SigFfLinkMargin:
			dot11f_unpack_ff_link_margin(pCtx,
			    pBufRemaining, (tDot11fFfLinkMargin *)
			    (pFrm + pFf->offset));
			break;
		case SigFfListenInterval:
			dot11f_unpack_ff_common_func(pCtx,
			    pBufRemaining, (uint16_t *)&(((tDot11fFfListenInterval *)
			    (pFrm + pFf->offset))->interval));
			break;
		case SigFfMaxTxPower:
			dot11f_unpack_ff_max_tx_power(pCtx,
			    pBufRemaining, (tDot11fFfMaxTxPower *)
			    (pFrm + pFf->offset));
			break;
		case SigFfNumOfRepetitions:
			dot11f_unpack_ff_num_of_repetitions(pCtx,
			    pBufRemaining, (tDot11fFfNumOfRepetitions *)
			    (pFrm + pFf->offset));
			break;
		case SigFfOperatingMode:
			dot11f_unpack_ff_operating_mode(pCtx,
			    pBufRemaining, (tDot11fFfOperatingMode *)
			    (pFrm + pFf->offset));
			break;
		case SigFfRCPI:
			dot11f_unpack_ff_rcpi(pCtx,
			    pBufRemaining, (tDot11fFfRCPI *)
			    (pFrm + pFf->offset));
			break;
		case SigFfRSNI:
			dot11f_unpack_ff_rsni(pCtx,
			    pBufRemaining, (tDot11fFfRSNI *)
			    (pFrm + pFf->offset));
			break;
		case SigFfReason:
			dot11f_unpack_ff_common_func(pCtx,
			    pBufRemaining, (uint16_t *)&(((tDot11fFfReason *)
			    (pFrm + pFf->offset))->code));
			break;
		case SigFfRxAntennaId:
			dot11f_unpack_ff_rx_antenna_id(pCtx,
			    pBufRemaining, (tDot11fFfRxAntennaId *)
			    (pFrm + pFf->offset));
			break;
		case SigFfSMPowerModeSet:
			dot11f_unpack_ff_sm_power_mode_set(pCtx,
			    pBufRemaining, (tDot11fFfSMPowerModeSet *)
			    (pFrm + pFf->offset));
			break;
		case SigFfStatus:
			dot11f_unpack_ff_common_func(pCtx,
			    pBufRemaining, (uint16_t *)&(((tDot11fFfStatus *)
			    (pFrm + pFf->offset))->status));
			break;
		case SigFfStatusCode:
			dot11f_unpack_ff_status_code(pCtx,
			    pBufRemaining, (tDot11fFfStatusCode *)
			    (pFrm + pFf->offset));
			break;
		case SigFfTPCEleID:
			dot11f_unpack_ff_tpc_ele_id(pCtx,
			    pBufRemaining, (tDot11fFfTPCEleID *)
			    (pFrm + pFf->offset));
			break;
		case SigFfTPCEleLen:
			dot11f_unpack_ff_tpc_ele_len(pCtx,
			    pBufRemaining, (tDot11fFfTPCEleLen *)
			    (pFrm + pFf->offset));
			break;
		case SigFfTSInfo:
			dot11f_unpack_ff_ts_info(pCtx,
			    pBufRemaining, (tDot11fFfTSInfo *)
			    (pFrm + pFf->offset));
			break;
		case SigFfTimeStamp:
			dot11f_unpack_ff_time_stamp(pCtx,
			    pBufRemaining, (tDot11fFfTimeStamp *)
			    (pFrm + pFf->offset));
			break;
		case SigFfTransactionId:
			dot11f_unpack_ff_transaction_id(pCtx,
			    pBufRemaining, (tDot11fFfTransactionId *)
			    (pFrm + pFf->offset));
			break;
		case SigFfTxAntennaId:
			dot11f_unpack_ff_tx_antenna_id(pCtx,
			    pBufRemaining, (tDot11fFfTxAntennaId *)
			    (pFrm + pFf->offset));
			break;
		case SigFfTxPower:
			dot11f_unpack_ff_tx_power(pCtx,
			    pBufRemaining, (tDot11fFfTxPower *)
			    (pFrm + pFf->offset));
			break;
		case SigFfVhtMembershipStatusArray:
			dot11f_unpack_ff_vht_membership_status_array(pCtx,
			    pBufRemaining, (tDot11fFfVhtMembershipStatusArray *)
			    (pFrm + pFf->offset));
			break;
		case SigFfVhtUserPositionArray:
			dot11f_unpack_ff_vht_user_position_array(pCtx,
			    pBufRemaining, (tDot11fFfVhtUserPositionArray *)
			    (pFrm + pFf->offset));
			break;
		case SigFfaddba_param_set:
			dot11f_unpack_ff_addba_param_set(pCtx,
			    pBufRemaining, (tDot11fFfaddba_param_set *)
			    (pFrm + pFf->offset));
			break;
		case SigFfba_start_seq_ctrl:
			dot11f_unpack_ff_ba_start_seq_ctrl(pCtx,
			    pBufRemaining, (tDot11fFfba_start_seq_ctrl *)
			    (pFrm + pFf->offset));
			break;
		case SigFfba_timeout:
			dot11f_unpack_ff_ba_timeout(pCtx,
			    pBufRemaining, (tDot11fFfba_timeout *)
			    (pFrm + pFf->offset));
			break;
		case SigFfdelba_param_set:
			dot11f_unpack_ff_delba_param_set(pCtx,
			    pBufRemaining, (tDot11fFfdelba_param_set *)
			    (pFrm + pFf->offset));
			break;
		case SigFfext_chan_switch_ann_action:
			dot11f_unpack_ff_ext_chan_switch_ann_action(pCtx,
			    pBufRemaining, (tDot11fFfext_chan_switch_ann_action *)
			    (pFrm + pFf->offset));
			break;
		case SigFfp2p_action_oui:
			dot11f_unpack_ff_p2p_action_oui(pCtx,
			    pBufRemaining, (tDot11fFfp2p_action_oui *)
			    (pFrm + pFf->offset));
			break;
		case SigFfp2p_action_subtype:
			dot11f_unpack_ff_p2p_action_subtype(pCtx,
			    pBufRemaining, (tDot11fFfp2p_action_subtype *)
			    (pFrm + pFf->offset));
			break;
		case SigFfvendor_action_subtype:
			dot11f_unpack_ff_vendor_action_subtype(pCtx,
			    pBufRemaining, (tDot11fFfvendor_action_subtype *)
			    (pFrm + pFf->offset));
			break;
		case SigFfvendor_oui:
			dot11f_unpack_ff_vendor_oui(pCtx,
			    pBufRemaining, (tDot11fFfvendor_oui *)
			    (pFrm + pFf->offset));
			break;
		default:
			FRAMES_LOG1(pCtx, FRLOGE, FRFL("INTERNAL ERROR: I don'"
				   "t know about the FF signature %d-- this is most "
				   "likely a 'framesc' bug.\n"), pFf->sig);
			return DOT11F_INTERNAL_ERROR;
		}

		pBufRemaining += pFf->size;
		nBufRemaining -= pFf->size;
		++pFf;
	}

	while (nBufRemaining) {
		if (1 == nBufRemaining) {
			FRAMES_LOG0(pCtx, FRLOGE, FRFL("This frame reports "
				    "only one byte remaining after it's fixed fields.\n"));
			status |= DOT11F_INCOMPLETE_IE;
			FRAMES_DBG_BREAK();
			goto MandatoryCheck;
		}

		pIe = find_ie_defn(pCtx, pBufRemaining, nBufRemaining, IEs);

		eid = *pBufRemaining++; --nBufRemaining;
		len = *pBufRemaining++; --nBufRemaining;
		if (pIe && pIe->extn_eid) {
			extn_eid = *pBufRemaining++; --nBufRemaining;
			len--;
		}

		if (pIe && pIe->noui) {
			if (pIe->noui > nBufRemaining) {
				FRAMES_LOG4(pCtx, FRLOGW, FRFL("IE %d extn id %d reports "
					"length %d, but it has an OUI of %d bytes.\n"),
					eid, extn_eid, len, pIe->noui);
				FRAMES_DUMP(pCtx, FRLOG1, pBuf, nBuf);
				FRAMES_LOG2(pCtx, FRLOG1, FRFL("We've parsed %d by"
					"tes of this buffer, and show %d left.\n"),
					pBufRemaining - pBuf, nBufRemaining);
				status |= DOT11F_INCOMPLETE_IE;
				FRAMES_DBG_BREAK();
				goto MandatoryCheck;
			}
			pBufRemaining += pIe->noui;
			nBufRemaining -= pIe->noui;
			len           -= pIe->noui;
		}

		if (len > nBufRemaining) {
			FRAMES_LOG4(pCtx, FRLOGW, FRFL("IE %d extn id %d reports length %"
				"d, but there are only %d bytes remaining in this"
				" frame.\n"), eid, extn_eid, len, nBufRemaining);
			FRAMES_DUMP(pCtx, FRLOG1, pBuf, nBuf);
			FRAMES_LOG2(pCtx, FRLOG1, FRFL("We've parsed %d by"
				"tes of this buffer, and show %d left.\n"),
				pBufRemaining - pBuf, nBufRemaining);
			status |= DOT11F_INCOMPLETE_IE;
			FRAMES_DBG_BREAK();
			goto MandatoryCheck;
		}

		if (pIe) {
			if ((nBufRemaining < pIe->minSize - pIe->noui - 2U)) {
				FRAMES_LOG3(pCtx, FRLOGW, FRFL("The IE %s must "
					"be at least %d bytes in size, but "
					"there are only %d bytes remaining in "
					"this frame\n"),
					pIe->name, pIe->minSize, nBufRemaining);
				FRAMES_DUMP(pCtx, FRLOG1, pBuf, nBuf);
				status |= DOT11F_INCOMPLETE_IE;
				FRAMES_DBG_BREAK();
				goto MandatoryCheck;
			} else {
				if (len < pIe->minSize - pIe->noui - 2U) {
					FRAMES_LOG3(pCtx, FRLOGW, FRFL("The IE %s must "
							"be at least %d bytes in size, but "
							"there are only %d bytes in the IE\n"),
							pIe->name, pIe->minSize, (len + pIe->noui + 2U));
					goto skip_ie;
				}

				if (len > pIe->maxSize - pIe->noui - 2U) {
				FRAMES_LOG1(pCtx, FRLOGW, FRFL("The IE %s reports "
					"an unexpectedly large size; it is presumably "
					"more up-to-date than this parser, but this wa"
					"rning may also indicate a corrupt frame.\n"),
					pIe->name);
					FRAMES_DUMP(pCtx, FRLOG1, pBuf, nBuf);
				}

				countOffset = ((0 != pIe->arraybound) *
						(*(uint16_t *)(pFrm + pIe->countOffset)));
				if (0 != pIe->arraybound && countOffset >= pIe->arraybound) {
					status |= DOT11F_DUPLICATE_IE;
					goto skip_ie;
				}
				switch (pIe->sig) {
				case SigIeGTK:
					status |=
						dot11f_unpack_ie_gtk(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEGTK *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEGTK) *
						    countOffset),
						    append_ie);
					break;
				case SigIeIGTK:
					status |=
						dot11f_unpack_ie_igtk(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEIGTK *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEIGTK) *
						    countOffset),
						    append_ie);
					break;
				case SigIeR0KH_ID:
					status |=
						dot11f_unpack_ie_r0_kh_id(
						    pCtx, pBufRemaining, len,
						    (tDot11fIER0KH_ID *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIER0KH_ID) *
						    countOffset),
						    append_ie);
					break;
				case SigIeR1KH_ID:
					status |=
						dot11f_unpack_ie_r1_kh_id(
						    pCtx, pBufRemaining, len,
						    (tDot11fIER1KH_ID *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIER1KH_ID) *
						    countOffset),
						    append_ie);
					break;
				case SigIeAPChannelReport:
					status |=
						dot11f_unpack_ie_ap_channel_report(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEAPChannelReport *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEAPChannelReport) *
						    countOffset),
						    append_ie);
					break;
				case SigIeBcnReportingDetail:
					status |=
						dot11f_unpack_ie_bcn_reporting_detail(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEBcnReportingDetail *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEBcnReportingDetail) *
						    countOffset),
						    append_ie);
					break;
				case SigIeBeaconReportFrmBody:
					status |=
						dot11f_unpack_ie_beacon_report_frm_body(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEBeaconReportFrmBody *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEBeaconReportFrmBody) *
						    countOffset),
						    append_ie);
					break;
				case SigIeBeaconReporting:
					status |=
						dot11f_unpack_ie_beacon_reporting(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEBeaconReporting *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEBeaconReporting) *
						    countOffset),
						    append_ie);
					break;
				case SigIeCondensedCountryStr:
					status |=
						dot11f_unpack_ie_condensed_country_str(
						    pCtx, pBufRemaining, len,
						    (tDot11fIECondensedCountryStr *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIECondensedCountryStr) *
						    countOffset),
						    append_ie);
					break;
				case SigIeMeasurementPilot:
					status |=
						dot11f_unpack_ie_measurement_pilot(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEMeasurementPilot *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEMeasurementPilot) *
						    countOffset),
						    append_ie);
					break;
				case SigIeMultiBssid:
					status |=
						dot11f_unpack_ie_multi_bssid(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEMultiBssid *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEMultiBssid) *
						    countOffset),
						    append_ie);
					break;
				case SigIeRICData:
					status |=
						dot11f_unpack_ie_ric_data(
						    pCtx, pBufRemaining, len,
						    (tDot11fIERICData *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIERICData) *
						    countOffset),
						    append_ie);
					break;
				case SigIeRICDescriptor:
					status |=
						dot11f_unpack_ie_ric_descriptor(
						    pCtx, pBufRemaining, len,
						    (tDot11fIERICDescriptor *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIERICDescriptor) *
						    countOffset),
						    append_ie);
					break;
				case SigIeRRMEnabledCap:
					status |=
						dot11f_unpack_ie_rrm_enabled_cap(
						    pCtx, pBufRemaining, len,
						    (tDot11fIERRMEnabledCap *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIERRMEnabledCap) *
						    countOffset),
						    append_ie);
					break;
				case SigIeRequestedInfo:
					status |=
						dot11f_unpack_ie_requested_info(
						    pCtx, pBufRemaining, len,
						    (tDot11fIERequestedInfo *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIERequestedInfo) *
						    countOffset),
						    append_ie);
					break;
				case SigIeSSID:
					status |=
						dot11f_unpack_ie_ssid(
						    pCtx, pBufRemaining, len,
						    (tDot11fIESSID *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIESSID) *
						    countOffset),
						    append_ie);
					break;
				case SigIeSchedule:
					status |=
						dot11f_unpack_ie_schedule(
						    pCtx, pBufRemaining, len,
						    (tDot11fIESchedule *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIESchedule) *
						    countOffset),
						    append_ie);
					break;
				case SigIeTCLAS:
					status |=
						dot11f_unpack_ie_tclas(
						    pCtx, pBufRemaining, len,
						    (tDot11fIETCLAS *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIETCLAS) *
						    countOffset),
						    append_ie);
					break;
				case SigIeTCLASSPROC:
					status |= dot11f_unpack_ie_common_func(pCtx, pBufRemaining, len,
										(uint8_t *) &(((tDot11fIETCLASSPROC *)(pFrm + pIe->offset + sizeof(tDot11fIETCLASSPROC)*countOffset))->present),
										(uint8_t *) &(((tDot11fIETCLASSPROC *)(pFrm + pIe->offset + sizeof(tDot11fIETCLASSPROC)*countOffset))->processing));
					break;
				case SigIeTSDelay:
					status |=
						dot11f_unpack_ie_ts_delay(
						    pCtx, pBufRemaining, len,
						    (tDot11fIETSDelay *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIETSDelay) *
						    countOffset),
						    append_ie);
					break;
				case SigIeTSFInfo:
					status |=
						dot11f_unpack_ie_tsf_info(
						    pCtx, pBufRemaining, len,
						    (tDot11fIETSFInfo *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIETSFInfo) *
						    countOffset),
						    append_ie);
					break;
				case SigIeTSPEC:
					status |=
						dot11f_unpack_ie_tspec(
						    pCtx, pBufRemaining, len,
						    (tDot11fIETSPEC *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIETSPEC) *
						    countOffset),
						    append_ie);
					break;
				case SigIeVHTCaps:
					status |=
						dot11f_unpack_ie_vht_caps(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEVHTCaps *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEVHTCaps) *
						    countOffset),
						    append_ie);
					break;
				case SigIeVHTOperation:
					status |=
						dot11f_unpack_ie_vht_operation(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEVHTOperation *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEVHTOperation) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWMMSchedule:
					status |=
						dot11f_unpack_ie_wmm_schedule(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWMMSchedule *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWMMSchedule) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWMMTCLAS:
					status |=
						dot11f_unpack_ie_wmmtclas(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWMMTCLAS *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWMMTCLAS) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWMMTCLASPROC:
					status |=
						dot11f_unpack_ie_wmmtclasproc(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWMMTCLASPROC *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWMMTCLASPROC) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWMMTSDelay:
					status |=
						dot11f_unpack_ie_wmmts_delay(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWMMTSDelay *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWMMTSDelay) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWMMTSPEC:
					status |=
						dot11f_unpack_ie_wmmtspec(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWMMTSPEC *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWMMTSPEC) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWiderBWChanSwitchAnn:
					status |=
						dot11f_unpack_ie_wider_bw_chan_switch_ann(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWiderBWChanSwitchAnn *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWiderBWChanSwitchAnn) *
						    countOffset),
						    append_ie);
					break;
				case SigIeazimuth_req:
					status |=
						dot11f_unpack_ie_azimuth_req(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEazimuth_req *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEazimuth_req) *
						    countOffset),
						    append_ie);
					break;
				case SigIebeacon_report_frm_body_fragment_id:
					status |=
						dot11f_unpack_ie_beacon_report_frm_body_fragment_id(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEbeacon_report_frm_body_fragment_id *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEbeacon_report_frm_body_fragment_id) *
						    countOffset),
						    append_ie);
					break;
				case SigIelast_beacon_report_indication:
					status |=
						dot11f_unpack_ie_last_beacon_report_indication(
						    pCtx, pBufRemaining, len,
						    (tDot11fIElast_beacon_report_indication *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIElast_beacon_report_indication) *
						    countOffset),
						    append_ie);
					break;
				case SigIemax_age:
					status |=
						dot11f_unpack_ie_max_age(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEmax_age *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEmax_age) *
						    countOffset),
						    append_ie);
					break;
				case SigIemscs_status:
					status |=
						dot11f_unpack_ie_mscs_status(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEmscs_status *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEmscs_status) *
						    countOffset),
						    append_ie);
					break;
				case SigIeneighbor_rpt:
					status |=
						dot11f_unpack_ie_neighbor_rpt(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEneighbor_rpt *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEneighbor_rpt) *
						    countOffset),
						    append_ie);
					break;
				case SigIereq_mac_addr:
					status |=
						dot11f_unpack_ie_req_mac_addr(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEreq_mac_addr *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEreq_mac_addr) *
						    countOffset),
						    append_ie);
					break;
				case SigIetclas_mask:
					status |=
						dot11f_unpack_ie_tclas_mask(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEtclas_mask *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEtclas_mask) *
						    countOffset),
						    append_ie);
					break;
				case SigIetgt_mac_addr:
					status |=
						dot11f_unpack_ie_tgt_mac_addr(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEtgt_mac_addr *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEtgt_mac_addr) *
						    countOffset),
						    append_ie);
					break;
				case SigIetransmit_power_env:
					status |=
						dot11f_unpack_ie_transmit_power_env(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEtransmit_power_env *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEtransmit_power_env) *
						    countOffset),
						    append_ie);
					break;
				case SigIeAID:
					status |=
						dot11f_unpack_ie_aid(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEAID *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEAID) *
						    countOffset),
						    append_ie);
					break;
				case SigIeCFParams:
					status |=
						dot11f_unpack_ie_cf_params(
						    pCtx, pBufRemaining, len,
						    (tDot11fIECFParams *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIECFParams) *
						    countOffset),
						    append_ie);
					break;
				case SigIeChallengeText:
					status |=
						dot11f_unpack_ie_challenge_text(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEChallengeText *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEChallengeText) *
						    countOffset),
						    append_ie);
					break;
				case SigIeChanSwitchAnn:
					status |=
						dot11f_unpack_ie_chan_switch_ann(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEChanSwitchAnn *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEChanSwitchAnn) *
						    countOffset),
						    append_ie);
					break;
				case SigIeChannelSwitchWrapper:
					status |=
						dot11f_unpack_ie_channel_switch_wrapper(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEChannelSwitchWrapper *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEChannelSwitchWrapper) *
						    countOffset),
						    append_ie);
					break;
				case SigIeCountry:
					status |=
						dot11f_unpack_ie_country(
						    pCtx, pBufRemaining, len,
						    (tDot11fIECountry *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIECountry) *
						    countOffset),
						    append_ie);
					break;
				case SigIeDSParams:
					status |= dot11f_unpack_ie_common_func(pCtx, pBufRemaining, len,
										(uint8_t *) &(((tDot11fIEDSParams *)(pFrm + pIe->offset + sizeof(tDot11fIEDSParams)*countOffset))->present),
										(uint8_t *) &(((tDot11fIEDSParams *)(pFrm + pIe->offset + sizeof(tDot11fIEDSParams)*countOffset))->curr_channel));
					break;
				case SigIeEDCAParamSet:
					status |=
						dot11f_unpack_ie_edca_param_set(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEEDCAParamSet *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEEDCAParamSet) *
						    countOffset),
						    append_ie);
					break;
				case SigIeERPInfo:
					status |=
						dot11f_unpack_ie_erp_info(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEERPInfo *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEERPInfo) *
						    countOffset),
						    append_ie);
					break;
				case SigIeESECckmOpaque:
					status |=
						dot11f_unpack_ie_ese_cckm_opaque(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEESECckmOpaque *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEESECckmOpaque) *
						    countOffset),
						    append_ie);
					break;
				case SigIeESERadMgmtCap:
					status |=
						dot11f_unpack_ie_ese_rad_mgmt_cap(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEESERadMgmtCap *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEESERadMgmtCap) *
						    countOffset),
						    append_ie);
					break;
				case SigIeESETrafStrmMet:
					status |=
						dot11f_unpack_ie_ese_traf_strm_met(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEESETrafStrmMet *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEESETrafStrmMet) *
						    countOffset),
						    append_ie);
					break;
				case SigIeESETrafStrmRateSet:
					status |=
						dot11f_unpack_ie_ese_traf_strm_rate_set(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEESETrafStrmRateSet *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEESETrafStrmRateSet) *
						    countOffset),
						    append_ie);
					break;
				case SigIeESETxmitPower:
					status |=
						dot11f_unpack_ie_ese_txmit_power(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEESETxmitPower *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEESETxmitPower) *
						    countOffset),
						    append_ie);
					break;
				case SigIeESEVersion:
					status |=
						dot11f_unpack_ie_ese_version(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEESEVersion *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEESEVersion) *
						    countOffset),
						    append_ie);
					break;
				case SigIeExtCap:
					status |=
						dot11f_unpack_ie_ext_cap(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEExtCap *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEExtCap) *
						    countOffset),
						    append_ie);
					break;
				case SigIeExtSuppRates:
					status |=
						dot11f_unpack_ie_ext_supp_rates(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEExtSuppRates *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEExtSuppRates) *
						    countOffset),
						    append_ie);
					break;
				case SigIeFHParamSet:
					status |=
						dot11f_unpack_ie_fh_param_set(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEFHParamSet *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEFHParamSet) *
						    countOffset),
						    append_ie);
					break;
				case SigIeFHParams:
					status |=
						dot11f_unpack_ie_fh_params(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEFHParams *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEFHParams) *
						    countOffset),
						    append_ie);
					break;
				case SigIeFHPattTable:
					status |=
						dot11f_unpack_ie_fh_patt_table(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEFHPattTable *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEFHPattTable) *
						    countOffset),
						    append_ie);
					break;
				case SigIeFTInfo:
					status |=
						dot11f_unpack_ie_ft_info(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEFTInfo *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEFTInfo) *
						    countOffset),
						    append_ie);
					break;
				case SigIeHTCaps:
					status |=
						dot11f_unpack_ie_ht_caps(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEHTCaps *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEHTCaps) *
						    countOffset),
						    append_ie);
					break;
				case SigIeHTInfo:
					status |=
						dot11f_unpack_ie_ht_info(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEHTInfo *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEHTInfo) *
						    countOffset),
						    append_ie);
					break;
				case SigIeLinkIdentifier:
					status |=
						dot11f_unpack_ie_link_identifier(
						    pCtx, pBufRemaining, len,
						    (tDot11fIELinkIdentifier *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIELinkIdentifier) *
						    countOffset),
						    append_ie);
					break;
				case SigIeMBO_IE:
					status |=
						dot11f_unpack_ie_MBO_IE(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEMBO_IE *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEMBO_IE) *
						    countOffset),
						    append_ie);
					break;
				case SigIeMeasurementReport:
					status |=
						dot11f_unpack_ie_measurement_report(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEMeasurementReport *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEMeasurementReport) *
						    countOffset),
						    append_ie);
					break;
				case SigIeMeasurementRequest:
					status |=
						dot11f_unpack_ie_measurement_request(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEMeasurementRequest *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEMeasurementRequest) *
						    countOffset),
						    append_ie);
					break;
				case SigIeMobilityDomain:
					status |=
						dot11f_unpack_ie_mobility_domain(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEMobilityDomain *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEMobilityDomain) *
						    countOffset),
						    append_ie);
					break;
				case SigIeNeighborReport:
					status |=
						dot11f_unpack_ie_neighbor_report(
						    pCtx, pBufRemaining, len,
						    (tDot11fIENeighborReport *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIENeighborReport) *
						    countOffset),
						    append_ie);
					break;
				case SigIeOBSSScanParameters:
					status |=
						dot11f_unpack_ie_obss_scan_parameters(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEOBSSScanParameters *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEOBSSScanParameters) *
						    countOffset),
						    append_ie);
					break;
				case SigIeOperatingMode:
					status |=
						dot11f_unpack_ie_operating_mode(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEOperatingMode *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEOperatingMode) *
						    countOffset),
						    append_ie);
					break;
				case SigIeP2PAssocReq:
					status |=
						dot11f_unpack_ie_p2_p_assoc_req(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEP2PAssocReq *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEP2PAssocReq) *
						    countOffset),
						    append_ie);
					break;
				case SigIeP2PAssocRes:
					status |=
						dot11f_unpack_ie_p2_p_assoc_res(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEP2PAssocRes *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEP2PAssocRes) *
						    countOffset),
						    append_ie);
					break;
				case SigIeP2PBeacon:
					status |=
						dot11f_unpack_ie_p2_p_beacon(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEP2PBeacon *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEP2PBeacon) *
						    countOffset),
						    append_ie);
					break;
				case SigIeP2PBeaconProbeRes:
					status |=
						dot11f_unpack_ie_p2_p_beacon_probe_res(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEP2PBeaconProbeRes *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEP2PBeaconProbeRes) *
						    countOffset),
						    append_ie);
					break;
				case SigIeP2PDeAuth:
					status |=
						dot11f_unpack_ie_p2_p_de_auth(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEP2PDeAuth *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEP2PDeAuth) *
						    countOffset),
						    append_ie);
					break;
				case SigIeP2PDisAssoc:
					status |=
						dot11f_unpack_ie_p2_p_dis_assoc(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEP2PDisAssoc *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEP2PDisAssoc) *
						    countOffset),
						    append_ie);
					break;
				case SigIeP2PIEOpaque:
					status |=
						dot11f_unpack_ie_p2_pie_opaque(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEP2PIEOpaque *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEP2PIEOpaque) *
						    countOffset),
						    append_ie);
					break;
				case SigIeP2PProbeReq:
					status |=
						dot11f_unpack_ie_p2_p_probe_req(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEP2PProbeReq *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEP2PProbeReq) *
						    countOffset),
						    append_ie);
					break;
				case SigIeP2PProbeRes:
					status |=
						dot11f_unpack_ie_p2_p_probe_res(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEP2PProbeRes *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEP2PProbeRes) *
						    countOffset),
						    append_ie);
					break;
				case SigIePTIControl:
					status |=
						dot11f_unpack_ie_pti_control(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEPTIControl *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEPTIControl) *
						    countOffset),
						    append_ie);
					break;
				case SigIePUBufferStatus:
					status |=
						dot11f_unpack_ie_pu_buffer_status(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEPUBufferStatus *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEPUBufferStatus) *
						    countOffset),
						    append_ie);
					break;
				case SigIePowerCaps:
					status |=
						dot11f_unpack_ie_power_caps(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEPowerCaps *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEPowerCaps) *
						    countOffset),
						    append_ie);
					break;
				case SigIePowerConstraints:
					status |=
						dot11f_unpack_ie_power_constraints(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEPowerConstraints *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEPowerConstraints) *
						    countOffset),
						    append_ie);
					break;
				case SigIeQBSSLoad:
					status |=
						dot11f_unpack_ie_qbss_load(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEQBSSLoad *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEQBSSLoad) *
						    countOffset),
						    append_ie);
					break;
				case SigIeQComVendorIE:
					status |=
						dot11f_unpack_ie_QComVendorIE(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEQComVendorIE *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEQComVendorIE) *
						    countOffset),
						    append_ie);
					break;
				case SigIeQOSCapsAp:
					status |=
						dot11f_unpack_ie_qos_caps_ap(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEQOSCapsAp *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEQOSCapsAp) *
						    countOffset),
						    append_ie);
					break;
				case SigIeQOSCapsStation:
					status |=
						dot11f_unpack_ie_qos_caps_station(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEQOSCapsStation *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEQOSCapsStation) *
						    countOffset),
						    append_ie);
					break;
				case SigIeQosMapSet:
					status |=
						dot11f_unpack_ie_qos_map_set(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEQosMapSet *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEQosMapSet) *
						    countOffset),
						    append_ie);
					break;
				case SigIeQuiet:
					status |=
						dot11f_unpack_ie_quiet(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEQuiet *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEQuiet) *
						    countOffset),
						    append_ie);
					break;
				case SigIeRCPIIE:
					status |=
						dot11f_unpack_ie_rcpiie(
						    pCtx, pBufRemaining, len,
						    (tDot11fIERCPIIE *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIERCPIIE) *
						    countOffset),
						    append_ie);
					break;
				case SigIeRICDataDesc:
					/* reset the pointers back since this is a container IE and it doesn't have its own EID and Len. */
					pBufRemaining -= 2;
					nBufRemaining += 2;
					if (pIe && pIe->noui) {
						pBufRemaining -= pIe->noui;
						nBufRemaining += pIe->noui;
						len += pIe->noui;
					}
					status |= get_container_ies_len(pCtx, pBufRemaining, nBufRemaining, &len, IES_RICDataDesc);
					if (status != DOT11F_PARSE_SUCCESS && status != DOT11F_UNKNOWN_IES)
						 break;
					status |=
						dot11f_unpack_ie_ric_data_desc(
						    pCtx, pBufRemaining, len,
						    (tDot11fIERICDataDesc *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIERICDataDesc) *
						    countOffset),
						    append_ie);
					break;
				case SigIeRSN:
					status |=
						dot11f_unpack_ie_rsn(
						    pCtx, pBufRemaining, len,
						    (tDot11fIERSN *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIERSN) *
						    countOffset),
						    append_ie);
					break;
				case SigIeRSNIIE:
					status |=
						dot11f_unpack_ie_rsniie(
						    pCtx, pBufRemaining, len,
						    (tDot11fIERSNIIE *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIERSNIIE) *
						    countOffset),
						    append_ie);
					break;
				case SigIeRSNOpaque:
					status |=
						dot11f_unpack_ie_rsn_opaque(
						    pCtx, pBufRemaining, len,
						    (tDot11fIERSNOpaque *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIERSNOpaque) *
						    countOffset),
						    append_ie);
					break;
				case SigIeSuppChannels:
					status |=
						dot11f_unpack_ie_supp_channels(
						    pCtx, pBufRemaining, len,
						    (tDot11fIESuppChannels *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIESuppChannels) *
						    countOffset),
						    append_ie);
					break;
				case SigIeSuppOperatingClasses:
					status |=
						dot11f_unpack_ie_supp_operating_classes(
						    pCtx, pBufRemaining, len,
						    (tDot11fIESuppOperatingClasses *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIESuppOperatingClasses) *
						    countOffset),
						    append_ie);
					break;
				case SigIeSuppRates:
					status |=
						dot11f_unpack_ie_supp_rates(
						    pCtx, pBufRemaining, len,
						    (tDot11fIESuppRates *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIESuppRates) *
						    countOffset),
						    append_ie);
					break;
				case SigIeTIM:
					status |=
						dot11f_unpack_ie_tim(
						    pCtx, pBufRemaining, len,
						    (tDot11fIETIM *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIETIM) *
						    countOffset),
						    append_ie);
					break;
				case SigIeTPCReport:
					status |=
						dot11f_unpack_ie_tpc_report(
						    pCtx, pBufRemaining, len,
						    (tDot11fIETPCReport *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIETPCReport) *
						    countOffset),
						    append_ie);
					break;
				case SigIeTPCRequest:
					status |=
						dot11f_unpack_ie_tpc_request(
						    pCtx, pBufRemaining, len,
						    (tDot11fIETPCRequest *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIETPCRequest) *
						    countOffset),
						    append_ie);
					break;
				case SigIeTimeAdvertisement:
					status |=
						dot11f_unpack_ie_time_advertisement(
						    pCtx, pBufRemaining, len,
						    (tDot11fIETimeAdvertisement *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIETimeAdvertisement) *
						    countOffset),
						    append_ie);
					break;
				case SigIeTimeoutInterval:
					status |=
						dot11f_unpack_ie_timeout_interval(
						    pCtx, pBufRemaining, len,
						    (tDot11fIETimeoutInterval *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIETimeoutInterval) *
						    countOffset),
						    append_ie);
					break;
				case SigIeVHTExtBssLoad:
					status |=
						dot11f_unpack_ie_vht_ext_bss_load(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEVHTExtBssLoad *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEVHTExtBssLoad) *
						    countOffset),
						    append_ie);
					break;
				case SigIeVendor1IE:
					status |=
						dot11f_unpack_ie_vendor1_ie(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEVendor1IE *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEVendor1IE) *
						    countOffset),
						    append_ie);
					break;
				case SigIeVendor3IE:
					status |=
						dot11f_unpack_ie_vendor3_ie(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEVendor3IE *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEVendor3IE) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWAPI:
					status |=
						dot11f_unpack_ie_wapi(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWAPI *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWAPI) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWAPIOpaque:
					status |=
						dot11f_unpack_ie_wapi_opaque(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWAPIOpaque *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWAPIOpaque) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWFATPC:
					status |=
						dot11f_unpack_ie_wfatpc(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWFATPC *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWFATPC) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWFDIEOpaque:
					status |=
						dot11f_unpack_ie_wfdie_opaque(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWFDIEOpaque *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWFDIEOpaque) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWMMCaps:
					status |=
						dot11f_unpack_ie_wmm_caps(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWMMCaps *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWMMCaps) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWMMInfoAp:
					status |=
						dot11f_unpack_ie_wmm_info_ap(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWMMInfoAp *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWMMInfoAp) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWMMInfoStation:
					status |=
						dot11f_unpack_ie_wmm_info_station(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWMMInfoStation *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWMMInfoStation) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWMMParams:
					status |=
						dot11f_unpack_ie_wmm_params(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWMMParams *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWMMParams) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWPA:
					status |=
						dot11f_unpack_ie_wpa(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWPA *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWPA) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWPAOpaque:
					status |=
						dot11f_unpack_ie_wpa_opaque(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWPAOpaque *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWPAOpaque) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWSC:
					status |=
						dot11f_unpack_ie_wsc(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWSC *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWSC) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWscAssocReq:
					status |=
						dot11f_unpack_ie_wsc_assoc_req(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWscAssocReq *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWscAssocReq) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWscAssocRes:
					status |=
						dot11f_unpack_ie_wsc_assoc_res(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWscAssocRes *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWscAssocRes) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWscBeacon:
					status |=
						dot11f_unpack_ie_wsc_beacon(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWscBeacon *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWscBeacon) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWscBeaconProbeRes:
					status |=
						dot11f_unpack_ie_wsc_beacon_probe_res(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWscBeaconProbeRes *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWscBeaconProbeRes) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWscIEOpaque:
					status |=
						dot11f_unpack_ie_wsc_ie_opaque(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWscIEOpaque *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWscIEOpaque) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWscProbeReq:
					status |=
						dot11f_unpack_ie_wsc_probe_req(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWscProbeReq *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWscProbeReq) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWscProbeRes:
					status |=
						dot11f_unpack_ie_wsc_probe_res(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWscProbeRes *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWscProbeRes) *
						    countOffset),
						    append_ie);
					break;
				case SigIeWscReassocRes:
					status |=
						dot11f_unpack_ie_wsc_reassoc_res(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEWscReassocRes *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEWscReassocRes) *
						    countOffset),
						    append_ie);
					break;
				case SigIeaddba_extn_element:
					status |=
						dot11f_unpack_ie_addba_extn_element(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEaddba_extn_element *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEaddba_extn_element) *
						    countOffset),
						    append_ie);
					break;
				case SigIebss_color_change:
					status |=
						dot11f_unpack_ie_bss_color_change(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEbss_color_change *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEbss_color_change) *
						    countOffset),
						    append_ie);
					break;
				case SigIedecriptor_element:
					status |=
						dot11f_unpack_ie_decriptor_element(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEdecriptor_element *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEdecriptor_element) *
						    countOffset),
						    append_ie);
					break;
				case SigIedh_parameter_element:
					status |=
						dot11f_unpack_ie_dh_parameter_element(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEdh_parameter_element *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEdh_parameter_element) *
						    countOffset),
						    append_ie);
					break;
				case SigIeesp_information:
					status |=
						dot11f_unpack_ie_esp_information(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEesp_information *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEesp_information) *
						    countOffset),
						    append_ie);
					break;
				case SigIeext_chan_switch_ann:
					status |=
						dot11f_unpack_ie_ext_chan_switch_ann(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEext_chan_switch_ann *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEext_chan_switch_ann) *
						    countOffset),
						    append_ie);
					break;
				case SigIefils_assoc_delay_info:
					status |=
						dot11f_unpack_ie_fils_assoc_delay_info(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEfils_assoc_delay_info *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEfils_assoc_delay_info) *
						    countOffset),
						    append_ie);
					break;
				case SigIefils_hlp_container:
					status |=
						dot11f_unpack_ie_fils_hlp_container(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEfils_hlp_container *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEfils_hlp_container) *
						    countOffset),
						    append_ie);
					break;
				case SigIefils_indication:
					status |=
						dot11f_unpack_ie_fils_indication(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEfils_indication *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEfils_indication) *
						    countOffset),
						    append_ie);
					break;
				case SigIefils_kde:
					status |=
						dot11f_unpack_ie_fils_kde(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEfils_kde *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEfils_kde) *
						    countOffset),
						    append_ie);
					break;
				case SigIefils_key_confirmation:
					status |=
						dot11f_unpack_ie_fils_key_confirmation(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEfils_key_confirmation *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEfils_key_confirmation) *
						    countOffset),
						    append_ie);
					break;
				case SigIefils_nonce:
					status |=
						dot11f_unpack_ie_fils_nonce(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEfils_nonce *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEfils_nonce) *
						    countOffset),
						    append_ie);
					break;
				case SigIefils_public_key:
					status |=
						dot11f_unpack_ie_fils_public_key(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEfils_public_key *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEfils_public_key) *
						    countOffset),
						    append_ie);
					break;
				case SigIefils_session:
					status |=
						dot11f_unpack_ie_fils_session(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEfils_session *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEfils_session) *
						    countOffset),
						    append_ie);
					break;
				case SigIefils_wrapped_data:
					status |=
						dot11f_unpack_ie_fils_wrapped_data(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEfils_wrapped_data *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEfils_wrapped_data) *
						    countOffset),
						    append_ie);
					break;
				case SigIefragment_ie:
					status |=
						dot11f_unpack_ie_fragment_ie(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEfragment_ie *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEfragment_ie) *
						    countOffset),
						    append_ie);
					break;
				case SigIehe_6ghz_band_cap:
					status |=
						dot11f_unpack_ie_he_6ghz_band_cap(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEhe_6ghz_band_cap *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEhe_6ghz_band_cap) *
						    countOffset),
						    append_ie);
					break;
				case SigIehe_cap:
					status |=
						dot11f_unpack_ie_he_cap(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEhe_cap *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEhe_cap) *
						    countOffset),
						    append_ie);
					break;
				case SigIehe_op:
					status |=
						dot11f_unpack_ie_he_op(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEhe_op *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEhe_op) *
						    countOffset),
						    append_ie);
					break;
				case SigIehs20vendor_ie:
					status |=
						dot11f_unpack_ie_hs20vendor_ie(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEhs20vendor_ie *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEhs20vendor_ie) *
						    countOffset),
						    append_ie);
					break;
				case SigIeht2040_bss_coexistence:
					status |=
						dot11f_unpack_ie_ht2040_bss_coexistence(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEht2040_bss_coexistence *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEht2040_bss_coexistence) *
						    countOffset),
						    append_ie);
					break;
				case SigIeht2040_bss_intolerant_report:
					status |=
						dot11f_unpack_ie_ht2040_bss_intolerant_report(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEht2040_bss_intolerant_report *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEht2040_bss_intolerant_report) *
						    countOffset),
						    append_ie);
					break;
				case SigIemu_edca_param_set:
					status |=
						dot11f_unpack_ie_mu_edca_param_set(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEmu_edca_param_set *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEmu_edca_param_set) *
						    countOffset),
						    append_ie);
					break;
				case SigIeoci:
					status |=
						dot11f_unpack_ie_oci(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEoci *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEoci) *
						    countOffset),
						    append_ie);
					break;
				case SigIeosen_ie:
					status |=
						dot11f_unpack_ie_osen_ie(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEosen_ie *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEosen_ie) *
						    countOffset),
						    append_ie);
					break;
				case SigIeqcn_ie:
					status |=
						dot11f_unpack_ie_qcn_ie(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEqcn_ie *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEqcn_ie) *
						    countOffset),
						    append_ie);
					break;
				case SigIeroaming_consortium_sel:
					status |=
						dot11f_unpack_ie_roaming_consortium_sel(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEroaming_consortium_sel *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEroaming_consortium_sel) *
						    countOffset),
						    append_ie);
					break;
				case SigIesec_chan_offset_ele:
					status |=
						dot11f_unpack_ie_sec_chan_offset_ele(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEsec_chan_offset_ele *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEsec_chan_offset_ele) *
						    countOffset),
						    append_ie);
					break;
				case SigIevendor_vht_ie:
					status |=
						dot11f_unpack_ie_vendor_vht_ie(
						    pCtx, pBufRemaining, len,
						    (tDot11fIEvendor_vht_ie *)
						    (pFrm + pIe->offset +
						    sizeof(tDot11fIEvendor_vht_ie) *
						    countOffset),
						    append_ie);
					break;
				default:
					FRAMES_LOG1(pCtx, FRLOGE, FRFL("INTERNAL ERROR"
						     ": I don't know about the IE signature %d"
						     "-- this is most likely a 'framesc' bug.\n"),
						     pIe->sig);
					FRAMES_DBG_BREAK();
					return DOT11F_INTERNAL_ERROR;
				}
				if (pIe->arraybound)
					(++(*(uint16_t *)(pFrm + pIe->countOffset)));
			}
		} else {
			FRAMES_LOG3(pCtx, FRLOG3, FRFL("Skipping unknown IE %d extn ID %d"
				     " (length %d)\n"), eid, extn_eid, len);
			FRAMES_DUMP(pCtx, FRLOG3, pBufRemaining - 2, len);
			status |= DOT11F_UNKNOWN_IES;
		}

skip_ie:
		pBufRemaining += len;

		if (len > nBufRemaining) {
			FRAMES_LOG0(pCtx, FRLOGW, FRFL("This IE extends past "
				     "the buffer as it was defined to us.  This could"
				     "mean a corrupt frame, or just an incorrect leng"
				     "th parameter.\n"));
			FRAMES_DBG_BREAK();
			status |= DOT11F_LAST_IE_TOO_LONG;
			goto MandatoryCheck;
		}

		nBufRemaining -= len;

	}

MandatoryCheck:
	pIe = &IEs[0];
	while (0xff != pIe->eid || pIe->extn_eid) {
		if (pIe->fMandatory) {
			pfFound = (tFRAMES_BOOL *)(pFrm + pIe->offset +
						     pIe->presenceOffset);
			if (!*pfFound) {
				FRAMES_LOG1(pCtx, FRLOGW, FRFL("ERROR: The mandato"
					     "ry IE %s wasn't seen.\n"),
					     pIe->name);
				FRAMES_DBG_BREAK();
				status |= DOT11F_MANDATORY_IE_MISSING;
			}
		}
		++pIe;
	}

	return status;
} /* End unpack_core. */

static uint32_t unpack_tlv_core(tpAniSirGlobal   pCtx,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  const tTLVDefn TLVs[],
				  uint8_t *pFrm,
				  size_t nFrm)
{
	const tTLVDefn *pTlv;
	uint32_t      nBufRemaining, status, npec;
	uint16_t      id, len;
	uint8_t      *pBufRemaining, *pfFound;

	(void)pCtx;                 /* Shutup the compiler */
	(void)nFrm;
	status = DOT11F_PARSE_SUCCESS;
	pBufRemaining = pBuf;
	nBufRemaining = nBuf;

	/* While we have data... */
	while (nBufRemaining) {
		if (3 > nBufRemaining) {
			FRAMES_LOG0(pCtx, FRLOGE, FRFL("This frame reports "
				     "fewer three byte(s) remaining.\n"));
			status |= DOT11F_INCOMPLETE_TLV;
			FRAMES_DBG_BREAK();
			goto MandatoryCheck;
		}

		npec = 0U;

		/* Look for a matching TLV definition, */
		pTlv = find_tlv_defn(pCtx, pBufRemaining, nBufRemaining, TLVs);
		/* consume the type, */
		if (pTlv) {
			if (pTlv->sType == 2) {
				framesntohs(pCtx, &id, pBufRemaining, pTlv->fMsb);
				pBufRemaining += 2;
				nBufRemaining -= 2;
			} else {
				id = *pBufRemaining;
				pBufRemaining += 1;
				nBufRemaining -= 1;
			}
			/* & length, */
			if (pTlv->sLen == 2) {
				if (2 > nBufRemaining) {
					FRAMES_LOG0(pCtx, FRLOGE, FRFL("This frame reports "
							"fewer two byte(s) remaining.\n"));
					status |= DOT11F_INCOMPLETE_TLV;
					FRAMES_DBG_BREAK();
					goto MandatoryCheck;
				}
				framesntohs(pCtx, &len, pBufRemaining, pTlv->fMsb);
				pBufRemaining += 2;
				nBufRemaining -= 2;
			} else {
				len = *pBufRemaining;
				pBufRemaining += 1;
				nBufRemaining -= 1;
			}
		} else {
			if (TLVs[0].sType > nBufRemaining) {
				FRAMES_LOG0(pCtx, FRLOGE, FRFL("This frame reports "
					     "fewer LVs[0].sType byte(s) remaining.\n"));
				status |= DOT11F_INCOMPLETE_TLV;
				goto MandatoryCheck;
			}
			pBufRemaining += TLVs[0].sType;
			nBufRemaining -= TLVs[0].sType;
			if (2 > nBufRemaining) {
				FRAMES_LOG0(pCtx, FRLOGE, FRFL("This frame reports "
					     "fewer two byte(s) remaining.\n"));
				status |= DOT11F_INCOMPLETE_TLV;
				FRAMES_DBG_BREAK();
				goto MandatoryCheck;
			}
			framesntohs(pCtx, &len, pBufRemaining, (TLVs[0].sType == 2));
			pBufRemaining += 2;
			nBufRemaining -= 2;
		}

		if (pTlv && pTlv->pec) {
		npec = 3U;
			if (3 > nBufRemaining) {
				FRAMES_LOG2(pCtx, FRLOGW, FRFL("TLV %d reports length"
				    "%d, but it has a Private Enterprise Code (3 byte"
				    "s.\n"), id, len);
				FRAMES_DUMP(pCtx, FRLOG1, pBuf, nBuf);
				FRAMES_LOG2(pCtx, FRLOG1, FRFL("We've parsed %d bytes"
				    "of this buffer, and show %d left.\n"),
				pBufRemaining - pBuf, nBufRemaining);
				status |= DOT11F_INCOMPLETE_TLV;
				FRAMES_DBG_BREAK();
				goto MandatoryCheck;
			}
		pBufRemaining += 3;
		nBufRemaining -= 3;
		len           -= 3;
		}

		/* Whether we found a hit or not, we can validate the reported */
		/* length of this TLV: */
		if (len > nBufRemaining) {
			FRAMES_LOG3(pCtx, FRLOGW, FRFL("TLV %d reports length %"
			    "d, but there are only %d bytes remaining in this f"
			    "rame.\n"), id, len, nBufRemaining);
			FRAMES_DUMP(pCtx, FRLOG1, pBuf, nBuf);
			FRAMES_LOG2(pCtx, FRLOG1, FRFL("We've parsed %d bytes"
			    " of this buffer, and show %d left.\n"),
			    pBufRemaining - pBuf, nBufRemaining);
			status |= DOT11F_INCOMPLETE_TLV;
			FRAMES_DBG_BREAK();
			goto MandatoryCheck;
		}

		/* Now, *if* we found a hit... */
		if (pTlv) {
			if (len + (pTlv->sType + pTlv->sLen) < pTlv->minSize - npec) {
				FRAMES_LOG3(pCtx, FRLOGW, FRFL("The IE %s must be "
				    "at least %d bytes in size, but the size is only "
				    "%d bytes.\n"),
				     pTlv->name, pTlv->minSize, len);
				FRAMES_DUMP(pCtx, FRLOG1, pBuf, nBuf);
				status |= DOT11F_INCOMPLETE_TLV;
				FRAMES_DBG_BREAK();
				goto MandatoryCheck;
			}
			if (nBufRemaining < pTlv->minSize - npec - (pTlv->sType + pTlv->sLen)) {
				FRAMES_LOG3(pCtx, FRLOGW, FRFL("The IE %s must be "
				    "at least %d bytes in size, but there are only "
				    "%d bytes remaining in this frame.\n"),
				     pTlv->name, pTlv->minSize, nBufRemaining);
				FRAMES_DUMP(pCtx, FRLOG1, pBuf, nBuf);
				status |= DOT11F_INCOMPLETE_TLV;
				FRAMES_DBG_BREAK();
				goto MandatoryCheck;
			} else if (len > pTlv->maxSize - npec - (pTlv->sType + pTlv->sLen)) {
				FRAMES_LOG1(pCtx, FRLOGW, FRFL("The TLV %s reports "
				    "an illegally large size; this TLV is presumably"
				    "corrupt or otherwise invalid & will be skipped "
				    "ipped.\n"), pTlv->name);
				FRAMES_DUMP(pCtx, FRLOG1, pBuf, nBuf);
				FRAMES_LOG2(pCtx, FRLOG1, FRFL("We've parsed %d by"
				    "tes of this buffer, and show %d left.\n"),
				    pBufRemaining - pBuf, nBufRemaining);
				FRAMES_DBG_BREAK();
				status |= DOT11F_SKIPPED_BAD_TLV;
			} else {
				switch (pTlv->sig) {
				case SigTlvAuthorizedMACs:
					status |=
						dot11f_unpack_tlv_authorized_ma_cs(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVAuthorizedMACs *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvRequestToEnroll:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVRequestToEnroll *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVRequestToEnroll *)
						  (pFrm + pTlv->offset))->req));
					break;
				case SigTlvVersion2:
					status |=
						dot11f_unpack_tlv_version2(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVVersion2 *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvAPSetupLocked:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVAPSetupLocked *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVAPSetupLocked *)
						  (pFrm + pTlv->offset))->fLocked));
					break;
				case SigTlvAssociationState:
					status |=
						dot11f_unpack_tlv_common_func2(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVAssociationState *)
						  (pFrm + pTlv->offset))->present),
						  (uint16_t *)&(((tDot11fTLVAssociationState *)
						  (pFrm + pTlv->offset))->state));
					break;
				case SigTlvConfigMethods:
					status |=
						dot11f_unpack_tlv_common_func2(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVConfigMethods *)
						  (pFrm + pTlv->offset))->present),
						  (uint16_t *)&(((tDot11fTLVConfigMethods *)
						  (pFrm + pTlv->offset))->methods));
					break;
				case SigTlvConfigurationError:
					status |=
						dot11f_unpack_tlv_common_func2(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVConfigurationError *)
						  (pFrm + pTlv->offset))->present),
						  (uint16_t *)&(((tDot11fTLVConfigurationError *)
						  (pFrm + pTlv->offset))->error));
					break;
				case SigTlvDeviceName:
					status |=
						dot11f_unpack_tlv_device_name(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVDeviceName *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvDevicePasswordID:
					status |=
						dot11f_unpack_tlv_common_func2(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVDevicePasswordID *)
						  (pFrm + pTlv->offset))->present),
						  (uint16_t *)&(((tDot11fTLVDevicePasswordID *)
						  (pFrm + pTlv->offset))->id));
					break;
				case SigTlvExtendedListenTiming:
					status |=
						dot11f_unpack_tlv_extended_listen_timing(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVExtendedListenTiming *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvListenChannel:
					status |=
						dot11f_unpack_tlv_listen_channel(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVListenChannel *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvManufacturer:
					status |=
						dot11f_unpack_tlv_manufacturer(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVManufacturer *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvMinorReasonCode:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVMinorReasonCode *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVMinorReasonCode *)
						  (pFrm + pTlv->offset))->minorReasonCode));
					break;
				case SigTlvModelName:
					status |=
						dot11f_unpack_tlv_model_name(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVModelName *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvModelNumber:
					status |=
						dot11f_unpack_tlv_model_number(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVModelNumber *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvNoticeOfAbsence:
					status |=
						dot11f_unpack_tlv_notice_of_absence(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVNoticeOfAbsence *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvOperatingChannel:
					status |=
						dot11f_unpack_tlv_operating_channel(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVOperatingChannel *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvP2PCapability:
					status |=
						dot11f_unpack_tlv_p2_p_capability(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVP2PCapability *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvP2PDeviceId:
					status |=
						dot11f_unpack_tlv_p2_p_device_id(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVP2PDeviceId *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvP2PDeviceInfo:
					status |=
						dot11f_unpack_tlv_p2_p_device_info(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVP2PDeviceInfo *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvP2PGroupInfo:
					status |=
						dot11f_unpack_tlv_p2_p_group_info(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVP2PGroupInfo *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvP2PStatus:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVP2PStatus *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVP2PStatus *)
						  (pFrm + pTlv->offset))->status));
					break;
				case SigTlvPrimaryDeviceType:
					status |=
						dot11f_unpack_tlv_primary_device_type(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVPrimaryDeviceType *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvRFBands:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVRFBands *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVRFBands *)
						  (pFrm + pTlv->offset))->bands));
					break;
				case SigTlvRequestDeviceType:
					status |=
						dot11f_unpack_tlv_request_device_type(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVRequestDeviceType *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvRequestType:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVRequestType *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVRequestType *)
						  (pFrm + pTlv->offset))->reqType));
					break;
				case SigTlvResponseType:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVResponseType *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVResponseType *)
						  (pFrm + pTlv->offset))->resType));
					break;
				case SigTlvSelectedRegistrar:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVSelectedRegistrar *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVSelectedRegistrar *)
						  (pFrm + pTlv->offset))->selected));
					break;
				case SigTlvSelectedRegistrarConfigMethods:
					status |=
						dot11f_unpack_tlv_common_func2(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVSelectedRegistrarConfigMethods *)
						  (pFrm + pTlv->offset))->present),
						  (uint16_t *)&(((tDot11fTLVSelectedRegistrarConfigMethods *)
						  (pFrm + pTlv->offset))->methods));
					break;
				case SigTlvSerialNumber:
					status |=
						dot11f_unpack_tlv_serial_number(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVSerialNumber *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvUUID_E:
					status |=
						dot11f_unpack_tlv_uuid_e(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVUUID_E *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvUUID_R:
					status |=
						dot11f_unpack_tlv_uuid_r(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVUUID_R *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvVendorExtension:
					status |=
						dot11f_unpack_tlv_vendor_extension(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVVendorExtension *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvVersion:
					status |=
						dot11f_unpack_tlv_version(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVVersion *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvWPSState:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVWPSState *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVWPSState *)
						  (pFrm + pTlv->offset))->state));
					break;
				case SigTlvassoc_disallowed:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVassoc_disallowed *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVassoc_disallowed *)
						  (pFrm + pTlv->offset))->reason_code));
					break;
				case SigTlvassoc_retry_delay:
					status |=
						dot11f_unpack_tlv_common_func2(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVassoc_retry_delay *)
						  (pFrm + pTlv->offset))->present),
						  (uint16_t *)&(((tDot11fTLVassoc_retry_delay *)
						  (pFrm + pTlv->offset))->delay));
					break;
				case SigTlvcellular_data_cap:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVcellular_data_cap *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVcellular_data_cap *)
						  (pFrm + pTlv->offset))->cellular_connectivity));
					break;
				case SigTlvcellular_data_con_pref:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVcellular_data_con_pref *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVcellular_data_con_pref *)
						  (pFrm + pTlv->offset))->cellular_preference));
					break;
				case SigTlvhe_2xltf_160mhz_supp:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVhe_2xltf_160mhz_supp *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVhe_2xltf_160mhz_supp *)
						  (pFrm + pTlv->offset))->he_2xltf_160MHz_supp));
					break;
				case SigTlvhe_400ns_sgi_attr:
					status |=
						dot11f_unpack_tlv_he_400ns_sgi_attr(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVhe_400ns_sgi_attr *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvhe_dl_mumimo_attr:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVhe_dl_mumimo_attr *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVhe_dl_mumimo_attr *)
						  (pFrm + pTlv->offset))->he_dl_mumimo_supp));
					break;
				case SigTlvhe_dl_ofdma_attr:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVhe_dl_ofdma_attr *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVhe_dl_ofdma_attr *)
						  (pFrm + pTlv->offset))->he_dl_ofdma_supp));
					break;
				case SigTlvhe_mcs13_attr:
					status |=
						dot11f_unpack_tlv_he_mcs13_attr(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVhe_mcs13_attr *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvmbo_ap_cap:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVmbo_ap_cap *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVmbo_ap_cap *)
						  (pFrm + pTlv->offset))->mbo_cap_ind));
					break;
				case SigTlvnon_prefferd_chan_rep:
					status |=
						dot11f_unpack_tlv_non_prefferd_chan_rep(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVnon_prefferd_chan_rep *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvoce_cap:
					status |=
						dot11f_unpack_tlv_oce_cap(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVoce_cap *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvqcn_version:
					status |=
						dot11f_unpack_tlv_qcn_version(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVqcn_version *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvreduced_wan_metrics:
					status |=
						dot11f_unpack_tlv_reduced_wan_metrics(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVreduced_wan_metrics *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvrssi_assoc_rej:
					status |=
						dot11f_unpack_tlv_rssi_assoc_rej(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVrssi_assoc_rej *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvtrans_reasonp_attr:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVtrans_reasonp_attr *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVtrans_reasonp_attr *)
						  (pFrm + pTlv->offset))->transition_reasonp));
					break;
				case SigTlvtrans_rejectp_attr:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVtrans_rejectp_attr *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVtrans_rejectp_attr *)
						  (pFrm + pTlv->offset))->transition_rejp));
					break;
				case SigTlvtransition_reason:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVtransition_reason *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVtransition_reason *)
						  (pFrm + pTlv->offset))->transition_reason_code));
					break;
				case SigTlvtransition_reject_reason:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVtransition_reject_reason *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVtransition_reject_reason *)
						  (pFrm + pTlv->offset))->transition_reject_code));
					break;
				case SigTlvvht_mcs11_attr:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVvht_mcs11_attr *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVvht_mcs11_attr *)
						  (pFrm + pTlv->offset))->vht_mcs_10_11_supp));
					break;
				case SigTlvP2PInterface:
					status |=
						dot11f_unpack_tlv_p2_p_interface(pCtx,
						  pBufRemaining, len,
						  (tDot11fTLVP2PInterface *)
						  (pFrm + pTlv->offset));
					break;
				case SigTlvP2PManageability:
					status |=
						dot11f_unpack_tlv_common_func(pCtx,
						  pBufRemaining, len,
						  (uint8_t *)&(((tDot11fTLVP2PManageability *)
						  (pFrm + pTlv->offset))->present),
						  (uint8_t *)&(((tDot11fTLVP2PManageability *)
						  (pFrm + pTlv->offset))->manageability));
					break;
				default:
					FRAMES_LOG1(pCtx, FRLOGE, FRFL("INTERNAL ERROR: I"
					    " don't know about the TLV signature %d-- thi"
					    "s is most likely a 'framesc' bug.\n"),
					    pTlv->sig);
					FRAMES_DBG_BREAK();
					return DOT11F_INTERNAL_ERROR;
				} /* End switch on sig. */
			} /* End if on length check. */

		} else {
			FRAMES_LOG2(pCtx, FRLOG3, FRFL("Skipping unknown TLV %d ("
			    "length %d)\n"), id, len);
			FRAMES_DUMP(pCtx, FRLOG3, pBufRemaining - (pTlv->sType + pTlv->sLen), len);
			status |= DOT11F_UNKNOWN_TLVS;
		}

		/* Advance to the next TLV */
		pBufRemaining += len;

		if (len > nBufRemaining) {
			FRAMES_LOG0(pCtx, FRLOGW, FRFL("This TLV extends past th"
			    "e buffer as it was defined to us.  This could mean "
			    "a corrupt frame, or just an incorrect length parame"
			    "ter.\n"));
			FRAMES_DBG_BREAK();
			status |= DOT11F_LAST_TLV_TOO_LONG;
			goto MandatoryCheck;
		}

		nBufRemaining -= len;

	} /* End iteration over TLVs.*/

MandatoryCheck:
	pTlv = &TLVs[0];
	while (0xffff != pTlv->id) {
		if (pTlv->fMandatory) {
			pfFound = (uint8_t *)(pFrm + pTlv->offset +
					     pTlv->presenceOffset);
			if (!*pfFound) {
				FRAMES_LOG1(pCtx, FRLOGW, FRFL("ERROR: The mandatory "
				    "TLV %s wasn't seen.\n"),
				    pTlv->name);
				FRAMES_DBG_BREAK();
				status |= DOT11F_MANDATORY_TLV_MISSING;
			}

		}
		++pTlv;
	}

	return status;
} /* End UnpacTlvkCore. */
uint32_t dot11f_get_packed_ietclas(tpAniSirGlobal pCtx,
	tDot11fIETCLAS *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 1;
		*pnNeeded += 1;
		*pnNeeded += 1;
		switch (pIe->classifier_type) {
		case 0:
			*pnNeeded += 6;
			*pnNeeded += 6;
			*pnNeeded += 2;
			break;
		case 1:
			*pnNeeded += 1;
			switch (pIe->info.IpParams.version) {
			case 4:
				*pnNeeded += 4;
				*pnNeeded += 4;
				*pnNeeded += 2;
				*pnNeeded += 2;
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				break;
			case 6:
				*pnNeeded += 16;
				*pnNeeded += 16;
				*pnNeeded += 2;
				*pnNeeded += 2;
				*pnNeeded += 3;
				break;
			}
			break;
		case 2:
			*pnNeeded += 2;
			break;
		}
		break;
	}
	return status;
} /* End dot11f_get_packed_ietclas. */

uint32_t dot11f_get_packed_iewmmtclas(tpAniSirGlobal pCtx,
	tDot11fIEWMMTCLAS *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 1;
		*pnNeeded += 1;
		*pnNeeded += 1;
		*pnNeeded += 1;
		switch (pIe->classifier_type) {
		case 0:
			*pnNeeded += 6;
			*pnNeeded += 6;
			*pnNeeded += 2;
			break;
		case 1:
			*pnNeeded += 1;
			switch (pIe->info.IpParams.version) {
			case 4:
				*pnNeeded += 4;
				*pnNeeded += 4;
				*pnNeeded += 2;
				*pnNeeded += 2;
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				break;
			case 6:
				*pnNeeded += 16;
				*pnNeeded += 16;
				*pnNeeded += 2;
				*pnNeeded += 2;
				*pnNeeded += 3;
				break;
			}
			break;
		case 2:
			*pnNeeded += 2;
			break;
		}
		break;
	}
	return status;
} /* End dot11f_get_packed_iewmmtclas. */

uint32_t dot11f_get_packed_ie_neighbor_rpt(tpAniSirGlobal pCtx,
	tDot11fIEneighbor_rpt *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 6;
		*pnNeeded += 1;
		*pnNeeded += 1;
		*pnNeeded += 2;
		*pnNeeded += 1;
		*pnNeeded += 1;
		*pnNeeded += 1;
		status = get_packed_size_core(pCtx, (uint8_t *)pIe, pnNeeded,
				IES_neighbor_rpt);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_neighbor_rpt. */

uint32_t dot11f_get_packed_ie_tclas_mask(tpAniSirGlobal pCtx,
	tDot11fIEtclas_mask *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 1;
		*pnNeeded += 1;
		switch (pIe->classifier_type) {
		case 4:
			*pnNeeded += 16;
			break;
		}
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_tclas_mask. */

uint32_t dot11f_get_packed_ie_channel_switch_wrapper(tpAniSirGlobal pCtx,
	tDot11fIEChannelSwitchWrapper *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_core(pCtx, (uint8_t *)pIe, pnNeeded,
				IES_ChannelSwitchWrapper);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_channel_switch_wrapper. */

uint32_t dot11f_get_packed_ie_country(tpAniSirGlobal pCtx,
	tDot11fIECountry *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 3;
		*pnNeeded += 3;
		if (pIe->num_more_triplets) {
			*pnNeeded += (pIe->num_more_triplets * 3);
		} else {
			break;
		}
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_country. */

uint32_t dot11f_get_packed_ieft_info(tpAniSirGlobal pCtx,
	tDot11fIEFTInfo *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 2;
		*pnNeeded += 16;
		*pnNeeded += 32;
		*pnNeeded += 32;
		status = get_packed_size_core(pCtx, (uint8_t *)pIe, pnNeeded,
				IES_FTInfo);
		break;
	}
	return status;
} /* End dot11f_get_packed_ieft_info. */

uint32_t dot11f_get_packed_ie_MBO_IE(tpAniSirGlobal pCtx,
	tDot11fIEMBO_IE *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_MBO_IE);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_MBO_IE. */

uint32_t dot11f_get_packed_ie_measurement_report(tpAniSirGlobal pCtx,
	tDot11fIEMeasurementReport *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 1;
		*pnNeeded += 1;
		*pnNeeded += 1;
		if (pIe->type) {
			switch (pIe->type) {
			case 0:
				*pnNeeded += 1;
				*pnNeeded += 8;
				*pnNeeded += 2;
				*pnNeeded += 1;
				break;
			case 1:
				*pnNeeded += 1;
				*pnNeeded += 8;
				*pnNeeded += 2;
				*pnNeeded += 1;
				break;
			case 2:
				*pnNeeded += 1;
				*pnNeeded += 8;
				*pnNeeded += 2;
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				break;
			case 5:
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 8;
				*pnNeeded += 2;
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 6;
				*pnNeeded += 1;
				*pnNeeded += 4;
				status = get_packed_size_core(pCtx, (uint8_t *)pIe, pnNeeded, IES_reportBeacon);
				break;
			}
		} else {
			break;
		}
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_measurement_report. */

uint32_t dot11f_get_packed_ie_measurement_request(tpAniSirGlobal pCtx,
	tDot11fIEMeasurementRequest *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 1;
		*pnNeeded += 1;
		*pnNeeded += 1;
		switch (pIe->measurement_type) {
		case 0:
			*pnNeeded += 1;
			*pnNeeded += 8;
			*pnNeeded += 2;
			break;
		case 1:
			*pnNeeded += 1;
			*pnNeeded += 8;
			*pnNeeded += 2;
			break;
		case 2:
			*pnNeeded += 1;
			*pnNeeded += 8;
			*pnNeeded += 2;
			break;
		case 5:
			*pnNeeded += 1;
			*pnNeeded += 1;
			*pnNeeded += 2;
			*pnNeeded += 2;
			*pnNeeded += 1;
			*pnNeeded += 6;
			status = get_packed_size_core(pCtx, (uint8_t *)pIe, pnNeeded, IES_measurement_requestBeacon);
			break;
		case 8:
			*pnNeeded += 1;
			status = get_packed_size_core(pCtx, (uint8_t *)pIe, pnNeeded, IES_measurement_requestlci);
			break;
		case 16:
			*pnNeeded += 2;
			*pnNeeded += 1;
			status = get_packed_size_core(pCtx, (uint8_t *)pIe, pnNeeded, IES_measurement_requestftmrr);
			break;
		}
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_measurement_request. */

uint32_t dot11f_get_packed_ie_neighbor_report(tpAniSirGlobal pCtx,
	tDot11fIENeighborReport *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 6;
		*pnNeeded += 1;
		*pnNeeded += 1;
		*pnNeeded += 2;
		*pnNeeded += 1;
		*pnNeeded += 1;
		*pnNeeded += 1;
		status = get_packed_size_core(pCtx, (uint8_t *)pIe, pnNeeded,
				IES_NeighborReport);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_neighbor_report. */

uint32_t dot11f_get_packed_iep2_p_assoc_req(tpAniSirGlobal pCtx,
	tDot11fIEP2PAssocReq *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_P2PAssocReq);
		break;
	}
	return status;
} /* End dot11f_get_packed_iep2_p_assoc_req. */

uint32_t dot11f_get_packed_iep2_p_assoc_res(tpAniSirGlobal pCtx,
	tDot11fIEP2PAssocRes *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_P2PAssocRes);
		break;
	}
	return status;
} /* End dot11f_get_packed_iep2_p_assoc_res. */

uint32_t dot11f_get_packed_iep2_p_beacon(tpAniSirGlobal pCtx,
	tDot11fIEP2PBeacon *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_P2PBeacon);
		break;
	}
	return status;
} /* End dot11f_get_packed_iep2_p_beacon. */

uint32_t dot11f_get_packed_iep2_p_beacon_probe_res(tpAniSirGlobal pCtx,
	tDot11fIEP2PBeaconProbeRes *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_P2PBeaconProbeRes);
		break;
	}
	return status;
} /* End dot11f_get_packed_iep2_p_beacon_probe_res. */

uint32_t dot11f_get_packed_iep2_p_de_auth(tpAniSirGlobal pCtx,
	tDot11fIEP2PDeAuth *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_P2PDeAuth);
		break;
	}
	return status;
} /* End dot11f_get_packed_iep2_p_de_auth. */

uint32_t dot11f_get_packed_iep2_p_dis_assoc(tpAniSirGlobal pCtx,
	tDot11fIEP2PDisAssoc *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_P2PDisAssoc);
		break;
	}
	return status;
} /* End dot11f_get_packed_iep2_p_dis_assoc. */

uint32_t dot11f_get_packed_iep2_p_probe_req(tpAniSirGlobal pCtx,
	tDot11fIEP2PProbeReq *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_P2PProbeReq);
		break;
	}
	return status;
} /* End dot11f_get_packed_iep2_p_probe_req. */

uint32_t dot11f_get_packed_iep2_p_probe_res(tpAniSirGlobal pCtx,
	tDot11fIEP2PProbeRes *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_P2PProbeRes);
		break;
	}
	return status;
} /* End dot11f_get_packed_iep2_p_probe_res. */

uint32_t dot11f_get_packed_ieric_data_desc(tpAniSirGlobal pCtx,
	tDot11fIERICDataDesc *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_core(pCtx, (uint8_t *)pIe, pnNeeded,
				IES_RICDataDesc);
		break;
	}
	return status;
} /* End dot11f_get_packed_ieric_data_desc. */

uint32_t dot11f_get_packed_iersn(tpAniSirGlobal pCtx,
	tDot11fIERSN *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 2;
		if (pIe->gp_cipher_suite_present) {

			*pnNeeded += 4;
		} else {
			break;
		}
		if (pIe->pwise_cipher_suite_count) {
			*pnNeeded += 2;
		} else {
			break;
		}
		*pnNeeded += (pIe->pwise_cipher_suite_count * 4);
		if (pIe->akm_suite_cnt) {
			*pnNeeded += 2;
		} else {
			break;
		}
		*pnNeeded += (pIe->akm_suite_cnt * 4);
		if (pIe->RSN_Cap_present) {

			*pnNeeded += 2;
		} else {
			break;
		}
		if (pIe->pmkid_count) {
			*pnNeeded += 2;
		} else {
			if (pIe->gp_mgmt_cipher_suite_present) {
				*pnNeeded += 2;
			}
		}
		*pnNeeded += (pIe->pmkid_count * 16);
		if (pIe->gp_mgmt_cipher_suite_present) {

			*pnNeeded += 4;
		} else {
			break;
		}
		break;
	}
	return status;
} /* End dot11f_get_packed_iersn. */

uint32_t dot11f_get_packed_iewapi(tpAniSirGlobal pCtx,
	tDot11fIEWAPI *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 2;
		*pnNeeded += 2;
		*pnNeeded += (pIe->akm_suite_count * 4);
		*pnNeeded += 2;
		*pnNeeded += (pIe->unicast_cipher_suite_count * 4);
		*pnNeeded += 4;
		*pnNeeded += 2;
		if (pIe->bkid_count) {
			*pnNeeded += 2;
		} else {
			break;
		}
		*pnNeeded += (pIe->bkid_count * 16);
		break;
	}
	return status;
} /* End dot11f_get_packed_iewapi. */

uint32_t dot11f_get_packed_iewpa(tpAniSirGlobal pCtx,
	tDot11fIEWPA *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 2;
		if (pIe->multicast_cipher_present) {

			*pnNeeded += 4;
		} else {
			break;
		}
		if (pIe->unicast_cipher_count) {
			*pnNeeded += 2;
		} else {
			break;
		}
		*pnNeeded += (pIe->unicast_cipher_count * 4);
		if (pIe->auth_suite_count) {
			*pnNeeded += 2;
		} else {
			break;
		}
		*pnNeeded += (pIe->auth_suite_count * 4);
		if (pIe->caps) {
			*pnNeeded += 2;
		} else {
			break;
		}
		break;
	}
	return status;
} /* End dot11f_get_packed_iewpa. */

uint32_t dot11f_get_packed_iewsc(tpAniSirGlobal pCtx,
	tDot11fIEWSC *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_WSC);
		break;
	}
	return status;
} /* End dot11f_get_packed_iewsc. */

uint32_t dot11f_get_packed_ie_wsc_assoc_req(tpAniSirGlobal pCtx,
	tDot11fIEWscAssocReq *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_WscAssocReq);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_wsc_assoc_req. */

uint32_t dot11f_get_packed_ie_wsc_assoc_res(tpAniSirGlobal pCtx,
	tDot11fIEWscAssocRes *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_WscAssocRes);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_wsc_assoc_res. */

uint32_t dot11f_get_packed_ie_wsc_beacon(tpAniSirGlobal pCtx,
	tDot11fIEWscBeacon *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_WscBeacon);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_wsc_beacon. */

uint32_t dot11f_get_packed_ie_wsc_beacon_probe_res(tpAniSirGlobal pCtx,
	tDot11fIEWscBeaconProbeRes *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_WscBeaconProbeRes);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_wsc_beacon_probe_res. */

uint32_t dot11f_get_packed_ie_wsc_probe_req(tpAniSirGlobal pCtx,
	tDot11fIEWscProbeReq *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_WscProbeReq);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_wsc_probe_req. */

uint32_t dot11f_get_packed_ie_wsc_probe_res(tpAniSirGlobal pCtx,
	tDot11fIEWscProbeRes *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_WscProbeRes);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_wsc_probe_res. */

uint32_t dot11f_get_packed_ie_wsc_reassoc_res(tpAniSirGlobal pCtx,
	tDot11fIEWscReassocRes *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_WscReassocRes);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_wsc_reassoc_res. */

uint32_t dot11f_get_packed_ie_decriptor_element(tpAniSirGlobal pCtx,
	tDot11fIEdecriptor_element *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 1;
		*pnNeeded += 2;
		*pnNeeded += 4;
		status = get_packed_size_core(pCtx, (uint8_t *)pIe, pnNeeded,
				IES_decriptor_element);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_decriptor_element. */

uint32_t dot11f_get_packed_ie_he_cap(tpAniSirGlobal pCtx,
	tDot11fIEhe_cap *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 4;
		*pnNeeded += 2;
		*pnNeeded += 4;
		*pnNeeded += 4;
		*pnNeeded += 2;
		*pnNeeded += 1;
		*pnNeeded += 2;
		*pnNeeded += 2;
		*pnNeeded += (pIe->chan_width_2 * 2);
		*pnNeeded += (pIe->chan_width_2 * 2);
		*pnNeeded += (pIe->chan_width_3 * 2);
		*pnNeeded += (pIe->chan_width_3 * 2);
		if (pIe->ppet_present) {
			switch (pIe->ppet_present) {
			case 1:
				*pnNeeded += pIe->ppet.ppe_threshold.num_ppe_th;
				break;
			}
		} else {
			break;
		}
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_he_cap. */

uint32_t dot11f_get_packed_ie_he_op(tpAniSirGlobal pCtx,
	tDot11fIEhe_op *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 2;
		*pnNeeded += 1;
		*pnNeeded += 1;
		*pnNeeded += 2;
		if (pIe->vht_oper_present) {
			switch (pIe->vht_oper_present) {
			case 1:
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				break;
			}
		}
		if (pIe->co_located_bss) {
			switch (pIe->co_located_bss) {
			case 1:
				*pnNeeded += 1;
				break;
			}
		}
		if (pIe->oper_info_6g_present) {
			switch (pIe->oper_info_6g_present) {
			case 1:
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				*pnNeeded += 1;
				break;
			}
		}
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_he_op. */

uint32_t dot11f_get_packed_ie_hs20vendor_ie(tpAniSirGlobal pCtx,
	tDot11fIEhs20vendor_ie *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 1;
		if (pIe->hs_id_present) {
			switch (pIe->hs_id_present) {
			case 1:
				*pnNeeded += 2;
				break;
			case 2:
				*pnNeeded += 2;
				break;
			}
		} else {
			break;
		}
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_hs20vendor_ie. */

uint32_t dot11f_get_packed_ie_qcn_ie(tpAniSirGlobal pCtx,
	tDot11fIEqcn_ie *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pIe, pnNeeded,
				TLVS_qcn_ie);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_qcn_ie. */

uint32_t dot11f_get_packed_ie_vendor_vht_ie(tpAniSirGlobal pCtx,
	tDot11fIEvendor_vht_ie *pIe, uint32_t *pnNeeded)
{
	uint32_t status = DOT11F_PARSE_SUCCESS;
	(void)pCtx;
	while (pIe->present) {
		*pnNeeded += 1;
		status = get_packed_size_core(pCtx, (uint8_t *)pIe, pnNeeded,
				IES_vendor_vht_ie);
		break;
	}
	return status;
} /* End dot11f_get_packed_ie_vendor_vht_ie. */

uint32_t dot11f_get_packed_add_ts_request_size(tpAniSirGlobal pCtx,
	tDot11fAddTSRequest *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_AddTSRequest);
	return status;
} /* End dot11f_get_packed_add_ts_request_size. */

uint32_t dot11f_get_packed_add_ts_response_size(tpAniSirGlobal pCtx,
	tDot11fAddTSResponse *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 5;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_AddTSResponse);
	return status;
} /* End dot11f_get_packed_add_ts_response_size. */

uint32_t dot11f_get_packed_assoc_request_size(tpAniSirGlobal pCtx,
	tDot11fAssocRequest *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 4;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_AssocRequest);
	return status;
} /* End dot11f_get_packed_assoc_request_size. */

uint32_t dot11f_get_packed_assoc_response_size(tpAniSirGlobal pCtx,
	tDot11fAssocResponse *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 6;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_AssocResponse);
	return status;
} /* End dot11f_get_packed_assoc_response_size. */

uint32_t dot11f_get_packed_authentication_size(tpAniSirGlobal pCtx,
	tDot11fAuthentication *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 6;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_Authentication);
	return status;
} /* End dot11f_get_packed_authentication_size. */

uint32_t dot11f_get_packed_beacon_size(tpAniSirGlobal pCtx,
	tDot11fBeacon *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 12;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_Beacon);
	return status;
} /* End dot11f_get_packed_beacon_size. */

uint32_t dot11f_get_packed_beacon1_size(tpAniSirGlobal pCtx,
	tDot11fBeacon1 *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 12;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_Beacon1);
	return status;
} /* End dot11f_get_packed_beacon1_size. */

uint32_t dot11f_get_packed_beacon2_size(tpAniSirGlobal pCtx,
	tDot11fBeacon2 *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 0;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_Beacon2);
	return status;
} /* End dot11f_get_packed_beacon2_size. */

uint32_t dot11f_get_packed_beacon_i_es_size(tpAniSirGlobal pCtx,
	tDot11fBeaconIEs *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 0;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_BeaconIEs);
	return status;
} /* End dot11f_get_packed_beacon_i_es_size. */

uint32_t dot11f_get_packed_channel_switch_size(tpAniSirGlobal pCtx,
	tDot11fChannelSwitch *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 2;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_ChannelSwitch);
	return status;
} /* End dot11f_get_packed_channel_switch_size. */

uint32_t dot11f_get_packed_de_auth_size(tpAniSirGlobal pCtx,
	tDot11fDeAuth *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 2;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_DeAuth);
	return status;
} /* End dot11f_get_packed_de_auth_size. */

uint32_t dot11f_get_packed_del_ts_size(tpAniSirGlobal pCtx,
	tDot11fDelTS *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 7;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_DelTS);
	return status;
} /* End dot11f_get_packed_del_ts_size. */

uint32_t dot11f_get_packed_disassociation_size(tpAniSirGlobal pCtx,
	tDot11fDisassociation *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 2;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_Disassociation);
	return status;
} /* End dot11f_get_packed_disassociation_size. */

uint32_t dot11f_get_packed_link_measurement_report_size(tpAniSirGlobal pCtx,
	tDot11fLinkMeasurementReport *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 11;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_LinkMeasurementReport);
	return status;
} /* End dot11f_get_packed_link_measurement_report_size. */

uint32_t dot11f_get_packed_link_measurement_request_size(tpAniSirGlobal pCtx,
	tDot11fLinkMeasurementRequest *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 5;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_LinkMeasurementRequest);
	return status;
} /* End dot11f_get_packed_link_measurement_request_size. */

uint32_t dot11f_get_packed_measurement_report_size(tpAniSirGlobal pCtx,
	tDot11fMeasurementReport *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_MeasurementReport);
	return status;
} /* End dot11f_get_packed_measurement_report_size. */

uint32_t dot11f_get_packed_measurement_request_size(tpAniSirGlobal pCtx,
	tDot11fMeasurementRequest *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_MeasurementRequest);
	return status;
} /* End dot11f_get_packed_measurement_request_size. */

uint32_t dot11f_get_packed_neighbor_report_request_size(tpAniSirGlobal pCtx,
	tDot11fNeighborReportRequest *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_NeighborReportRequest);
	return status;
} /* End dot11f_get_packed_neighbor_report_request_size. */

uint32_t dot11f_get_packed_neighbor_report_response_size(tpAniSirGlobal pCtx,
	tDot11fNeighborReportResponse *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_NeighborReportResponse);
	return status;
} /* End dot11f_get_packed_neighbor_report_response_size. */

uint32_t dot11f_get_packed_operating_mode_size(tpAniSirGlobal pCtx,
	tDot11fOperatingMode *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_OperatingMode);
	return status;
} /* End dot11f_get_packed_operating_mode_size. */

uint32_t dot11f_get_packed_probe_request_size(tpAniSirGlobal pCtx,
	tDot11fProbeRequest *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 0;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_ProbeRequest);
	return status;
} /* End dot11f_get_packed_probe_request_size. */

uint32_t dot11f_get_packed_probe_response_size(tpAniSirGlobal pCtx,
	tDot11fProbeResponse *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 12;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_ProbeResponse);
	return status;
} /* End dot11f_get_packed_probe_response_size. */

uint32_t dot11f_get_packed_qos_map_configure_size(tpAniSirGlobal pCtx,
	tDot11fQosMapConfigure *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 2;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_QosMapConfigure);
	return status;
} /* End dot11f_get_packed_qos_map_configure_size. */

uint32_t dot11f_get_packed_radio_measurement_report_size(tpAniSirGlobal pCtx,
	tDot11fRadioMeasurementReport *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_RadioMeasurementReport);
	return status;
} /* End dot11f_get_packed_radio_measurement_report_size. */

uint32_t dot11f_get_packed_radio_measurement_request_size(tpAniSirGlobal pCtx,
	tDot11fRadioMeasurementRequest *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 5;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_RadioMeasurementRequest);
	return status;
} /* End dot11f_get_packed_radio_measurement_request_size. */

uint32_t dot11f_get_packed_re_assoc_request_size(tpAniSirGlobal pCtx,
	tDot11fReAssocRequest *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 10;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_ReAssocRequest);
	return status;
} /* End dot11f_get_packed_re_assoc_request_size. */

uint32_t dot11f_get_packed_re_assoc_response_size(tpAniSirGlobal pCtx,
	tDot11fReAssocResponse *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 6;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_ReAssocResponse);
	return status;
} /* End dot11f_get_packed_re_assoc_response_size. */

uint32_t dot11f_get_packed_sm_power_save_size(tpAniSirGlobal pCtx,
	tDot11fSMPowerSave *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_SMPowerSave);
	return status;
} /* End dot11f_get_packed_sm_power_save_size. */

uint32_t dot11f_get_packed_sa_query_req_size(tpAniSirGlobal pCtx,
	tDot11fSaQueryReq *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 4;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_SaQueryReq);
	return status;
} /* End dot11f_get_packed_sa_query_req_size. */

uint32_t dot11f_get_packed_sa_query_rsp_size(tpAniSirGlobal pCtx,
	tDot11fSaQueryRsp *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 4;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_SaQueryRsp);
	return status;
} /* End dot11f_get_packed_sa_query_rsp_size. */

uint32_t dot11f_get_packed_tdls_dis_req_size(tpAniSirGlobal pCtx,
	tDot11fTDLSDisReq *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_TDLSDisReq);
	return status;
} /* End dot11f_get_packed_tdls_dis_req_size. */

uint32_t dot11f_get_packed_tdls_dis_rsp_size(tpAniSirGlobal pCtx,
	tDot11fTDLSDisRsp *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 5;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_TDLSDisRsp);
	return status;
} /* End dot11f_get_packed_tdls_dis_rsp_size. */

uint32_t dot11f_get_packed_tdls_peer_traffic_ind_size(tpAniSirGlobal pCtx,
	tDot11fTDLSPeerTrafficInd *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_TDLSPeerTrafficInd);
	return status;
} /* End dot11f_get_packed_tdls_peer_traffic_ind_size. */

uint32_t dot11f_get_packed_tdls_peer_traffic_rsp_size(tpAniSirGlobal pCtx,
	tDot11fTDLSPeerTrafficRsp *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_TDLSPeerTrafficRsp);
	return status;
} /* End dot11f_get_packed_tdls_peer_traffic_rsp_size. */

uint32_t dot11f_get_packed_tdls_setup_cnf_size(tpAniSirGlobal pCtx,
	tDot11fTDLSSetupCnf *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 5;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_TDLSSetupCnf);
	return status;
} /* End dot11f_get_packed_tdls_setup_cnf_size. */

uint32_t dot11f_get_packed_tdls_setup_req_size(tpAniSirGlobal pCtx,
	tDot11fTDLSSetupReq *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 5;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_TDLSSetupReq);
	return status;
} /* End dot11f_get_packed_tdls_setup_req_size. */

uint32_t dot11f_get_packed_tdls_setup_rsp_size(tpAniSirGlobal pCtx,
	tDot11fTDLSSetupRsp *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 7;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_TDLSSetupRsp);
	return status;
} /* End dot11f_get_packed_tdls_setup_rsp_size. */

uint32_t dot11f_get_packed_tdls_teardown_size(tpAniSirGlobal pCtx,
	tDot11fTDLSTeardown *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 4;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_TDLSTeardown);
	return status;
} /* End dot11f_get_packed_tdls_teardown_size. */

uint32_t dot11f_get_packed_tpc_report_size(tpAniSirGlobal pCtx,
	tDot11fTPCReport *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_TPCReport);
	return status;
} /* End dot11f_get_packed_tpc_report_size. */

uint32_t dot11f_get_packed_tpc_request_size(tpAniSirGlobal pCtx,
	tDot11fTPCRequest *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_TPCRequest);
	return status;
} /* End dot11f_get_packed_tpc_request_size. */

uint32_t dot11f_get_packed_timing_advertisement_frame_size(tpAniSirGlobal pCtx,
	tDot11fTimingAdvertisementFrame *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 10;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_TimingAdvertisementFrame);
	return status;
} /* End dot11f_get_packed_timing_advertisement_frame_size. */

uint32_t dot11f_get_packed_vht_gid_management_action_frame_size(tpAniSirGlobal pCtx,
	tDot11fVHTGidManagementActionFrame *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 26;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_VHTGidManagementActionFrame);
	return status;
} /* End dot11f_get_packed_vht_gid_management_action_frame_size. */

uint32_t dot11f_get_packed_wmm_add_ts_request_size(tpAniSirGlobal pCtx,
	tDot11fWMMAddTSRequest *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 4;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_WMMAddTSRequest);
	return status;
} /* End dot11f_get_packed_wmm_add_ts_request_size. */

uint32_t dot11f_get_packed_wmm_add_ts_response_size(tpAniSirGlobal pCtx,
	tDot11fWMMAddTSResponse *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 4;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_WMMAddTSResponse);
	return status;
} /* End dot11f_get_packed_wmm_add_ts_response_size. */

uint32_t dot11f_get_packed_wmm_del_ts_size(tpAniSirGlobal pCtx,
	tDot11fWMMDelTS *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 4;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_WMMDelTS);
	return status;
} /* End dot11f_get_packed_wmm_del_ts_size. */

uint32_t dot11f_get_packed_addba_req_size(tpAniSirGlobal pCtx,
	tDot11faddba_req *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 9;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_addba_req);
	return status;
} /* End dot11f_get_packed_addba_req_size. */

uint32_t dot11f_get_packed_addba_rsp_size(tpAniSirGlobal pCtx,
	tDot11faddba_rsp *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 9;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_addba_rsp);
	return status;
} /* End dot11f_get_packed_addba_rsp_size. */

uint32_t dot11f_get_packed_delba_req_size(tpAniSirGlobal pCtx,
	tDot11fdelba_req *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 6;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_delba_req);
	return status;
} /* End dot11f_get_packed_delba_req_size. */

uint32_t dot11f_get_packed_ext_channel_switch_action_frame_size(tpAniSirGlobal pCtx,
	tDot11fext_channel_switch_action_frame *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 6;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_ext_channel_switch_action_frame);
	return status;
} /* End dot11f_get_packed_ext_channel_switch_action_frame_size. */

uint32_t dot11f_get_packed_ht2040_bss_coexistence_mgmt_action_frameSize(tpAniSirGlobal pCtx,
	tDot11fht2040_bss_coexistence_mgmt_action_frame *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 2;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_ht2040_bss_coexistence_mgmt_action_frame);
	return status;
} /* End dot11f_get_packed_ht2040_bss_coexistence_mgmt_action_frameSize. */

uint32_t dot11f_get_packed_mscs_request_action_frameSize(tpAniSirGlobal pCtx,
	tDot11fmscs_request_action_frame *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 3;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_mscs_request_action_frame);
	return status;
} /* End dot11f_get_packed_mscs_request_action_frameSize. */

uint32_t dot11f_get_packed_p2p_oper_chan_change_confirmSize(tpAniSirGlobal pCtx,
	tDot11fp2p_oper_chan_change_confirm *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 7;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_p2p_oper_chan_change_confirm);
	return status;
} /* End dot11f_get_packed_p2p_oper_chan_change_confirmSize. */

uint32_t dot11f_get_packed_vendor_action_frameSize(tpAniSirGlobal pCtx,
	tDot11fvendor_action_frame *pFrm, uint32_t *pnNeeded)
{
	uint32_t status = 0;
	*pnNeeded = 5;
	status = get_packed_size_core(pCtx, (uint8_t *)pFrm, pnNeeded,
				      IES_vendor_action_frame);
	return status;
} /* End dot11f_get_packed_vendor_action_frameSize. */

static uint32_t get_packed_size_core(tpAniSirGlobal pCtx,
				      uint8_t *pFrm,
				      uint32_t *pnNeeded,
				      const tIEDefn  IEs[])
{
	const tIEDefn *pIe;
	uint16_t  i, n;
	uint32_t  status;
	tFRAMES_BOOL *pfFound;
	uint32_t countOffset = 0;
	uint32_t byteCount = 0;
	uint8_t  pIePresent = 0;
	uint32_t offset = 0;

	status = DOT11F_PARSE_SUCCESS;

	(void)pCtx; /* Shutup the compiler if we have no FFs nor IEs... */
	i = 0;
	n = 0;
	pIe = &(IEs[0]);
	while (0xff != pIe->eid || pIe->extn_eid) {
		pfFound = (tFRAMES_BOOL *)(pFrm + pIe->offset +
					  pIe->presenceOffset);
		if (*pfFound) {
			countOffset = ((0 == pIe->arraybound) ? 1 : (*(uint16_t *)(pFrm + pIe->countOffset)));
			for (i = 0U; i < countOffset; ++i) {
				*pnNeeded += 2U + pIe->noui;
				if (pIe->extn_eid)
						(*pnNeeded)++;
				byteCount = 0;
				switch (pIe->sig) {
				case SigIeGTK:
					offset = sizeof(tDot11fIEGTK);
					byteCount = ((tDot11fIEGTK *)
					  (pFrm + pIe->offset + offset * i))->
					  num_key + 11;
					pIePresent = ((tDot11fIEGTK *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeIGTK:
					offset = sizeof(tDot11fIEIGTK);
					byteCount = 33;
					pIePresent = ((tDot11fIEIGTK *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeR0KH_ID:
					offset = sizeof(tDot11fIER0KH_ID);
					byteCount = ((tDot11fIER0KH_ID *)
					  (pFrm + pIe->offset + offset * i))->
					  num_PMK_R0_ID;
					pIePresent = ((tDot11fIER0KH_ID *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeR1KH_ID:
					offset = sizeof(tDot11fIER1KH_ID);
					byteCount = 6;
					pIePresent = ((tDot11fIER1KH_ID *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeAPChannelReport:
					offset = sizeof(tDot11fIEAPChannelReport);
					byteCount = ((tDot11fIEAPChannelReport *)
					  (pFrm + pIe->offset + offset * i))->
					  num_channelList + 1;
					pIePresent = ((tDot11fIEAPChannelReport *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeBcnReportingDetail:
					offset = sizeof(tDot11fIEBcnReportingDetail);
					byteCount = 1;
					pIePresent = ((tDot11fIEBcnReportingDetail *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeBeaconReportFrmBody:
					offset = sizeof(tDot11fIEBeaconReportFrmBody);
					byteCount = ((tDot11fIEBeaconReportFrmBody *)
					  (pFrm + pIe->offset + offset * i))->
					  num_reportedFields;
					pIePresent = ((tDot11fIEBeaconReportFrmBody *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeBeaconReporting:
					offset = sizeof(tDot11fIEBeaconReporting);
					byteCount = 2;
					pIePresent = ((tDot11fIEBeaconReporting *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeCondensedCountryStr:
					offset = sizeof(tDot11fIECondensedCountryStr);
					byteCount = 2;
					pIePresent = ((tDot11fIECondensedCountryStr *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeMeasurementPilot:
					offset = sizeof(tDot11fIEMeasurementPilot);
					byteCount = ((tDot11fIEMeasurementPilot *)
					  (pFrm + pIe->offset + offset * i))->
					  num_vendorSpecific + 1;
					pIePresent = ((tDot11fIEMeasurementPilot *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeMultiBssid:
					offset = sizeof(tDot11fIEMultiBssid);
					byteCount = ((tDot11fIEMultiBssid *)
					  (pFrm + pIe->offset + offset * i))->
					  num_vendorSpecific + 1;
					pIePresent = ((tDot11fIEMultiBssid *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeRICData:
					offset = sizeof(tDot11fIERICData);
					byteCount = 4;
					pIePresent = ((tDot11fIERICData *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeRICDescriptor:
					offset = sizeof(tDot11fIERICDescriptor);
					byteCount = ((tDot11fIERICDescriptor *)
					  (pFrm + pIe->offset + offset * i))->
					  num_variableData + 1;
					pIePresent = ((tDot11fIERICDescriptor *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeRRMEnabledCap:
					offset = sizeof(tDot11fIERRMEnabledCap);
					byteCount = 5;
					pIePresent = ((tDot11fIERRMEnabledCap *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeRequestedInfo:
					offset = sizeof(tDot11fIERequestedInfo);
					byteCount = ((tDot11fIERequestedInfo *)
					  (pFrm + pIe->offset + offset * i))->
					  num_requested_eids;
					pIePresent = ((tDot11fIERequestedInfo *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeSSID:
					offset = sizeof(tDot11fIESSID);
					byteCount = ((tDot11fIESSID *)
					  (pFrm + pIe->offset + offset * i))->
					  num_ssid;
					pIePresent = ((tDot11fIESSID *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeSchedule:
					offset = sizeof(tDot11fIESchedule);
					byteCount = 14;
					pIePresent = ((tDot11fIESchedule *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeTCLAS:
					offset = sizeof(tDot11fIETCLAS);
					status |=
						dot11f_get_packed_ietclas(
						pCtx, (tDot11fIETCLAS *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeTCLASSPROC:
					offset = sizeof(tDot11fIETCLASSPROC);
					byteCount = 1;
					pIePresent = ((tDot11fIETCLASSPROC *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeTSDelay:
					offset = sizeof(tDot11fIETSDelay);
					byteCount = 4;
					pIePresent = ((tDot11fIETSDelay *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeTSFInfo:
					offset = sizeof(tDot11fIETSFInfo);
					byteCount = 4;
					pIePresent = ((tDot11fIETSFInfo *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeTSPEC:
					offset = sizeof(tDot11fIETSPEC);
					byteCount = 55;
					pIePresent = ((tDot11fIETSPEC *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeVHTCaps:
					offset = sizeof(tDot11fIEVHTCaps);
					byteCount = 12;
					pIePresent = ((tDot11fIEVHTCaps *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeVHTOperation:
					offset = sizeof(tDot11fIEVHTOperation);
					byteCount = 5;
					pIePresent = ((tDot11fIEVHTOperation *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWMMSchedule:
					offset = sizeof(tDot11fIEWMMSchedule);
					byteCount = 15;
					pIePresent = ((tDot11fIEWMMSchedule *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWMMTCLAS:
					offset = sizeof(tDot11fIEWMMTCLAS);
					status |=
						dot11f_get_packed_iewmmtclas(
						pCtx, (tDot11fIEWMMTCLAS *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeWMMTCLASPROC:
					offset = sizeof(tDot11fIEWMMTCLASPROC);
					byteCount = 2;
					pIePresent = ((tDot11fIEWMMTCLASPROC *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWMMTSDelay:
					offset = sizeof(tDot11fIEWMMTSDelay);
					byteCount = 5;
					pIePresent = ((tDot11fIEWMMTSDelay *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWMMTSPEC:
					offset = sizeof(tDot11fIEWMMTSPEC);
					byteCount = 56;
					pIePresent = ((tDot11fIEWMMTSPEC *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWiderBWChanSwitchAnn:
					offset = sizeof(tDot11fIEWiderBWChanSwitchAnn);
					byteCount = 3;
					pIePresent = ((tDot11fIEWiderBWChanSwitchAnn *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeazimuth_req:
					offset = sizeof(tDot11fIEazimuth_req);
					byteCount = 1;
					pIePresent = ((tDot11fIEazimuth_req *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIebeacon_report_frm_body_fragment_id:
					offset = sizeof(tDot11fIEbeacon_report_frm_body_fragment_id);
					byteCount = 2;
					pIePresent = ((tDot11fIEbeacon_report_frm_body_fragment_id *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIelast_beacon_report_indication:
					offset = sizeof(tDot11fIElast_beacon_report_indication);
					byteCount = 1;
					pIePresent = ((tDot11fIElast_beacon_report_indication *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIemax_age:
					offset = sizeof(tDot11fIEmax_age);
					byteCount = 2;
					pIePresent = ((tDot11fIEmax_age *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIemscs_status:
					offset = sizeof(tDot11fIEmscs_status);
					byteCount = 1;
					pIePresent = ((tDot11fIEmscs_status *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeneighbor_rpt:
					offset = sizeof(tDot11fIEneighbor_rpt);
					status |=
						dot11f_get_packed_ie_neighbor_rpt(
						pCtx, (tDot11fIEneighbor_rpt *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIereq_mac_addr:
					offset = sizeof(tDot11fIEreq_mac_addr);
					byteCount = 6;
					pIePresent = ((tDot11fIEreq_mac_addr *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIetclas_mask:
					offset = sizeof(tDot11fIEtclas_mask);
					status |=
						dot11f_get_packed_ie_tclas_mask(
						pCtx, (tDot11fIEtclas_mask *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIetgt_mac_addr:
					offset = sizeof(tDot11fIEtgt_mac_addr);
					byteCount = 6;
					pIePresent = ((tDot11fIEtgt_mac_addr *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIetransmit_power_env:
					offset = sizeof(tDot11fIEtransmit_power_env);
					byteCount = ((tDot11fIEtransmit_power_env *)
					  (pFrm + pIe->offset + offset * i))->
					  num_tx_power + 1;
					pIePresent = ((tDot11fIEtransmit_power_env *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeAID:
					offset = sizeof(tDot11fIEAID);
					byteCount = 2;
					pIePresent = ((tDot11fIEAID *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeCFParams:
					offset = sizeof(tDot11fIECFParams);
					byteCount = 6;
					pIePresent = ((tDot11fIECFParams *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeChallengeText:
					offset = sizeof(tDot11fIEChallengeText);
					byteCount = ((tDot11fIEChallengeText *)
					  (pFrm + pIe->offset + offset * i))->
					  num_text;
					pIePresent = ((tDot11fIEChallengeText *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeChanSwitchAnn:
					offset = sizeof(tDot11fIEChanSwitchAnn);
					byteCount = 3;
					pIePresent = ((tDot11fIEChanSwitchAnn *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeChannelSwitchWrapper:
					offset = sizeof(tDot11fIEChannelSwitchWrapper);
					status |=
						dot11f_get_packed_ie_channel_switch_wrapper(
						pCtx, (tDot11fIEChannelSwitchWrapper *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeCountry:
					offset = sizeof(tDot11fIECountry);
					status |=
						dot11f_get_packed_ie_country(
						pCtx, (tDot11fIECountry *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeDSParams:
					offset = sizeof(tDot11fIEDSParams);
					byteCount = 1;
					pIePresent = ((tDot11fIEDSParams *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeEDCAParamSet:
					offset = sizeof(tDot11fIEEDCAParamSet);
					byteCount = 18;
					pIePresent = ((tDot11fIEEDCAParamSet *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeERPInfo:
					offset = sizeof(tDot11fIEERPInfo);
					byteCount = 1;
					pIePresent = ((tDot11fIEERPInfo *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeESECckmOpaque:
					offset = sizeof(tDot11fIEESECckmOpaque);
					byteCount = ((tDot11fIEESECckmOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  num_data;
					pIePresent = ((tDot11fIEESECckmOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeESERadMgmtCap:
					offset = sizeof(tDot11fIEESERadMgmtCap);
					byteCount = 2;
					pIePresent = ((tDot11fIEESERadMgmtCap *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeESETrafStrmMet:
					offset = sizeof(tDot11fIEESETrafStrmMet);
					byteCount = 4;
					pIePresent = ((tDot11fIEESETrafStrmMet *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeESETrafStrmRateSet:
					offset = sizeof(tDot11fIEESETrafStrmRateSet);
					byteCount = ((tDot11fIEESETrafStrmRateSet *)
					  (pFrm + pIe->offset + offset * i))->
					  num_tsrates + 1;
					pIePresent = ((tDot11fIEESETrafStrmRateSet *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeESETxmitPower:
					offset = sizeof(tDot11fIEESETxmitPower);
					byteCount = 2;
					pIePresent = ((tDot11fIEESETxmitPower *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeESEVersion:
					offset = sizeof(tDot11fIEESEVersion);
					byteCount = 1;
					pIePresent = ((tDot11fIEESEVersion *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeExtCap:
					offset = sizeof(tDot11fIEExtCap);
					byteCount = ((tDot11fIEExtCap *)
					  (pFrm + pIe->offset + offset * i))->
					  num_bytes;
					pIePresent = ((tDot11fIEExtCap *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeExtSuppRates:
					offset = sizeof(tDot11fIEExtSuppRates);
					byteCount = ((tDot11fIEExtSuppRates *)
					  (pFrm + pIe->offset + offset * i))->
					  num_rates;
					pIePresent = ((tDot11fIEExtSuppRates *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeFHParamSet:
					offset = sizeof(tDot11fIEFHParamSet);
					byteCount = 5;
					pIePresent = ((tDot11fIEFHParamSet *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeFHParams:
					offset = sizeof(tDot11fIEFHParams);
					byteCount = 2;
					pIePresent = ((tDot11fIEFHParams *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeFHPattTable:
					offset = sizeof(tDot11fIEFHPattTable);
					byteCount = ((tDot11fIEFHPattTable *)
					  (pFrm + pIe->offset + offset * i))->
					  num_randtable + 4;
					pIePresent = ((tDot11fIEFHPattTable *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeFTInfo:
					offset = sizeof(tDot11fIEFTInfo);
					status |=
						dot11f_get_packed_ieft_info(
						pCtx, (tDot11fIEFTInfo *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeHTCaps:
					offset = sizeof(tDot11fIEHTCaps);
					byteCount = ((tDot11fIEHTCaps *)
					  (pFrm + pIe->offset + offset * i))->
					  num_rsvd + 26;
					pIePresent = ((tDot11fIEHTCaps *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeHTInfo:
					offset = sizeof(tDot11fIEHTInfo);
					byteCount = ((tDot11fIEHTInfo *)
					  (pFrm + pIe->offset + offset * i))->
					  num_rsvd + 22;
					pIePresent = ((tDot11fIEHTInfo *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeLinkIdentifier:
					offset = sizeof(tDot11fIELinkIdentifier);
					byteCount = 18;
					pIePresent = ((tDot11fIELinkIdentifier *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeMBO_IE:
					offset = sizeof(tDot11fIEMBO_IE);
					status |=
						dot11f_get_packed_ie_MBO_IE(
						pCtx, (tDot11fIEMBO_IE *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeMeasurementReport:
					offset = sizeof(tDot11fIEMeasurementReport);
					status |=
						dot11f_get_packed_ie_measurement_report(
						pCtx, (tDot11fIEMeasurementReport *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeMeasurementRequest:
					offset = sizeof(tDot11fIEMeasurementRequest);
					status |=
						dot11f_get_packed_ie_measurement_request(
						pCtx, (tDot11fIEMeasurementRequest *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeMobilityDomain:
					offset = sizeof(tDot11fIEMobilityDomain);
					byteCount = 3;
					pIePresent = ((tDot11fIEMobilityDomain *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeNeighborReport:
					offset = sizeof(tDot11fIENeighborReport);
					status |=
						dot11f_get_packed_ie_neighbor_report(
						pCtx, (tDot11fIENeighborReport *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeOBSSScanParameters:
					offset = sizeof(tDot11fIEOBSSScanParameters);
					byteCount = 14;
					pIePresent = ((tDot11fIEOBSSScanParameters *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeOperatingMode:
					offset = sizeof(tDot11fIEOperatingMode);
					byteCount = 1;
					pIePresent = ((tDot11fIEOperatingMode *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeP2PAssocReq:
					offset = sizeof(tDot11fIEP2PAssocReq);
					status |=
						dot11f_get_packed_iep2_p_assoc_req(
						pCtx, (tDot11fIEP2PAssocReq *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeP2PAssocRes:
					offset = sizeof(tDot11fIEP2PAssocRes);
					status |=
						dot11f_get_packed_iep2_p_assoc_res(
						pCtx, (tDot11fIEP2PAssocRes *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeP2PBeacon:
					offset = sizeof(tDot11fIEP2PBeacon);
					status |=
						dot11f_get_packed_iep2_p_beacon(
						pCtx, (tDot11fIEP2PBeacon *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeP2PBeaconProbeRes:
					offset = sizeof(tDot11fIEP2PBeaconProbeRes);
					status |=
						dot11f_get_packed_iep2_p_beacon_probe_res(
						pCtx, (tDot11fIEP2PBeaconProbeRes *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeP2PDeAuth:
					offset = sizeof(tDot11fIEP2PDeAuth);
					status |=
						dot11f_get_packed_iep2_p_de_auth(
						pCtx, (tDot11fIEP2PDeAuth *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeP2PDisAssoc:
					offset = sizeof(tDot11fIEP2PDisAssoc);
					status |=
						dot11f_get_packed_iep2_p_dis_assoc(
						pCtx, (tDot11fIEP2PDisAssoc *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeP2PIEOpaque:
					offset = sizeof(tDot11fIEP2PIEOpaque);
					byteCount = ((tDot11fIEP2PIEOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  num_data;
					pIePresent = ((tDot11fIEP2PIEOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeP2PProbeReq:
					offset = sizeof(tDot11fIEP2PProbeReq);
					status |=
						dot11f_get_packed_iep2_p_probe_req(
						pCtx, (tDot11fIEP2PProbeReq *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeP2PProbeRes:
					offset = sizeof(tDot11fIEP2PProbeRes);
					status |=
						dot11f_get_packed_iep2_p_probe_res(
						pCtx, (tDot11fIEP2PProbeRes *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIePTIControl:
					offset = sizeof(tDot11fIEPTIControl);
					byteCount = 3;
					pIePresent = ((tDot11fIEPTIControl *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIePUBufferStatus:
					offset = sizeof(tDot11fIEPUBufferStatus);
					byteCount = 1;
					pIePresent = ((tDot11fIEPUBufferStatus *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIePowerCaps:
					offset = sizeof(tDot11fIEPowerCaps);
					byteCount = 2;
					pIePresent = ((tDot11fIEPowerCaps *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIePowerConstraints:
					offset = sizeof(tDot11fIEPowerConstraints);
					byteCount = 1;
					pIePresent = ((tDot11fIEPowerConstraints *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeQBSSLoad:
					offset = sizeof(tDot11fIEQBSSLoad);
					byteCount = 5;
					pIePresent = ((tDot11fIEQBSSLoad *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeQComVendorIE:
					offset = sizeof(tDot11fIEQComVendorIE);
					byteCount = 2;
					pIePresent = ((tDot11fIEQComVendorIE *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeQOSCapsAp:
					offset = sizeof(tDot11fIEQOSCapsAp);
					byteCount = 1;
					pIePresent = ((tDot11fIEQOSCapsAp *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeQOSCapsStation:
					offset = sizeof(tDot11fIEQOSCapsStation);
					byteCount = 1;
					pIePresent = ((tDot11fIEQOSCapsStation *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeQosMapSet:
					offset = sizeof(tDot11fIEQosMapSet);
					byteCount = ((tDot11fIEQosMapSet *)
					  (pFrm + pIe->offset + offset * i))->
					  num_dscp_exceptions;
					pIePresent = ((tDot11fIEQosMapSet *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeQuiet:
					offset = sizeof(tDot11fIEQuiet);
					byteCount = 6;
					pIePresent = ((tDot11fIEQuiet *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeRCPIIE:
					offset = sizeof(tDot11fIERCPIIE);
					byteCount = 1;
					pIePresent = ((tDot11fIERCPIIE *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeRICDataDesc:
					offset = sizeof(tDot11fIERICDataDesc);
					pnNeeded -= 2  ; /* Subtract the length and Oui as this is our container IE to group Ies and it doesn't have its own length and OUI. */
					status |=
						dot11f_get_packed_ieric_data_desc(
						pCtx, (tDot11fIERICDataDesc *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeRSN:
					offset = sizeof(tDot11fIERSN);
					status |=
						dot11f_get_packed_iersn(
						pCtx, (tDot11fIERSN *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeRSNIIE:
					offset = sizeof(tDot11fIERSNIIE);
					byteCount = 1;
					pIePresent = ((tDot11fIERSNIIE *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeRSNOpaque:
					offset = sizeof(tDot11fIERSNOpaque);
					byteCount = ((tDot11fIERSNOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  num_data;
					pIePresent = ((tDot11fIERSNOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeSuppChannels:
					offset = sizeof(tDot11fIESuppChannels);
					byteCount = ((tDot11fIESuppChannels *)
					  (pFrm + pIe->offset + offset * i))->
					  num_bands * 2;
					pIePresent = ((tDot11fIESuppChannels *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeSuppOperatingClasses:
					offset = sizeof(tDot11fIESuppOperatingClasses);
					byteCount = ((tDot11fIESuppOperatingClasses *)
					  (pFrm + pIe->offset + offset * i))->
					  num_classes;
					pIePresent = ((tDot11fIESuppOperatingClasses *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeSuppRates:
					offset = sizeof(tDot11fIESuppRates);
					byteCount = ((tDot11fIESuppRates *)
					  (pFrm + pIe->offset + offset * i))->
					  num_rates;
					pIePresent = ((tDot11fIESuppRates *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeTIM:
					offset = sizeof(tDot11fIETIM);
					byteCount = ((tDot11fIETIM *)
					  (pFrm + pIe->offset + offset * i))->
					  num_vbmp + 3;
					pIePresent = ((tDot11fIETIM *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeTPCReport:
					offset = sizeof(tDot11fIETPCReport);
					byteCount = 2;
					pIePresent = ((tDot11fIETPCReport *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeTPCRequest:
					offset = sizeof(tDot11fIETPCRequest);
					byteCount = 0;
					pIePresent = ((tDot11fIETPCRequest *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeTimeAdvertisement:
					offset = sizeof(tDot11fIETimeAdvertisement);
					byteCount = 16;
					pIePresent = ((tDot11fIETimeAdvertisement *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeTimeoutInterval:
					offset = sizeof(tDot11fIETimeoutInterval);
					byteCount = 5;
					pIePresent = ((tDot11fIETimeoutInterval *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeVHTExtBssLoad:
					offset = sizeof(tDot11fIEVHTExtBssLoad);
					byteCount = 5;
					pIePresent = ((tDot11fIEVHTExtBssLoad *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeVendor1IE:
					offset = sizeof(tDot11fIEVendor1IE);
					byteCount = 0;
					pIePresent = ((tDot11fIEVendor1IE *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeVendor3IE:
					offset = sizeof(tDot11fIEVendor3IE);
					byteCount = 0;
					pIePresent = ((tDot11fIEVendor3IE *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWAPI:
					offset = sizeof(tDot11fIEWAPI);
					status |=
						dot11f_get_packed_iewapi(
						pCtx, (tDot11fIEWAPI *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeWAPIOpaque:
					offset = sizeof(tDot11fIEWAPIOpaque);
					byteCount = ((tDot11fIEWAPIOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  num_data;
					pIePresent = ((tDot11fIEWAPIOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWFATPC:
					offset = sizeof(tDot11fIEWFATPC);
					byteCount = 2;
					pIePresent = ((tDot11fIEWFATPC *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWFDIEOpaque:
					offset = sizeof(tDot11fIEWFDIEOpaque);
					byteCount = ((tDot11fIEWFDIEOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  num_data;
					pIePresent = ((tDot11fIEWFDIEOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWMMCaps:
					offset = sizeof(tDot11fIEWMMCaps);
					byteCount = 2;
					pIePresent = ((tDot11fIEWMMCaps *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWMMInfoAp:
					offset = sizeof(tDot11fIEWMMInfoAp);
					byteCount = 2;
					pIePresent = ((tDot11fIEWMMInfoAp *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWMMInfoStation:
					offset = sizeof(tDot11fIEWMMInfoStation);
					byteCount = 2;
					pIePresent = ((tDot11fIEWMMInfoStation *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWMMParams:
					offset = sizeof(tDot11fIEWMMParams);
					byteCount = 19;
					pIePresent = ((tDot11fIEWMMParams *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWPA:
					offset = sizeof(tDot11fIEWPA);
					status |=
						dot11f_get_packed_iewpa(
						pCtx, (tDot11fIEWPA *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeWPAOpaque:
					offset = sizeof(tDot11fIEWPAOpaque);
					byteCount = ((tDot11fIEWPAOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  num_data;
					pIePresent = ((tDot11fIEWPAOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWSC:
					offset = sizeof(tDot11fIEWSC);
					status |=
						dot11f_get_packed_iewsc(
						pCtx, (tDot11fIEWSC *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeWscAssocReq:
					offset = sizeof(tDot11fIEWscAssocReq);
					status |=
						dot11f_get_packed_ie_wsc_assoc_req(
						pCtx, (tDot11fIEWscAssocReq *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeWscAssocRes:
					offset = sizeof(tDot11fIEWscAssocRes);
					status |=
						dot11f_get_packed_ie_wsc_assoc_res(
						pCtx, (tDot11fIEWscAssocRes *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeWscBeacon:
					offset = sizeof(tDot11fIEWscBeacon);
					status |=
						dot11f_get_packed_ie_wsc_beacon(
						pCtx, (tDot11fIEWscBeacon *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeWscBeaconProbeRes:
					offset = sizeof(tDot11fIEWscBeaconProbeRes);
					status |=
						dot11f_get_packed_ie_wsc_beacon_probe_res(
						pCtx, (tDot11fIEWscBeaconProbeRes *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeWscIEOpaque:
					offset = sizeof(tDot11fIEWscIEOpaque);
					byteCount = ((tDot11fIEWscIEOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  num_data;
					pIePresent = ((tDot11fIEWscIEOpaque *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeWscProbeReq:
					offset = sizeof(tDot11fIEWscProbeReq);
					status |=
						dot11f_get_packed_ie_wsc_probe_req(
						pCtx, (tDot11fIEWscProbeReq *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeWscProbeRes:
					offset = sizeof(tDot11fIEWscProbeRes);
					status |=
						dot11f_get_packed_ie_wsc_probe_res(
						pCtx, (tDot11fIEWscProbeRes *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeWscReassocRes:
					offset = sizeof(tDot11fIEWscReassocRes);
					status |=
						dot11f_get_packed_ie_wsc_reassoc_res(
						pCtx, (tDot11fIEWscReassocRes *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeaddba_extn_element:
					offset = sizeof(tDot11fIEaddba_extn_element);
					byteCount = 1;
					pIePresent = ((tDot11fIEaddba_extn_element *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIebss_color_change:
					offset = sizeof(tDot11fIEbss_color_change);
					byteCount = 2;
					pIePresent = ((tDot11fIEbss_color_change *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIedecriptor_element:
					offset = sizeof(tDot11fIEdecriptor_element);
					status |=
						dot11f_get_packed_ie_decriptor_element(
						pCtx, (tDot11fIEdecriptor_element *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIedh_parameter_element:
					offset = sizeof(tDot11fIEdh_parameter_element);
					byteCount = ((tDot11fIEdh_parameter_element *)
					  (pFrm + pIe->offset + offset * i))->
					  num_public_key + 2;
					pIePresent = ((tDot11fIEdh_parameter_element *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeesp_information:
					offset = sizeof(tDot11fIEesp_information);
					byteCount = ((tDot11fIEesp_information *)
					  (pFrm + pIe->offset + offset * i))->
					  num_data;
					pIePresent = ((tDot11fIEesp_information *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeext_chan_switch_ann:
					offset = sizeof(tDot11fIEext_chan_switch_ann);
					byteCount = 4;
					pIePresent = ((tDot11fIEext_chan_switch_ann *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIefils_assoc_delay_info:
					offset = sizeof(tDot11fIEfils_assoc_delay_info);
					byteCount = 1;
					pIePresent = ((tDot11fIEfils_assoc_delay_info *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIefils_hlp_container:
					offset = sizeof(tDot11fIEfils_hlp_container);
					byteCount = ((tDot11fIEfils_hlp_container *)
					  (pFrm + pIe->offset + offset * i))->
					  num_hlp_packet + 12;
					pIePresent = ((tDot11fIEfils_hlp_container *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIefils_indication:
					offset = sizeof(tDot11fIEfils_indication);
					byteCount = ((tDot11fIEfils_indication *)
					  (pFrm + pIe->offset + offset * i))->
					  num_variable_data + 2;
					pIePresent = ((tDot11fIEfils_indication *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIefils_kde:
					offset = sizeof(tDot11fIEfils_kde);
					byteCount = ((tDot11fIEfils_kde *)
					  (pFrm + pIe->offset + offset * i))->
					  num_kde_list + 8;
					pIePresent = ((tDot11fIEfils_kde *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIefils_key_confirmation:
					offset = sizeof(tDot11fIEfils_key_confirmation);
					byteCount = ((tDot11fIEfils_key_confirmation *)
					  (pFrm + pIe->offset + offset * i))->
					  num_key_auth;
					pIePresent = ((tDot11fIEfils_key_confirmation *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIefils_nonce:
					offset = sizeof(tDot11fIEfils_nonce);
					byteCount = 16;
					pIePresent = ((tDot11fIEfils_nonce *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIefils_public_key:
					offset = sizeof(tDot11fIEfils_public_key);
					byteCount = ((tDot11fIEfils_public_key *)
					  (pFrm + pIe->offset + offset * i))->
					  num_public_key + 1;
					pIePresent = ((tDot11fIEfils_public_key *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIefils_session:
					offset = sizeof(tDot11fIEfils_session);
					byteCount = 8;
					pIePresent = ((tDot11fIEfils_session *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIefils_wrapped_data:
					offset = sizeof(tDot11fIEfils_wrapped_data);
					byteCount = ((tDot11fIEfils_wrapped_data *)
					  (pFrm + pIe->offset + offset * i))->
					  num_wrapped_data;
					pIePresent = ((tDot11fIEfils_wrapped_data *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIefragment_ie:
					offset = sizeof(tDot11fIEfragment_ie);
					byteCount = ((tDot11fIEfragment_ie *)
					  (pFrm + pIe->offset + offset * i))->
					  num_data;
					pIePresent = ((tDot11fIEfragment_ie *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIehe_6ghz_band_cap:
					offset = sizeof(tDot11fIEhe_6ghz_band_cap);
					byteCount = 2;
					pIePresent = ((tDot11fIEhe_6ghz_band_cap *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIehe_cap:
					offset = sizeof(tDot11fIEhe_cap);
					status |=
						dot11f_get_packed_ie_he_cap(
						pCtx, (tDot11fIEhe_cap *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIehe_op:
					offset = sizeof(tDot11fIEhe_op);
					status |=
						dot11f_get_packed_ie_he_op(
						pCtx, (tDot11fIEhe_op *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIehs20vendor_ie:
					offset = sizeof(tDot11fIEhs20vendor_ie);
					status |=
						dot11f_get_packed_ie_hs20vendor_ie(
						pCtx, (tDot11fIEhs20vendor_ie *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeht2040_bss_coexistence:
					offset = sizeof(tDot11fIEht2040_bss_coexistence);
					byteCount = 1;
					pIePresent = ((tDot11fIEht2040_bss_coexistence *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeht2040_bss_intolerant_report:
					offset = sizeof(tDot11fIEht2040_bss_intolerant_report);
					byteCount = ((tDot11fIEht2040_bss_intolerant_report *)
					  (pFrm + pIe->offset + offset * i))->
					  num_channel_list + 1;
					pIePresent = ((tDot11fIEht2040_bss_intolerant_report *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIemu_edca_param_set:
					offset = sizeof(tDot11fIEmu_edca_param_set);
					byteCount = 13;
					pIePresent = ((tDot11fIEmu_edca_param_set *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeoci:
					offset = sizeof(tDot11fIEoci);
					byteCount = 3;
					pIePresent = ((tDot11fIEoci *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeosen_ie:
					offset = sizeof(tDot11fIEosen_ie);
					byteCount = ((tDot11fIEosen_ie *)
					  (pFrm + pIe->offset + offset * i))->
					  num_data;
					pIePresent = ((tDot11fIEosen_ie *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIeqcn_ie:
					offset = sizeof(tDot11fIEqcn_ie);
					status |=
						dot11f_get_packed_ie_qcn_ie(
						pCtx, (tDot11fIEqcn_ie *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				case SigIeroaming_consortium_sel:
					offset = sizeof(tDot11fIEroaming_consortium_sel);
					byteCount = ((tDot11fIEroaming_consortium_sel *)
					  (pFrm + pIe->offset + offset * i))->
					  num_data;
					pIePresent = ((tDot11fIEroaming_consortium_sel *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIesec_chan_offset_ele:
					offset = sizeof(tDot11fIEsec_chan_offset_ele);
					byteCount = 1;
					pIePresent = ((tDot11fIEsec_chan_offset_ele *)
					  (pFrm + pIe->offset + offset * i))->
					  present;
					break;
				case SigIevendor_vht_ie:
					offset = sizeof(tDot11fIEvendor_vht_ie);
					status |=
						dot11f_get_packed_ie_vendor_vht_ie(
						pCtx, (tDot11fIEvendor_vht_ie *)
						(pFrm + pIe->offset + offset * i),
						pnNeeded);
					break;
				default:
					FRAMES_LOG1(pCtx, FRLOGE, FRFL("INTERNAL ERROR-- I don"
						"'t know about the IE signature %d; this is most l"
						"ikely a bug in 'framesc'.\n"), pIe->sig);
					return DOT11F_INTERNAL_ERROR;
				} /*End of switch Case*/

				if (byteCount && pIePresent)
					*pnNeeded += byteCount;
			} /*End of for loop*/
		}
		++pIe;
	}
	return status;

}

static uint32_t get_packed_size_tlv_core(tpAniSirGlobal pCtx,
				uint8_t *pFrm,
				uint32_t *pnNeeded,
				const tTLVDefn  TLVs[])
{
	const tTLVDefn *pTlv;
	uint32_t   status;
	tFRAMES_BOOL   *pfFound;
	uint32_t   byteCount = 0;
	uint8_t    pTlvPresent = 0;

	status = DOT11F_PARSE_SUCCESS;

	pTlv = &(TLVs[0]);
	while (0xffff != pTlv->id) {
		pfFound = (tFRAMES_BOOL *)(pFrm + pTlv->offset +
				pTlv->presenceOffset);
		if (*pfFound) {
			*pnNeeded += (pTlv->sType + pTlv->sLen);
			if (pTlv->pec)
				*pnNeeded += 3U;
			switch (pTlv->sig) {
			case SigTlvAuthorizedMACs:
				byteCount = 6;
				pTlvPresent = ((tDot11fTLVAuthorizedMACs *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvRequestToEnroll:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVRequestToEnroll *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvVersion2:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVVersion2 *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvAPSetupLocked:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVAPSetupLocked *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvAssociationState:
				byteCount = 2;
				pTlvPresent = ((tDot11fTLVAssociationState *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvConfigMethods:
				byteCount = 2;
				pTlvPresent = ((tDot11fTLVConfigMethods *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvConfigurationError:
				byteCount = 2;
				pTlvPresent = ((tDot11fTLVConfigurationError *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvDeviceName:
				byteCount = ((tDot11fTLVDeviceName *)(pFrm + pTlv->offset))->num_text;
				pTlvPresent = ((tDot11fTLVDeviceName *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvDevicePasswordID:
				byteCount = 2;
				pTlvPresent = ((tDot11fTLVDevicePasswordID *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvExtendedListenTiming:
				byteCount = 4;
				pTlvPresent = ((tDot11fTLVExtendedListenTiming *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvListenChannel:
				byteCount = 5;
				pTlvPresent = ((tDot11fTLVListenChannel *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvManufacturer:
				byteCount = ((tDot11fTLVManufacturer *)(pFrm + pTlv->offset))->num_name;
				pTlvPresent = ((tDot11fTLVManufacturer *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvMinorReasonCode:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVMinorReasonCode *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvModelName:
				byteCount = ((tDot11fTLVModelName *)(pFrm + pTlv->offset))->num_text;
				pTlvPresent = ((tDot11fTLVModelName *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvModelNumber:
				byteCount = ((tDot11fTLVModelNumber *)(pFrm + pTlv->offset))->num_text;
				pTlvPresent = ((tDot11fTLVModelNumber *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvNoticeOfAbsence:
				byteCount = ((tDot11fTLVNoticeOfAbsence *)(pFrm + pTlv->offset))->num_NoADesc+2;
				pTlvPresent = ((tDot11fTLVNoticeOfAbsence *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvOperatingChannel:
				byteCount = 5;
				pTlvPresent = ((tDot11fTLVOperatingChannel *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvP2PCapability:
				byteCount = 2;
				pTlvPresent = ((tDot11fTLVP2PCapability *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvP2PDeviceId:
				byteCount = 6;
				pTlvPresent = ((tDot11fTLVP2PDeviceId *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvP2PDeviceInfo:
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pFrm + pTlv->offset, pnNeeded, TLVS_P2PDeviceInfo);
				byteCount = 16;
				pTlvPresent = ((tDot11fTLVP2PDeviceInfo *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvP2PGroupInfo:
				byteCount = ((tDot11fTLVP2PGroupInfo *)(pFrm + pTlv->offset))->num_P2PClientInfoDesc;
				pTlvPresent = ((tDot11fTLVP2PGroupInfo *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvP2PStatus:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVP2PStatus *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvPrimaryDeviceType:
				byteCount = 8;
				pTlvPresent = ((tDot11fTLVPrimaryDeviceType *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvRFBands:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVRFBands *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvRequestDeviceType:
				byteCount = 8;
				pTlvPresent = ((tDot11fTLVRequestDeviceType *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvRequestType:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVRequestType *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvResponseType:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVResponseType *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvSelectedRegistrar:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVSelectedRegistrar *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvSelectedRegistrarConfigMethods:
				byteCount = 2;
				pTlvPresent = ((tDot11fTLVSelectedRegistrarConfigMethods *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvSerialNumber:
				byteCount = ((tDot11fTLVSerialNumber *)(pFrm + pTlv->offset))->num_text;
				pTlvPresent = ((tDot11fTLVSerialNumber *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvUUID_E:
				byteCount = 16;
				pTlvPresent = ((tDot11fTLVUUID_E *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvUUID_R:
				byteCount = 16;
				pTlvPresent = ((tDot11fTLVUUID_R *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvVendorExtension:
		status = get_packed_size_tlv_core(pCtx, (uint8_t *)pFrm + pTlv->offset, pnNeeded, TLVS_VendorExtension);
				byteCount = 3;
				pTlvPresent = ((tDot11fTLVVendorExtension *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvVersion:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVVersion *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvWPSState:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVWPSState *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvassoc_disallowed:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVassoc_disallowed *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvassoc_retry_delay:
				byteCount = 2;
				pTlvPresent = ((tDot11fTLVassoc_retry_delay *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvcellular_data_cap:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVcellular_data_cap *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvcellular_data_con_pref:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVcellular_data_con_pref *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvhe_2xltf_160mhz_supp:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVhe_2xltf_160mhz_supp *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvhe_400ns_sgi_attr:
				byteCount = 3;
				pTlvPresent = ((tDot11fTLVhe_400ns_sgi_attr *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvhe_dl_mumimo_attr:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVhe_dl_mumimo_attr *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvhe_dl_ofdma_attr:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVhe_dl_ofdma_attr *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvhe_mcs13_attr:
				byteCount = 2;
				pTlvPresent = ((tDot11fTLVhe_mcs13_attr *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvmbo_ap_cap:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVmbo_ap_cap *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvnon_prefferd_chan_rep:
				byteCount = ((tDot11fTLVnon_prefferd_chan_rep *)(pFrm + pTlv->offset))->num_channel_report+1;
				pTlvPresent = ((tDot11fTLVnon_prefferd_chan_rep *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvoce_cap:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVoce_cap *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvqcn_version:
				byteCount = 2;
				pTlvPresent = ((tDot11fTLVqcn_version *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvreduced_wan_metrics:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVreduced_wan_metrics *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvrssi_assoc_rej:
				byteCount = 2;
				pTlvPresent = ((tDot11fTLVrssi_assoc_rej *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvtrans_reasonp_attr:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVtrans_reasonp_attr *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvtrans_rejectp_attr:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVtrans_rejectp_attr *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvtransition_reason:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVtransition_reason *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvtransition_reject_reason:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVtransition_reject_reason *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvvht_mcs11_attr:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVvht_mcs11_attr *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvP2PInterface:
				byteCount = 6;
				pTlvPresent = ((tDot11fTLVP2PInterface *)
					      (pFrm + pTlv->offset))->present;
				break;
			case SigTlvP2PManageability:
				byteCount = 1;
				pTlvPresent = ((tDot11fTLVP2PManageability *)
					      (pFrm + pTlv->offset))->present;
				break;
			default:
				FRAMES_LOG1(pCtx, FRLOGE, FRFL("INTERNAL ERROR-- I don"
				    "'t know about the TLV signature %d; this is most l"
				    "ikely a bug in 'framesc'.\n"), pTlv->sig);
				return DOT11F_INTERNAL_ERROR;
			}
			if (pTlvPresent) {
				*pnNeeded += byteCount;
			}
		}
		++pTlv;
	}
	return status;
}
void dot11f_pack_ff_aid(tpAniSirGlobal pCtx,
			tDot11fFfAID *pSrc,
			uint8_t *pBuf)
{
	frameshtons(pCtx, pBuf, pSrc->associd, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_aid. */

void dot11f_pack_ff_action(tpAniSirGlobal pCtx,
			   tDot11fFfAction *pSrc,
			   uint8_t *pBuf)
{
	*pBuf = pSrc->action;
	(void)pCtx;
} /* End dot11f_pack_ff_action. */

void dot11f_pack_ff_auth_algo(tpAniSirGlobal pCtx,
			     tDot11fFfAuthAlgo *pSrc,
			     uint8_t *pBuf)
{
	frameshtons(pCtx, pBuf, pSrc->algo, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_auth_algo. */

void dot11f_pack_ff_auth_seq_no(tpAniSirGlobal pCtx,
			      tDot11fFfAuthSeqNo *pSrc,
			      uint8_t *pBuf)
{
	frameshtons(pCtx, pBuf, pSrc->no, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_auth_seq_no. */

void dot11f_pack_ff_beacon_interval(tpAniSirGlobal pCtx,
				   tDot11fFfBeaconInterval *pSrc,
				   uint8_t *pBuf)
{
	frameshtons(pCtx, pBuf, pSrc->interval, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_beacon_interval. */

void dot11f_pack_ff_capabilities(tpAniSirGlobal pCtx,
				 tDot11fFfCapabilities *pSrc,
				 uint8_t *pBuf)
{
	uint16_t tmp98__;
	tmp98__ = 0U;
	tmp98__ |= (pSrc->ess << 0);
	tmp98__ |= (pSrc->ibss << 1);
	tmp98__ |= (pSrc->cfPollable << 2);
	tmp98__ |= (pSrc->cfPollReq << 3);
	tmp98__ |= (pSrc->privacy << 4);
	tmp98__ |= (pSrc->shortPreamble << 5);
	tmp98__ |= (pSrc->pbcc << 6);
	tmp98__ |= (pSrc->channelAgility << 7);
	tmp98__ |= (pSrc->spectrumMgt << 8);
	tmp98__ |= (pSrc->qos << 9);
	tmp98__ |= (pSrc->shortSlotTime << 10);
	tmp98__ |= (pSrc->apsd << 11);
	tmp98__ |= (pSrc->rrm << 12);
	tmp98__ |= (pSrc->dsssOfdm << 13);
	tmp98__ |= (pSrc->delayedBA << 14);
	tmp98__ |= (pSrc->immediateBA << 15);
	frameshtons(pCtx, pBuf, tmp98__, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_capabilities. */

void dot11f_pack_ff_category(tpAniSirGlobal pCtx,
			     tDot11fFfCategory *pSrc,
			     uint8_t *pBuf)
{
	*pBuf = pSrc->category;
	(void)pCtx;
} /* End dot11f_pack_ff_category. */

void dot11f_pack_ff_current_ap_address(tpAniSirGlobal pCtx,
				     tDot11fFfCurrentAPAddress *pSrc,
				     uint8_t *pBuf)
{
	DOT11F_MEMCPY(pCtx, pBuf, pSrc->mac, 6);
	(void)pCtx;
} /* End dot11f_pack_ff_current_ap_address. */

void dot11f_pack_ff_dialog_token(tpAniSirGlobal pCtx,
				tDot11fFfDialogToken *pSrc,
				uint8_t *pBuf)
{
	*pBuf = pSrc->token;
	(void)pCtx;
} /* End dot11f_pack_ff_dialog_token. */

void dot11f_pack_ff_link_margin(tpAniSirGlobal pCtx,
			       tDot11fFfLinkMargin *pSrc,
			       uint8_t *pBuf)
{
	*pBuf = pSrc->linkMargin;
	(void)pCtx;
} /* End dot11f_pack_ff_link_margin. */

void dot11f_pack_ff_listen_interval(tpAniSirGlobal pCtx,
				   tDot11fFfListenInterval *pSrc,
				   uint8_t *pBuf)
{
	frameshtons(pCtx, pBuf, pSrc->interval, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_listen_interval. */

void dot11f_pack_ff_max_tx_power(tpAniSirGlobal pCtx,
			       tDot11fFfMaxTxPower *pSrc,
			       uint8_t *pBuf)
{
	*pBuf = pSrc->maxTxPower;
	(void)pCtx;
} /* End dot11f_pack_ff_max_tx_power. */

void dot11f_pack_ff_num_of_repetitions(tpAniSirGlobal pCtx,
				     tDot11fFfNumOfRepetitions *pSrc,
				     uint8_t *pBuf)
{
	frameshtons(pCtx, pBuf, pSrc->repetitions, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_num_of_repetitions. */

void dot11f_pack_ff_operating_mode(tpAniSirGlobal pCtx,
				  tDot11fFfOperatingMode *pSrc,
				  uint8_t *pBuf)
{
	uint8_t tmp99__;
	tmp99__ = 0U;
	tmp99__ |= (pSrc->chanWidth << 0);
	tmp99__ |= (pSrc->reserved << 2);
	tmp99__ |= (pSrc->rxNSS << 4);
	tmp99__ |= (pSrc->rxNSSType << 7);
	*pBuf = tmp99__;
	(void)pCtx;
} /* End dot11f_pack_ff_operating_mode. */

void dot11f_pack_ff_rcpi(tpAniSirGlobal pCtx,
			 tDot11fFfRCPI *pSrc,
			 uint8_t *pBuf)
{
	*pBuf = pSrc->rcpi;
	(void)pCtx;
} /* End dot11f_pack_ff_rcpi. */

void dot11f_pack_ff_rsni(tpAniSirGlobal pCtx,
			 tDot11fFfRSNI *pSrc,
			 uint8_t *pBuf)
{
	*pBuf = pSrc->rsni;
	(void)pCtx;
} /* End dot11f_pack_ff_rsni. */

void dot11f_pack_ff_reason(tpAniSirGlobal pCtx,
			   tDot11fFfReason *pSrc,
			   uint8_t *pBuf)
{
	frameshtons(pCtx, pBuf, pSrc->code, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_reason. */

void dot11f_pack_ff_rx_antenna_id(tpAniSirGlobal pCtx,
				tDot11fFfRxAntennaId *pSrc,
				uint8_t *pBuf)
{
	*pBuf = pSrc->antennaId;
	(void)pCtx;
} /* End dot11f_pack_ff_rx_antenna_id. */

void dot11f_pack_ff_sm_power_mode_set(tpAniSirGlobal pCtx,
				   tDot11fFfSMPowerModeSet *pSrc,
				   uint8_t *pBuf)
{
	uint8_t tmp100__;
	tmp100__ = 0U;
	tmp100__ |= (pSrc->PowerSave_En << 0);
	tmp100__ |= (pSrc->Mode << 1);
	tmp100__ |= (pSrc->reserved << 2);
	*pBuf = tmp100__;
	(void)pCtx;
} /* End dot11f_pack_ff_sm_power_mode_set. */

void dot11f_pack_ff_status(tpAniSirGlobal pCtx,
			   tDot11fFfStatus *pSrc,
			   uint8_t *pBuf)
{
	frameshtons(pCtx, pBuf, pSrc->status, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_status. */

void dot11f_pack_ff_status_code(tpAniSirGlobal pCtx,
			       tDot11fFfStatusCode *pSrc,
			       uint8_t *pBuf)
{
	*pBuf = pSrc->statusCode;
	(void)pCtx;
} /* End dot11f_pack_ff_status_code. */

void dot11f_pack_ff_tpc_ele_id(tpAniSirGlobal pCtx,
			     tDot11fFfTPCEleID *pSrc,
			     uint8_t *pBuf)
{
	*pBuf = pSrc->TPCId;
	(void)pCtx;
} /* End dot11f_pack_ff_tpc_ele_id. */

void dot11f_pack_ff_tpc_ele_len(tpAniSirGlobal pCtx,
			      tDot11fFfTPCEleLen *pSrc,
			      uint8_t *pBuf)
{
	*pBuf = pSrc->TPCLen;
	(void)pCtx;
} /* End dot11f_pack_ff_tpc_ele_len. */

void dot11f_pack_ff_ts_info(tpAniSirGlobal pCtx,
			   tDot11fFfTSInfo *pSrc,
			   uint8_t *pBuf)
{
	uint32_t tmp101__;
	tmp101__ = 0U;
	tmp101__ |= (pSrc->traffic_type << 0);
	tmp101__ |= (pSrc->tsid << 1);
	tmp101__ |= (pSrc->direction << 5);
	tmp101__ |= (pSrc->access_policy << 7);
	tmp101__ |= (pSrc->aggregation << 9);
	tmp101__ |= (pSrc->psb << 10);
	tmp101__ |= (pSrc->user_priority << 11);
	tmp101__ |= (pSrc->tsinfo_ack_pol << 14);
	tmp101__ |= (pSrc->schedule << 16);
	tmp101__ |= (pSrc->unused << 17);
	frameshtonl(pCtx, pBuf, tmp101__, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_ts_info. */

void dot11f_pack_ff_time_stamp(tpAniSirGlobal pCtx,
			      tDot11fFfTimeStamp *pSrc,
			      uint8_t *pBuf)
{
	frameshtonq(pCtx, pBuf, pSrc->timestamp, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_time_stamp. */

void dot11f_pack_ff_transaction_id(tpAniSirGlobal pCtx,
				  tDot11fFfTransactionId *pSrc,
				  uint8_t *pBuf)
{
	DOT11F_MEMCPY(pCtx, pBuf, pSrc->transId, 2);
	(void)pCtx;
} /* End dot11f_pack_ff_transaction_id. */

void dot11f_pack_ff_tx_antenna_id(tpAniSirGlobal pCtx,
				tDot11fFfTxAntennaId *pSrc,
				uint8_t *pBuf)
{
	*pBuf = pSrc->antennaId;
	(void)pCtx;
} /* End dot11f_pack_ff_tx_antenna_id. */

void dot11f_pack_ff_tx_power(tpAniSirGlobal pCtx,
			    tDot11fFfTxPower *pSrc,
			    uint8_t *pBuf)
{
	*pBuf = pSrc->txPower;
	(void)pCtx;
} /* End dot11f_pack_ff_tx_power. */

void dot11f_pack_ff_vht_membership_status_array(tpAniSirGlobal pCtx,
					     tDot11fFfVhtMembershipStatusArray *pSrc,
					     uint8_t *pBuf)
{
	DOT11F_MEMCPY(pCtx, pBuf, pSrc->membershipStatusArray, 8);
	(void)pCtx;
} /* End dot11f_pack_ff_vht_membership_status_array. */

void dot11f_pack_ff_vht_user_position_array(tpAniSirGlobal pCtx,
					 tDot11fFfVhtUserPositionArray *pSrc,
					 uint8_t *pBuf)
{
	DOT11F_MEMCPY(pCtx, pBuf, pSrc->userPositionArray, 16);
	(void)pCtx;
} /* End dot11f_pack_ff_vht_user_position_array. */

void dot11f_pack_ff_addba_param_set(tpAniSirGlobal pCtx,
				    tDot11fFfaddba_param_set *pSrc,
				    uint8_t *pBuf)
{
	uint16_t tmp102__;
	tmp102__ = 0U;
	tmp102__ |= (pSrc->amsdu_supp << 0);
	tmp102__ |= (pSrc->policy << 1);
	tmp102__ |= (pSrc->tid << 2);
	tmp102__ |= (pSrc->buff_size << 6);
	frameshtons(pCtx, pBuf, tmp102__, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_addba_param_set. */

void dot11f_pack_ff_ba_start_seq_ctrl(tpAniSirGlobal pCtx,
				      tDot11fFfba_start_seq_ctrl *pSrc,
				      uint8_t *pBuf)
{
	uint16_t tmp103__;
	tmp103__ = 0U;
	tmp103__ |= (pSrc->frag_number << 0);
	tmp103__ |= (pSrc->ssn << 4);
	frameshtons(pCtx, pBuf, tmp103__, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_ba_start_seq_ctrl. */

void dot11f_pack_ff_ba_timeout(tpAniSirGlobal pCtx,
			       tDot11fFfba_timeout *pSrc,
			       uint8_t *pBuf)
{
	frameshtons(pCtx, pBuf, pSrc->timeout, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_ba_timeout. */

void dot11f_pack_ff_delba_param_set(tpAniSirGlobal pCtx,
				    tDot11fFfdelba_param_set *pSrc,
				    uint8_t *pBuf)
{
	uint16_t tmp104__;
	tmp104__ = 0U;
	tmp104__ |= (pSrc->reserved << 0);
	tmp104__ |= (pSrc->initiator << 11);
	tmp104__ |= (pSrc->tid << 12);
	frameshtons(pCtx, pBuf, tmp104__, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_delba_param_set. */

void dot11f_pack_ff_ext_chan_switch_ann_action(tpAniSirGlobal pCtx,
					       tDot11fFfext_chan_switch_ann_action *pSrc,
					       uint8_t *pBuf)
{
	uint32_t tmp105__;
	tmp105__ = 0U;
	tmp105__ |= (pSrc->switch_mode << 0);
	tmp105__ |= (pSrc->op_class << 8);
	tmp105__ |= (pSrc->new_channel << 16);
	tmp105__ |= (pSrc->switch_count << 24);
	frameshtonl(pCtx, pBuf, tmp105__, 0);
	(void)pCtx;
} /* End dot11f_pack_ff_ext_chan_switch_ann_action. */

void dot11f_pack_ff_p2p_action_oui(tpAniSirGlobal pCtx,
				   tDot11fFfp2p_action_oui *pSrc,
				   uint8_t *pBuf)
{
	DOT11F_MEMCPY(pCtx, pBuf, pSrc->oui_data, 4);
	(void)pCtx;
} /* End dot11f_pack_ff_p2p_action_oui. */

void dot11f_pack_ff_p2p_action_subtype(tpAniSirGlobal pCtx,
				       tDot11fFfp2p_action_subtype *pSrc,
				       uint8_t *pBuf)
{
	*pBuf = pSrc->subtype;
	(void)pCtx;
} /* End dot11f_pack_ff_p2p_action_subtype. */

void dot11f_pack_ff_vendor_action_subtype(tpAniSirGlobal pCtx,
					  tDot11fFfvendor_action_subtype *pSrc,
					  uint8_t *pBuf)
{
	*pBuf = pSrc->subtype;
	(void)pCtx;
} /* End dot11f_pack_ff_vendor_action_subtype. */

void dot11f_pack_ff_vendor_oui(tpAniSirGlobal pCtx,
			       tDot11fFfvendor_oui *pSrc,
			       uint8_t *pBuf)
{
	DOT11F_MEMCPY(pCtx, pBuf, pSrc->oui_data, 3);
	(void)pCtx;
} /* End dot11f_pack_ff_vendor_oui. */

uint32_t dot11f_pack_tlv_authorized_ma_cs(tpAniSirGlobal pCtx,
					tDot11fTLVAuthorizedMACs *pSrc,
					uint8_t *pBuf,
					uint32_t nBuf,
					uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 8;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 1;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->mac, 6);
		*pnConsumed += 6;
		pBuf += 6;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_authorized_ma_cs. */

uint32_t dot11f_pack_tlv_request_to_enroll(tpAniSirGlobal pCtx,
					 tDot11fTLVRequestToEnroll *pSrc,
					 uint8_t *pBuf,
					 uint32_t nBuf,
					 uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 3;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->req;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_request_to_enroll. */

uint32_t dot11f_pack_tlv_version2(tpAniSirGlobal pCtx,
				  tDot11fTLVVersion2 *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp106__;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 0;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		tmp106__ = 0U;
		tmp106__ |= (pSrc->minor << 0);
		tmp106__ |= (pSrc->major << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp106__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_version2. */

uint32_t dot11f_pack_tlv_ap_setup_locked(tpAniSirGlobal pCtx,
				       tDot11fTLVAPSetupLocked *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 5;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4183, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		*pBuf = pSrc->fLocked;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_ap_setup_locked. */

uint32_t dot11f_pack_tlv_association_state(tpAniSirGlobal pCtx,
					  tDot11fTLVAssociationState *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 6;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4098, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		frameshtons(pCtx, pBuf, pSrc->state, 1);
		*pnConsumed += 2;
		pBuf += 2;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_association_state. */

uint32_t dot11f_pack_tlv_config_methods(tpAniSirGlobal pCtx,
				       tDot11fTLVConfigMethods *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 6;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4104, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		frameshtons(pCtx, pBuf, pSrc->methods, 1);
		*pnConsumed += 2;
		pBuf += 2;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_config_methods. */

uint32_t dot11f_pack_tlv_configuration_error(tpAniSirGlobal pCtx,
					    tDot11fTLVConfigurationError *pSrc,
					    uint8_t *pBuf,
					    uint32_t nBuf,
					    uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 6;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4105, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		frameshtons(pCtx, pBuf, pSrc->error, 1);
		*pnConsumed += 2;
		pBuf += 2;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_configuration_error. */

uint32_t dot11f_pack_tlv_device_name(tpAniSirGlobal pCtx,
				    tDot11fTLVDeviceName *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += (pSrc->num_text + 4) ;

	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4113, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->text), pSrc->num_text);
		*pnConsumed += pSrc->num_text;
		pBuf += pSrc->num_text;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_device_name. */

uint32_t dot11f_pack_tlv_device_password_id(tpAniSirGlobal pCtx,
					  tDot11fTLVDevicePasswordID *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 6;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4114, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		frameshtons(pCtx, pBuf, pSrc->id, 1);
		*pnConsumed += 2;
		pBuf += 2;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_device_password_id. */

uint32_t dot11f_pack_tlv_extended_listen_timing(tpAniSirGlobal pCtx,
					      tDot11fTLVExtendedListenTiming *pSrc,
					      uint8_t *pBuf,
					      uint32_t nBuf,
					      uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 7;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 8;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		frameshtons(pCtx, pBuf, pSrc->availibilityPeriod, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->availibilityInterval, 0);
		*pnConsumed += 2;
		pBuf += 2;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 3, 0);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_extended_listen_timing. */

uint32_t dot11f_pack_tlv_listen_channel(tpAniSirGlobal pCtx,
				       tDot11fTLVListenChannel *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 8;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 6;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->countryString, 3);
		*pnConsumed += 3;
		pBuf += 3;
		*pBuf = pSrc->regulatoryClass;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->channel;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 3, 0);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_listen_channel. */

uint32_t dot11f_pack_tlv_manufacturer(tpAniSirGlobal pCtx,
				      tDot11fTLVManufacturer *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += (pSrc->num_name + 4) ;

	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4129, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->name), pSrc->num_name);
		*pnConsumed += pSrc->num_name;
		pBuf += pSrc->num_name;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_manufacturer. */

uint32_t dot11f_pack_tlv_minor_reason_code(tpAniSirGlobal pCtx,
					 tDot11fTLVMinorReasonCode *pSrc,
					 uint8_t *pBuf,
					 uint32_t nBuf,
					 uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 4;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 1;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		*pBuf = pSrc->minorReasonCode;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 3, 0);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_minor_reason_code. */

uint32_t dot11f_pack_tlv_model_name(tpAniSirGlobal pCtx,
				   tDot11fTLVModelName *pSrc,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += (pSrc->num_text + 4) ;

	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4131, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->text), pSrc->num_text);
		*pnConsumed += pSrc->num_text;
		pBuf += pSrc->num_text;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_model_name. */

uint32_t dot11f_pack_tlv_model_number(tpAniSirGlobal pCtx,
				     tDot11fTLVModelNumber *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += (pSrc->num_text + 4) ;

	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4132, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->text), pSrc->num_text);
		*pnConsumed += pSrc->num_text;
		pBuf += pSrc->num_text;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_model_number. */

uint32_t dot11f_pack_tlv_notice_of_absence(tpAniSirGlobal pCtx,
					 tDot11fTLVNoticeOfAbsence *pSrc,
					 uint8_t *pBuf,
					 uint32_t nBuf,
					 uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += (pSrc->num_NoADesc + 5) ;

	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 12;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		*pBuf = pSrc->index;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->CTSWindowOppPS;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->NoADesc), pSrc->num_NoADesc);
		*pnConsumed += pSrc->num_NoADesc;
		pBuf += pSrc->num_NoADesc;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 3, 0);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_notice_of_absence. */

uint32_t dot11f_pack_tlv_operating_channel(tpAniSirGlobal pCtx,
					  tDot11fTLVOperatingChannel *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 8;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 17;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->countryString, 3);
		*pnConsumed += 3;
		pBuf += 3;
		*pBuf = pSrc->regulatoryClass;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->channel;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 3, 0);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_operating_channel. */

uint32_t dot11f_pack_tlv_p2_p_capability(tpAniSirGlobal pCtx,
				       tDot11fTLVP2PCapability *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 5;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 2;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		*pBuf = pSrc->deviceCapability;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->groupCapability;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 3, 0);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_p2_p_capability. */

uint32_t dot11f_pack_tlv_p2_p_device_id(tpAniSirGlobal pCtx,
				     tDot11fTLVP2PDeviceId *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 9;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 3;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->P2PDeviceAddress, 6);
		*pnConsumed += 6;
		pBuf += 6;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 3, 0);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_p2_p_device_id. */

uint32_t dot11f_pack_tlv_p2_p_device_info(tpAniSirGlobal pCtx,
				       tDot11fTLVP2PDeviceInfo *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	uint32_t idx = 0;
	nNeeded += 19;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 13;
		pBuf += 1; nBuf -= 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 2; nBuf -= 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->P2PDeviceAddress, 6);
		*pnConsumed += 6;
		pBuf += 6;
		frameshtons(pCtx, pBuf, pSrc->configMethod, 1);
		*pnConsumed += 2;
		pBuf += 2;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->primaryDeviceType, 8);
		*pnConsumed += 8;
		pBuf += 8;
		status |= pack_tlv_core(pCtx,
				(uint8_t *)pSrc,
				pBuf,
				nBuf,
				pnConsumed,
				TLVS_P2PDeviceInfo, &idx);
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 3, 0);
	}
	return status;
} /* End dot11f_pack_tlv_p2_p_device_info. */

uint32_t dot11f_pack_tlv_p2_p_group_info(tpAniSirGlobal pCtx,
				      tDot11fTLVP2PGroupInfo *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += (pSrc->num_P2PClientInfoDesc + 3) ;

	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 14;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->P2PClientInfoDesc), pSrc->num_P2PClientInfoDesc);
		*pnConsumed += pSrc->num_P2PClientInfoDesc;
		pBuf += pSrc->num_P2PClientInfoDesc;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 3, 0);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_p2_p_group_info. */

uint32_t dot11f_pack_tlv_p2_p_status(tpAniSirGlobal pCtx,
				   tDot11fTLVP2PStatus *pSrc,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 4;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 0;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		*pBuf = pSrc->status;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 3, 0);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_p2_p_status. */

uint32_t dot11f_pack_tlv_primary_device_type(tpAniSirGlobal pCtx,
					   tDot11fTLVPrimaryDeviceType *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 12;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4180, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		frameshtons(pCtx, pBuf, pSrc->primary_category, 1);
		*pnConsumed += 2;
		pBuf += 2;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->oui, 4);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtons(pCtx, pBuf, pSrc->sub_category, 1);
		*pnConsumed += 2;
		pBuf += 2;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_primary_device_type. */

uint32_t dot11f_pack_tlv_rf_bands(tpAniSirGlobal pCtx,
				 tDot11fTLVRFBands *pSrc,
				 uint8_t *pBuf,
				 uint32_t nBuf,
				 uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 5;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4156, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		*pBuf = pSrc->bands;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_rf_bands. */

uint32_t dot11f_pack_tlv_request_device_type(tpAniSirGlobal pCtx,
					   tDot11fTLVRequestDeviceType *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 12;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4202, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		frameshtons(pCtx, pBuf, pSrc->primary_category, 1);
		*pnConsumed += 2;
		pBuf += 2;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->oui, 4);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtons(pCtx, pBuf, pSrc->sub_category, 1);
		*pnConsumed += 2;
		pBuf += 2;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_request_device_type. */

uint32_t dot11f_pack_tlv_request_type(tpAniSirGlobal pCtx,
				     tDot11fTLVRequestType *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 5;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4154, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		*pBuf = pSrc->reqType;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_request_type. */

uint32_t dot11f_pack_tlv_response_type(tpAniSirGlobal pCtx,
				      tDot11fTLVResponseType *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 5;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4155, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		*pBuf = pSrc->resType;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_response_type. */

uint32_t dot11f_pack_tlv_selected_registrar(tpAniSirGlobal pCtx,
					   tDot11fTLVSelectedRegistrar *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 5;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4161, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		*pBuf = pSrc->selected;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_selected_registrar. */

uint32_t dot11f_pack_tlv_selected_registrar_config_methods(tpAniSirGlobal pCtx,
							tDot11fTLVSelectedRegistrarConfigMethods *pSrc,
							uint8_t *pBuf,
							uint32_t nBuf,
							uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 6;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4179, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		frameshtons(pCtx, pBuf, pSrc->methods, 1);
		*pnConsumed += 2;
		pBuf += 2;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_selected_registrar_config_methods. */

uint32_t dot11f_pack_tlv_serial_number(tpAniSirGlobal pCtx,
				      tDot11fTLVSerialNumber *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += (pSrc->num_text + 4) ;

	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4162, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->text), pSrc->num_text);
		*pnConsumed += pSrc->num_text;
		pBuf += pSrc->num_text;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_serial_number. */

uint32_t dot11f_pack_tlv_uuid_e(tpAniSirGlobal pCtx,
				tDot11fTLVUUID_E *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 20;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4167, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->uuid, 16);
		*pnConsumed += 16;
		pBuf += 16;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_uuid_e. */

uint32_t dot11f_pack_tlv_uuid_r(tpAniSirGlobal pCtx,
				tDot11fTLVUUID_R *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 20;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4168, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->uuid, 16);
		*pnConsumed += 16;
		pBuf += 16;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_uuid_r. */

uint32_t dot11f_pack_tlv_vendor_extension(tpAniSirGlobal pCtx,
					 tDot11fTLVVendorExtension *pSrc,
					 uint8_t *pBuf,
					 uint32_t nBuf,
					 uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	uint32_t idx = 0;
	nNeeded += 7;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4169, 1);
		pBuf += 2; nBuf -= 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; nBuf -= 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->vendorId, 3);
		*pnConsumed += 3;
		pBuf += 3;
		status |= pack_tlv_core(pCtx,
				(uint8_t *)pSrc,
				pBuf,
				nBuf,
				pnConsumed,
				TLVS_VendorExtension, &idx);
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return status;
} /* End dot11f_pack_tlv_vendor_extension. */

uint32_t dot11f_pack_tlv_version(tpAniSirGlobal pCtx,
				 tDot11fTLVVersion *pSrc,
				 uint8_t *pBuf,
				 uint32_t nBuf,
				 uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp107__;
	nNeeded += 5;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4170, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		tmp107__ = 0U;
		tmp107__ |= (pSrc->minor << 0);
		tmp107__ |= (pSrc->major << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp107__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_version. */

uint32_t dot11f_pack_tlv_wps_state(tpAniSirGlobal pCtx,
				  tDot11fTLVWPSState *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 5;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		frameshtons(pCtx, pBuf, 4164, 1);
		pBuf += 2; *pnConsumed += 2;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		*pBuf = pSrc->state;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 4, 1);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_wps_state. */

uint32_t dot11f_pack_tlv_assoc_disallowed(tpAniSirGlobal pCtx,
					  tDot11fTLVassoc_disallowed *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 4;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->reason_code;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_assoc_disallowed. */

uint32_t dot11f_pack_tlv_assoc_retry_delay(tpAniSirGlobal pCtx,
					   tDot11fTLVassoc_retry_delay *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 4;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 8;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		frameshtons(pCtx, pBuf, pSrc->delay, 0);
		*pnConsumed += 2;
		pBuf += 2;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_assoc_retry_delay. */

uint32_t dot11f_pack_tlv_cellular_data_cap(tpAniSirGlobal pCtx,
					   tDot11fTLVcellular_data_cap *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 3;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->cellular_connectivity;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_cellular_data_cap. */

uint32_t dot11f_pack_tlv_cellular_data_con_pref(tpAniSirGlobal pCtx,
						tDot11fTLVcellular_data_con_pref *pSrc,
						uint8_t *pBuf,
						uint32_t nBuf,
						uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 5;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->cellular_preference;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_cellular_data_con_pref. */

uint32_t dot11f_pack_tlv_he_2xltf_160mhz_supp(tpAniSirGlobal pCtx,
					      tDot11fTLVhe_2xltf_160mhz_supp *pSrc,
					      uint8_t *pBuf,
					      uint32_t nBuf,
					      uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 4;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->he_2xltf_160MHz_supp;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_he_2xltf_160mhz_supp. */

uint32_t dot11f_pack_tlv_he_400ns_sgi_attr(tpAniSirGlobal pCtx,
					   tDot11fTLVhe_400ns_sgi_attr *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 5;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 3;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->he_ltf1x_400ns_sgi;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->he_ltf2x_400ns_sgi;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->he_ltf4x_400ns_sgi;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_he_400ns_sgi_attr. */

uint32_t dot11f_pack_tlv_he_dl_mumimo_attr(tpAniSirGlobal pCtx,
					   tDot11fTLVhe_dl_mumimo_attr *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 8;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->he_dl_mumimo_supp;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_he_dl_mumimo_attr. */

uint32_t dot11f_pack_tlv_he_dl_ofdma_attr(tpAniSirGlobal pCtx,
					  tDot11fTLVhe_dl_ofdma_attr *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 5;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->he_dl_ofdma_supp;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_he_dl_ofdma_attr. */

uint32_t dot11f_pack_tlv_he_mcs13_attr(tpAniSirGlobal pCtx,
				       tDot11fTLVhe_mcs13_attr *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 4;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 9;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->he_mcs_12_13_supp_80;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->he_mcs_12_13_supp_160;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_he_mcs13_attr. */

uint32_t dot11f_pack_tlv_mbo_ap_cap(tpAniSirGlobal pCtx,
				    tDot11fTLVmbo_ap_cap *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 1;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->mbo_cap_ind;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_mbo_ap_cap. */

uint32_t dot11f_pack_tlv_non_prefferd_chan_rep(tpAniSirGlobal pCtx,
					       tDot11fTLVnon_prefferd_chan_rep *pSrc,
					       uint8_t *pBuf,
					       uint32_t nBuf,
					       uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += (pSrc->num_channel_report + 3) ;

	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 2;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->oper_class;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->channel_report), pSrc->num_channel_report);
		*pnConsumed += pSrc->num_channel_report;
		pBuf += pSrc->num_channel_report;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_non_prefferd_chan_rep. */

uint32_t dot11f_pack_tlv_oce_cap(tpAniSirGlobal pCtx,
				 tDot11fTLVoce_cap *pSrc,
				 uint8_t *pBuf,
				 uint32_t nBuf,
				 uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp108__;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 101;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		tmp108__ = 0U;
		tmp108__ |= (pSrc->oce_release << 0);
		tmp108__ |= (pSrc->is_sta_cfon << 3);
		tmp108__ |= (pSrc->non_oce_ap_present << 4);
		tmp108__ |= (pSrc->reserved << 5);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp108__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_oce_cap. */

uint32_t dot11f_pack_tlv_qcn_version(tpAniSirGlobal pCtx,
				     tDot11fTLVqcn_version *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 4;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 1;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->version;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->sub_version;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_qcn_version. */

uint32_t dot11f_pack_tlv_reduced_wan_metrics(tpAniSirGlobal pCtx,
					     tDot11fTLVreduced_wan_metrics *pSrc,
					     uint8_t *pBuf,
					     uint32_t nBuf,
					     uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp109__;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 103;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		tmp109__ = 0U;
		tmp109__ |= (pSrc->downlink_av_cap << 0);
		tmp109__ |= (pSrc->uplink_av_cap << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp109__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_reduced_wan_metrics. */

uint32_t dot11f_pack_tlv_rssi_assoc_rej(tpAniSirGlobal pCtx,
					tDot11fTLVrssi_assoc_rej *pSrc,
					uint8_t *pBuf,
					uint32_t nBuf,
					uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 4;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 102;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->delta_rssi;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->retry_delay;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_rssi_assoc_rej. */

uint32_t dot11f_pack_tlv_trans_reasonp_attr(tpAniSirGlobal pCtx,
					    tDot11fTLVtrans_reasonp_attr *pSrc,
					    uint8_t *pBuf,
					    uint32_t nBuf,
					    uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 6;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->transition_reasonp;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_trans_reasonp_attr. */

uint32_t dot11f_pack_tlv_trans_rejectp_attr(tpAniSirGlobal pCtx,
					    tDot11fTLVtrans_rejectp_attr *pSrc,
					    uint8_t *pBuf,
					    uint32_t nBuf,
					    uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 7;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->transition_rejp;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_trans_rejectp_attr. */

uint32_t dot11f_pack_tlv_transition_reason(tpAniSirGlobal pCtx,
					   tDot11fTLVtransition_reason *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 6;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->transition_reason_code;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_transition_reason. */

uint32_t dot11f_pack_tlv_transition_reject_reason(tpAniSirGlobal pCtx,
						  tDot11fTLVtransition_reject_reason *pSrc,
						  uint8_t *pBuf,
						  uint32_t nBuf,
						  uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 7;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->transition_reject_code;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_transition_reject_reason. */

uint32_t dot11f_pack_tlv_vht_mcs11_attr(tpAniSirGlobal pCtx,
					tDot11fTLVvht_mcs11_attr *pSrc,
					uint8_t *pBuf,
					uint32_t nBuf,
					uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 3;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 2;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 1; *pnConsumed += 1;
		*pBuf = pSrc->vht_mcs_10_11_supp;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		*pTlvLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_vht_mcs11_attr. */

uint32_t dot11f_pack_tlv_p2_p_interface(tpAniSirGlobal pCtx,
				      tDot11fTLVP2PInterface *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 9;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 16;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->P2PDeviceAddress, 6);
		*pnConsumed += 6;
		pBuf += 6;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 3, 0);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_p2_p_interface. */

uint32_t dot11f_pack_tlv_p2_p_manageability(tpAniSirGlobal pCtx,
					  tDot11fTLVP2PManageability *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pTlvLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded += 4;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	while (pSrc->present) {
		*pBuf = 10;
		pBuf += 1; *pnConsumed += 1;
		pTlvLen = pBuf;
		pBuf += 2; *pnConsumed += 2;
		*pBuf = pSrc->manageability;
		*pnConsumed += 1;
		pBuf += 1;
		break;
	}
	(void)pCtx;
	if (pTlvLen) {
		frameshtons(pCtx, pTlvLen, *pnConsumed - nConsumedOnEntry - 3, 0);
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_tlv_p2_p_manageability. */

uint32_t dot11f_pack_ie_gtk(tpAniSirGlobal pCtx,
			    tDot11fIEGTK *pSrc,
			    uint8_t *pBuf,
			    uint32_t nBuf,
			    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint16_t tmp110__;
	nNeeded  +=  (pSrc->num_key + 11);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 2;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp110__ = 0U;
		tmp110__ |= (pSrc->keyId << 0);
		tmp110__ |= (pSrc->reserved << 2);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp110__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		*pBuf = pSrc->keyLength;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->RSC, 8);
		*pnConsumed += 8;
		pBuf += 8;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->key), pSrc->num_key);
		*pnConsumed += pSrc->num_key;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_gtk. */

uint32_t dot11f_pack_ie_igtk(tpAniSirGlobal pCtx,
			     tDot11fIEIGTK *pSrc,
			     uint8_t *pBuf,
			     uint32_t nBuf,
			     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 33;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 4;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->keyID, 2);
		*pnConsumed += 2;
		pBuf += 2;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->IPN, 6);
		*pnConsumed += 6;
		pBuf += 6;
		*pBuf = pSrc->keyLength;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->key, 24);
		*pnConsumed += 24;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_igtk. */

uint32_t dot11f_pack_ie_r0_kh_id(tpAniSirGlobal pCtx,
				tDot11fIER0KH_ID *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_PMK_R0_ID;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 3;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->PMK_R0_ID), pSrc->num_PMK_R0_ID);
		*pnConsumed += pSrc->num_PMK_R0_ID;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_r0_kh_id. */

uint32_t dot11f_pack_ie_r1_kh_id(tpAniSirGlobal pCtx,
				tDot11fIER1KH_ID *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 6;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 1;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->PMK_R1_ID, 6);
		*pnConsumed += 6;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_r1_kh_id. */

uint32_t dot11f_pack_ie_ap_channel_report(tpAniSirGlobal pCtx,
					tDot11fIEAPChannelReport *pSrc,
					uint8_t *pBuf,
					uint32_t nBuf,
					uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  (pSrc->num_channelList + 1);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 51;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->regulatoryClass;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->channelList), pSrc->num_channelList);
		*pnConsumed += pSrc->num_channelList;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ap_channel_report. */

uint32_t dot11f_pack_ie_bcn_reporting_detail(tpAniSirGlobal pCtx,
					   tDot11fIEBcnReportingDetail *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 2;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->reportingDetail;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_bcn_reporting_detail. */

uint32_t dot11f_pack_ie_beacon_report_frm_body(tpAniSirGlobal pCtx,
					    tDot11fIEBeaconReportFrmBody *pSrc,
					    uint8_t *pBuf,
					    uint32_t nBuf,
					    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_reportedFields;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 1;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->reportedFields), pSrc->num_reportedFields);
		*pnConsumed += pSrc->num_reportedFields;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_beacon_report_frm_body. */

uint32_t dot11f_pack_ie_beacon_reporting(tpAniSirGlobal pCtx,
					tDot11fIEBeaconReporting *pSrc,
					uint8_t *pBuf,
					uint32_t nBuf,
					uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 1;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->reportingCondition;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->threshold;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_beacon_reporting. */

uint32_t dot11f_pack_ie_condensed_country_str(tpAniSirGlobal pCtx,
					    tDot11fIECondensedCountryStr *pSrc,
					    uint8_t *pBuf,
					    uint32_t nBuf,
					    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 2;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->countryStr, 2);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_condensed_country_str. */

uint32_t dot11f_pack_ie_measurement_pilot(tpAniSirGlobal pCtx,
					 tDot11fIEMeasurementPilot *pSrc,
					 uint8_t *pBuf,
					 uint32_t nBuf,
					 uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  (pSrc->num_vendorSpecific + 1);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 66;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->measurementPilot;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->vendorSpecific), pSrc->num_vendorSpecific);
		*pnConsumed += pSrc->num_vendorSpecific;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_measurement_pilot. */

uint32_t dot11f_pack_ie_multi_bssid(tpAniSirGlobal pCtx,
				   tDot11fIEMultiBssid *pSrc,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  (pSrc->num_vendorSpecific + 1);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 71;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->maxBSSIDIndicator;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->vendorSpecific), pSrc->num_vendorSpecific);
		*pnConsumed += pSrc->num_vendorSpecific;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_multi_bssid. */

uint32_t dot11f_pack_ie_ric_data(tpAniSirGlobal pCtx,
				tDot11fIERICData *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 4;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 57;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->Identifier;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->resourceDescCount;
		*pnConsumed += 1;
		pBuf += 1;
		frameshtons(pCtx, pBuf, pSrc->statusCode, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ric_data. */

uint32_t dot11f_pack_ie_ric_descriptor(tpAniSirGlobal pCtx,
				      tDot11fIERICDescriptor *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  (pSrc->num_variableData + 1);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 75;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->resourceType;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->variableData), pSrc->num_variableData);
		*pnConsumed += pSrc->num_variableData;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ric_descriptor. */

uint32_t dot11f_pack_ie_rrm_enabled_cap(tpAniSirGlobal pCtx,
				      tDot11fIERRMEnabledCap *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp111__;
	uint8_t tmp112__;
	uint8_t tmp113__;
	uint8_t tmp114__;
	uint8_t tmp115__;
	nNeeded  += 5;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 70;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp111__ = 0U;
		tmp111__ |= (pSrc->LinkMeasurement << 0);
		tmp111__ |= (pSrc->NeighborRpt << 1);
		tmp111__ |= (pSrc->parallel << 2);
		tmp111__ |= (pSrc->repeated << 3);
		tmp111__ |= (pSrc->BeaconPassive << 4);
		tmp111__ |= (pSrc->BeaconActive << 5);
		tmp111__ |= (pSrc->BeaconTable << 6);
		tmp111__ |= (pSrc->BeaconRepCond << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp111__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp112__ = 0U;
		tmp112__ |= (pSrc->FrameMeasurement << 0);
		tmp112__ |= (pSrc->ChannelLoad << 1);
		tmp112__ |= (pSrc->NoiseHistogram << 2);
		tmp112__ |= (pSrc->statistics << 3);
		tmp112__ |= (pSrc->LCIMeasurement << 4);
		tmp112__ |= (pSrc->LCIAzimuth << 5);
		tmp112__ |= (pSrc->TCMCapability << 6);
		tmp112__ |= (pSrc->triggeredTCM << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp112__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp113__ = 0U;
		tmp113__ |= (pSrc->APChanReport << 0);
		tmp113__ |= (pSrc->RRMMIBEnabled << 1);
		tmp113__ |= (pSrc->operatingChanMax << 2);
		tmp113__ |= (pSrc->nonOperatinChanMax << 5);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp113__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp114__ = 0U;
		tmp114__ |= (pSrc->MeasurementPilot << 0);
		tmp114__ |= (pSrc->MeasurementPilotEnabled << 3);
		tmp114__ |= (pSrc->NeighborTSFOffset << 4);
		tmp114__ |= (pSrc->RCPIMeasurement << 5);
		tmp114__ |= (pSrc->RSNIMeasurement << 6);
		tmp114__ |= (pSrc->BssAvgAccessDelay << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp114__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp115__ = 0U;
		tmp115__ |= (pSrc->BSSAvailAdmission << 0);
		tmp115__ |= (pSrc->AntennaInformation << 1);
		tmp115__ |= (pSrc->fine_time_meas_rpt << 2);
		tmp115__ |= (pSrc->lci_capability << 3);
		tmp115__ |= (pSrc->reserved << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp115__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_rrm_enabled_cap. */

uint32_t dot11f_pack_ie_requested_info(tpAniSirGlobal pCtx,
				      tDot11fIERequestedInfo *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_requested_eids;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 10;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->requested_eids), pSrc->num_requested_eids);
		*pnConsumed += pSrc->num_requested_eids;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_requested_info. */

uint32_t dot11f_pack_ie_ssid(tpAniSirGlobal pCtx,
			     tDot11fIESSID *pSrc,
			     uint8_t *pBuf,
			     uint32_t nBuf,
			     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_ssid;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 0;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->ssid), pSrc->num_ssid);
		*pnConsumed += pSrc->num_ssid;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ssid. */

uint32_t dot11f_pack_ie_schedule(tpAniSirGlobal pCtx,
				 tDot11fIESchedule *pSrc,
				 uint8_t *pBuf,
				 uint32_t nBuf,
				 uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint16_t tmp116__;
	nNeeded  += 14;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 15;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp116__ = 0U;
		tmp116__ |= (pSrc->aggregation << 0);
		tmp116__ |= (pSrc->tsid << 1);
		tmp116__ |= (pSrc->direction << 5);
		tmp116__ |= (pSrc->reserved << 7);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp116__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		frameshtonl(pCtx, pBuf, pSrc->service_start_time, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->service_interval, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtons(pCtx, pBuf, pSrc->max_service_dur, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->spec_interval, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_schedule. */

uint32_t dot11f_pack_ie_tclas(tpAniSirGlobal pCtx,
			      tDot11fIETCLAS *pSrc,
			      uint8_t *pBuf,
			      uint32_t nBuf,
			      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ietclas(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 14;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->user_priority;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->classifier_type;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->classifier_mask;
		*pnConsumed += 1;
		pBuf += 1;
		switch (pSrc->classifier_type) {
		case 0:
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.EthParams.source, 6);
			*pnConsumed += 6;
			pBuf += 6;
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.EthParams.dest, 6);
			*pnConsumed += 6;
			pBuf += 6;
			frameshtons(pCtx, pBuf, pSrc->info.EthParams.type, 0);
			*pnConsumed += 2;
			/* fieldsEndFlag = 1 */
			break;
		case 1:
			*pBuf = pSrc->info.IpParams.version;
			*pnConsumed += 1;
			pBuf += 1;
			switch (pSrc->info.IpParams.version) {
			case 4:
				DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.IpParams.params.IpV4Params.source, 4);
				*pnConsumed += 4;
				pBuf += 4;
				DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.IpParams.params.IpV4Params.dest, 4);
				*pnConsumed += 4;
				pBuf += 4;
				frameshtons(pCtx, pBuf, pSrc->info.IpParams.params.IpV4Params.src_port, 0);
				*pnConsumed += 2;
				pBuf += 2;
				frameshtons(pCtx, pBuf, pSrc->info.IpParams.params.IpV4Params.dest_port, 0);
				*pnConsumed += 2;
				pBuf += 2;
				*pBuf = pSrc->info.IpParams.params.IpV4Params.DSCP;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->info.IpParams.params.IpV4Params.proto;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->info.IpParams.params.IpV4Params.reserved;
				*pnConsumed += 1;
				/* fieldsEndFlag = 1 */
				break;
			case 6:
				DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.IpParams.params.IpV6Params.source, 16);
				*pnConsumed += 16;
				pBuf += 16;
				DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.IpParams.params.IpV6Params.dest, 16);
				*pnConsumed += 16;
				pBuf += 16;
				frameshtons(pCtx, pBuf, pSrc->info.IpParams.params.IpV6Params.src_port, 0);
				*pnConsumed += 2;
				pBuf += 2;
				frameshtons(pCtx, pBuf, pSrc->info.IpParams.params.IpV6Params.dest_port, 0);
				*pnConsumed += 2;
				pBuf += 2;
				DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.IpParams.params.IpV6Params.flow_label, 3);
				*pnConsumed += 3;
				/* fieldsEndFlag = 1 */
				break;
			}
			break;
		case 2:
			frameshtons(pCtx, pBuf, pSrc->info.Params8021dq.tag_type, 0);
			*pnConsumed += 2;
			/* fieldsEndFlag = 1 */
			break;
		}
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_tclas. */

uint32_t dot11f_pack_ie_tclassproc(tpAniSirGlobal pCtx,
				   tDot11fIETCLASSPROC *pSrc,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 44;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->processing;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_tclassproc. */

uint32_t dot11f_pack_ie_ts_delay(tpAniSirGlobal pCtx,
				tDot11fIETSDelay *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 4;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 43;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		frameshtonl(pCtx, pBuf, pSrc->delay, 0);
		*pnConsumed += 4;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ts_delay. */

uint32_t dot11f_pack_ie_tsf_info(tpAniSirGlobal pCtx,
				tDot11fIETSFInfo *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 4;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 1;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		frameshtons(pCtx, pBuf, pSrc->TsfOffset, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->BeaconIntvl, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_tsf_info. */

uint32_t dot11f_pack_ie_tspec(tpAniSirGlobal pCtx,
			      tDot11fIETSPEC *pSrc,
			      uint8_t *pBuf,
			      uint32_t nBuf,
			      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint16_t tmp117__;
	uint8_t tmp118__;
	uint16_t tmp119__;
	nNeeded  += 55;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 13;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp117__ = 0U;
		tmp117__ |= (pSrc->traffic_type << 0);
		tmp117__ |= (pSrc->tsid << 1);
		tmp117__ |= (pSrc->direction << 5);
		tmp117__ |= (pSrc->access_policy << 7);
		tmp117__ |= (pSrc->aggregation << 9);
		tmp117__ |= (pSrc->psb << 10);
		tmp117__ |= (pSrc->user_priority << 11);
		tmp117__ |= (pSrc->tsinfo_ack_pol << 14);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp117__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		tmp118__ = 0U;
		tmp118__ |= (pSrc->schedule << 0);
		tmp118__ |= (pSrc->unused << 1);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp118__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp119__ = 0U;
		tmp119__ |= (pSrc->size << 0);
		tmp119__ |= (pSrc->fixed << 15);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp119__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		frameshtons(pCtx, pBuf, pSrc->max_msdu_size, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtonl(pCtx, pBuf, pSrc->min_service_int, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->max_service_int, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->inactivity_int, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->suspension_int, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->service_start_time, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->min_data_rate, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->mean_data_rate, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->peak_data_rate, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->burst_size, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->delay_bound, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->min_phy_rate, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtons(pCtx, pBuf, pSrc->surplus_bw_allowance, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->medium_time, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_tspec. */

uint32_t dot11f_pack_ie_vht_caps(tpAniSirGlobal pCtx,
				tDot11fIEVHTCaps *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint32_t tmp120__;
	uint16_t tmp121__;
	uint16_t tmp122__;
	nNeeded  += 12;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 191;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp120__ = 0U;
		tmp120__ |= (pSrc->maxMPDULen << 0);
		tmp120__ |= (pSrc->supportedChannelWidthSet << 2);
		tmp120__ |= (pSrc->ldpcCodingCap << 4);
		tmp120__ |= (pSrc->shortGI80MHz << 5);
		tmp120__ |= (pSrc->shortGI160and80plus80MHz << 6);
		tmp120__ |= (pSrc->txSTBC << 7);
		tmp120__ |= (pSrc->rxSTBC << 8);
		tmp120__ |= (pSrc->suBeamFormerCap << 11);
		tmp120__ |= (pSrc->suBeamformeeCap << 12);
		tmp120__ |= (pSrc->csnofBeamformerAntSup << 13);
		tmp120__ |= (pSrc->numSoundingDim << 16);
		tmp120__ |= (pSrc->muBeamformerCap << 19);
		tmp120__ |= (pSrc->muBeamformeeCap << 20);
		tmp120__ |= (pSrc->vhtTXOPPS << 21);
		tmp120__ |= (pSrc->htcVHTCap << 22);
		tmp120__ |= (pSrc->maxAMPDULenExp << 23);
		tmp120__ |= (pSrc->vhtLinkAdaptCap << 26);
		tmp120__ |= (pSrc->rxAntPattern << 28);
		tmp120__ |= (pSrc->txAntPattern << 29);
		tmp120__ |= (pSrc->extended_nss_bw_supp << 30);
		if (unlikely(nBuf < 4))
			return DOT11F_INCOMPLETE_IE;

		frameshtonl(pCtx, pBuf, tmp120__, 0);
		*pnConsumed += 4;
		pBuf += 4;
		nBuf -=  4 ;
		frameshtons(pCtx, pBuf, pSrc->rxMCSMap, 0);
		*pnConsumed += 2;
		pBuf += 2;
		tmp121__ = 0U;
		tmp121__ |= (pSrc->rxHighSupDataRate << 0);
		tmp121__ |= (pSrc->max_nsts_total << 13);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp121__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		frameshtons(pCtx, pBuf, pSrc->txMCSMap, 0);
		*pnConsumed += 2;
		pBuf += 2;
		tmp122__ = 0U;
		tmp122__ |= (pSrc->txSupDataRate << 0);
		tmp122__ |= (pSrc->vht_extended_nss_bw_cap << 13);
		tmp122__ |= (pSrc->reserved << 14);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp122__, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag  = 1 */
		nBuf -=  2 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_vht_caps. */

uint32_t dot11f_pack_ie_vht_operation(tpAniSirGlobal pCtx,
				     tDot11fIEVHTOperation *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 5;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 192;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->chanWidth;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->chan_center_freq_seg0;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->chan_center_freq_seg1;
		*pnConsumed += 1;
		pBuf += 1;
		frameshtons(pCtx, pBuf, pSrc->basicMCSSet, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_vht_operation. */

uint32_t dot11f_pack_ie_wmm_schedule(tpAniSirGlobal pCtx,
				    tDot11fIEWMMSchedule *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint16_t tmp123__;
	nNeeded  += 15;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x9;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->version;
		*pnConsumed += 1;
		pBuf += 1;
		tmp123__ = 0U;
		tmp123__ |= (pSrc->aggregation << 0);
		tmp123__ |= (pSrc->tsid << 1);
		tmp123__ |= (pSrc->direction << 5);
		tmp123__ |= (pSrc->reserved << 7);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp123__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		frameshtonl(pCtx, pBuf, pSrc->service_start_time, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->service_interval, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtons(pCtx, pBuf, pSrc->max_service_dur, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->spec_interval, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wmm_schedule. */

uint32_t dot11f_pack_ie_wmmtclas(tpAniSirGlobal pCtx,
				 tDot11fIEWMMTCLAS *pSrc,
				 uint8_t *pBuf,
				 uint32_t nBuf,
				 uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_iewmmtclas(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x6;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->version;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->user_priority;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->classifier_type;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->classifier_mask;
		*pnConsumed += 1;
		pBuf += 1;
		switch (pSrc->classifier_type) {
		case 0:
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.EthParams.source, 6);
			*pnConsumed += 6;
			pBuf += 6;
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.EthParams.dest, 6);
			*pnConsumed += 6;
			pBuf += 6;
			frameshtons(pCtx, pBuf, pSrc->info.EthParams.type, 0);
			*pnConsumed += 2;
			/* fieldsEndFlag = 1 */
			break;
		case 1:
			*pBuf = pSrc->info.IpParams.version;
			*pnConsumed += 1;
			pBuf += 1;
			switch (pSrc->info.IpParams.version) {
			case 4:
				DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.IpParams.params.IpV4Params.source, 4);
				*pnConsumed += 4;
				pBuf += 4;
				DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.IpParams.params.IpV4Params.dest, 4);
				*pnConsumed += 4;
				pBuf += 4;
				frameshtons(pCtx, pBuf, pSrc->info.IpParams.params.IpV4Params.src_port, 0);
				*pnConsumed += 2;
				pBuf += 2;
				frameshtons(pCtx, pBuf, pSrc->info.IpParams.params.IpV4Params.dest_port, 0);
				*pnConsumed += 2;
				pBuf += 2;
				*pBuf = pSrc->info.IpParams.params.IpV4Params.DSCP;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->info.IpParams.params.IpV4Params.proto;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->info.IpParams.params.IpV4Params.reserved;
				*pnConsumed += 1;
				/* fieldsEndFlag = 1 */
				break;
			case 6:
				DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.IpParams.params.IpV6Params.source, 10);
				*pnConsumed += 10;
				pBuf += 10;
				DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.IpParams.params.IpV6Params.dest, 10);
				*pnConsumed += 10;
				pBuf += 10;
				frameshtons(pCtx, pBuf, pSrc->info.IpParams.params.IpV6Params.src_port, 0);
				*pnConsumed += 2;
				pBuf += 2;
				frameshtons(pCtx, pBuf, pSrc->info.IpParams.params.IpV6Params.dest_port, 0);
				*pnConsumed += 2;
				pBuf += 2;
				DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.IpParams.params.IpV6Params.flow_label, 3);
				*pnConsumed += 3;
				/* fieldsEndFlag = 1 */
				break;
			}
			break;
		case 2:
			frameshtons(pCtx, pBuf, pSrc->info.Params8021dq.tag_type, 0);
			*pnConsumed += 2;
			/* fieldsEndFlag = 1 */
			break;
		}
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_wmmtclas. */

uint32_t dot11f_pack_ie_wmmtclasproc(tpAniSirGlobal pCtx,
				     tDot11fIEWMMTCLASPROC *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x7;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->version;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->processing;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wmmtclasproc. */

uint32_t dot11f_pack_ie_wmmts_delay(tpAniSirGlobal pCtx,
				   tDot11fIEWMMTSDelay *pSrc,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 5;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x8;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->version;
		*pnConsumed += 1;
		pBuf += 1;
		frameshtonl(pCtx, pBuf, pSrc->delay, 0);
		*pnConsumed += 4;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wmmts_delay. */

uint32_t dot11f_pack_ie_wmmtspec(tpAniSirGlobal pCtx,
				 tDot11fIEWMMTSPEC *pSrc,
				 uint8_t *pBuf,
				 uint32_t nBuf,
				 uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint16_t tmp124__;
	uint8_t tmp125__;
	uint16_t tmp126__;
	nNeeded  += 38;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x2;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->version;
		*pnConsumed += 1;
		pBuf += 1;
		tmp124__ = 0U;
		tmp124__ |= (pSrc->traffic_type << 0);
		tmp124__ |= (pSrc->tsid << 1);
		tmp124__ |= (pSrc->direction << 5);
		tmp124__ |= (pSrc->access_policy << 7);
		tmp124__ |= (pSrc->aggregation << 9);
		tmp124__ |= (pSrc->psb << 10);
		tmp124__ |= (pSrc->user_priority << 11);
		tmp124__ |= (pSrc->tsinfo_ack_pol << 14);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp124__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		tmp125__ = 0U;
		tmp125__ |= (pSrc->tsinfo_rsvd << 0);
		tmp125__ |= (pSrc->burst_size_defn << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp125__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp126__ = 0U;
		tmp126__ |= (pSrc->size << 0);
		tmp126__ |= (pSrc->fixed << 15);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp126__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		frameshtons(pCtx, pBuf, pSrc->max_msdu_size, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtonl(pCtx, pBuf, pSrc->min_service_int, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->max_service_int, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->inactivity_int, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->suspension_int, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->service_start_time, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->min_data_rate, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->mean_data_rate, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->peak_data_rate, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->burst_size, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->delay_bound, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtonl(pCtx, pBuf, pSrc->min_phy_rate, 0);
		*pnConsumed += 4;
		pBuf += 4;
		frameshtons(pCtx, pBuf, pSrc->surplus_bw_allowance, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->medium_time, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wmmtspec. */

uint32_t dot11f_pack_ie_wider_bw_chan_switch_ann(tpAniSirGlobal pCtx,
					     tDot11fIEWiderBWChanSwitchAnn *pSrc,
					     uint8_t *pBuf,
					     uint32_t nBuf,
					     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 3;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 194;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->newChanWidth;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->newCenterChanFreq0;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->newCenterChanFreq1;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wider_bw_chan_switch_ann. */

uint32_t dot11f_pack_ie_azimuth_req(tpAniSirGlobal pCtx,
				    tDot11fIEazimuth_req *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 1;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->request;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_azimuth_req. */

uint32_t dot11f_pack_ie_beacon_report_frm_body_fragment_id(tpAniSirGlobal pCtx,
							   tDot11fIEbeacon_report_frm_body_fragment_id *pSrc,
							   uint8_t *pBuf,
							   uint32_t nBuf,
							   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint16_t tmp127__;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 2;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp127__ = 0U;
		tmp127__ |= (pSrc->beacon_report_id << 0);
		tmp127__ |= (pSrc->fragment_id_number << 8);
		tmp127__ |= (pSrc->more_fragments << 15);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp127__, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag  = 1 */
		nBuf -=  2 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_beacon_report_frm_body_fragment_id. */

uint32_t dot11f_pack_ie_last_beacon_report_indication(tpAniSirGlobal pCtx,
						      tDot11fIElast_beacon_report_indication *pSrc,
						      uint8_t *pBuf,
						      uint32_t nBuf,
						      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 164;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->last_fragment;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_last_beacon_report_indication. */

uint32_t dot11f_pack_ie_max_age(tpAniSirGlobal pCtx,
				tDot11fIEmax_age *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 4;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		frameshtons(pCtx, pBuf, pSrc->max_age, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_max_age. */

uint32_t dot11f_pack_ie_mscs_status(tpAniSirGlobal pCtx,
				    tDot11fIEmscs_status *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 76;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->status_code;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_mscs_status. */

uint32_t dot11f_pack_ie_neighbor_rpt(tpAniSirGlobal pCtx,
				     tDot11fIEneighbor_rpt *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp128__;
	uint8_t tmp129__;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ie_neighbor_rpt(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 52;
		++pBuf; --nBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; --nBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->bssid, 6);
		*pnConsumed += 6;
		pBuf += 6;
		tmp128__ = 0U;
		tmp128__ |= (pSrc->APReachability << 0);
		tmp128__ |= (pSrc->Security << 2);
		tmp128__ |= (pSrc->KeyScope << 3);
		tmp128__ |= (pSrc->SpecMgmtCap << 4);
		tmp128__ |= (pSrc->QosCap << 5);
		tmp128__ |= (pSrc->apsd << 6);
		tmp128__ |= (pSrc->rrm << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp128__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp129__ = 0U;
		tmp129__ |= (pSrc->DelayedBA << 0);
		tmp129__ |= (pSrc->ImmBA << 1);
		tmp129__ |= (pSrc->MobilityDomain << 2);
		tmp129__ |= (pSrc->reserved << 3);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp129__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		frameshtons(pCtx, pBuf, pSrc->reserved1, 0);
		*pnConsumed += 2;
		pBuf += 2;
		*pBuf = pSrc->regulatoryClass;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->channel;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->PhyType;
		*pnConsumed += 1;
		pBuf += 1;
		status = pack_core(pCtx,
				(uint8_t *)pSrc,
				pBuf,
				nBuf,
				pnConsumed,
				FFS_neighbor_rpt,
				IES_neighbor_rpt);
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_neighbor_rpt. */

uint32_t dot11f_pack_ie_req_mac_addr(tpAniSirGlobal pCtx,
				     tDot11fIEreq_mac_addr *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 6;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 2;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->addr, 6);
		*pnConsumed += 6;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_req_mac_addr. */

uint32_t dot11f_pack_ie_tclas_mask(tpAniSirGlobal pCtx,
				   tDot11fIEtclas_mask *pSrc,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ie_tclas_mask(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 89;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->classifier_type;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->classifier_mask;
		*pnConsumed += 1;
		pBuf += 1;
		switch (pSrc->classifier_type) {
		case 4:
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->info.ip_param.reserved, 16);
			*pnConsumed += 16;
			/* fieldsEndFlag = 1 */
			break;
		}
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_tclas_mask. */

uint32_t dot11f_pack_ie_tgt_mac_addr(tpAniSirGlobal pCtx,
				     tDot11fIEtgt_mac_addr *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 6;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 3;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->addr, 6);
		*pnConsumed += 6;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_tgt_mac_addr. */

uint32_t dot11f_pack_ie_transmit_power_env(tpAniSirGlobal pCtx,
					   tDot11fIEtransmit_power_env *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp130__;
	nNeeded  +=  (pSrc->num_tx_power + 1);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 195;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp130__ = 0U;
		tmp130__ |= (pSrc->max_tx_pwr_count << 0);
		tmp130__ |= (pSrc->max_tx_pwr_interpret << 3);
		tmp130__ |= (pSrc->max_tx_pwr_category << 6);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp130__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->tx_power), pSrc->num_tx_power);
		*pnConsumed += pSrc->num_tx_power;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_transmit_power_env. */

uint32_t dot11f_pack_ie_aid(tpAniSirGlobal pCtx,
			    tDot11fIEAID *pSrc,
			    uint8_t *pBuf,
			    uint32_t nBuf,
			    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 197;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		frameshtons(pCtx, pBuf, pSrc->assocId, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_aid. */

uint32_t dot11f_pack_ie_cf_params(tpAniSirGlobal pCtx,
				 tDot11fIECFParams *pSrc,
				 uint8_t *pBuf,
				 uint32_t nBuf,
				 uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 6;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 4;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->cfp_count;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->cfp_period;
		*pnConsumed += 1;
		pBuf += 1;
		frameshtons(pCtx, pBuf, pSrc->cfp_maxduration, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->cfp_durremaining, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_cf_params. */

uint32_t dot11f_pack_ie_challenge_text(tpAniSirGlobal pCtx,
				      tDot11fIEChallengeText *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_text;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 16;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->text), pSrc->num_text);
		*pnConsumed += pSrc->num_text;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_challenge_text. */

uint32_t dot11f_pack_ie_chan_switch_ann(tpAniSirGlobal pCtx,
				      tDot11fIEChanSwitchAnn *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 3;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 37;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->switchMode;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->newChannel;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->switchCount;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_chan_switch_ann. */

uint32_t dot11f_pack_ie_channel_switch_wrapper(tpAniSirGlobal pCtx,
					     tDot11fIEChannelSwitchWrapper *pSrc,
					     uint8_t *pBuf,
					     uint32_t nBuf,
					     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ie_channel_switch_wrapper(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 196;
		++pBuf; --nBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; --nBuf; ++(*pnConsumed);
		status = pack_core(pCtx,
				(uint8_t *)pSrc,
				pBuf,
				nBuf,
				pnConsumed,
				FFS_ChannelSwitchWrapper,
				IES_ChannelSwitchWrapper);
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_channel_switch_wrapper. */

uint32_t dot11f_pack_ie_country(tpAniSirGlobal pCtx,
				tDot11fIECountry *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ie_country(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 7;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->country, 3);
		*pnConsumed += 3;
		pBuf += 3;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->first_triplet, 3);
		*pnConsumed += 3;
		pBuf += 3;
		if (pSrc->num_more_triplets) {
			DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->more_triplets), (pSrc->num_more_triplets * 3));
			*pnConsumed += (pSrc->num_more_triplets * 3);
			/* fieldsEndFlag = 1 */
		} else {
			break;
		}
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_country. */

uint32_t dot11f_pack_ie_ds_params(tpAniSirGlobal pCtx,
				 tDot11fIEDSParams *pSrc,
				 uint8_t *pBuf,
				 uint32_t nBuf,
				 uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 3;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->curr_channel;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ds_params. */

uint32_t dot11f_pack_ie_edca_param_set(tpAniSirGlobal pCtx,
				     tDot11fIEEDCAParamSet *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp131__;
	uint8_t tmp132__;
	uint8_t tmp133__;
	uint8_t tmp134__;
	uint8_t tmp135__;
	uint8_t tmp136__;
	uint8_t tmp137__;
	uint8_t tmp138__;
	nNeeded  += 18;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 12;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->qos;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->reserved;
		*pnConsumed += 1;
		pBuf += 1;
		tmp131__ = 0U;
		tmp131__ |= (pSrc->acbe_aifsn << 0);
		tmp131__ |= (pSrc->acbe_acm << 4);
		tmp131__ |= (pSrc->acbe_aci << 5);
		tmp131__ |= (pSrc->unused1 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp131__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp132__ = 0U;
		tmp132__ |= (pSrc->acbe_acwmin << 0);
		tmp132__ |= (pSrc->acbe_acwmax << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp132__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		frameshtons(pCtx, pBuf, pSrc->acbe_txoplimit, 0);
		*pnConsumed += 2;
		pBuf += 2;
		tmp133__ = 0U;
		tmp133__ |= (pSrc->acbk_aifsn << 0);
		tmp133__ |= (pSrc->acbk_acm << 4);
		tmp133__ |= (pSrc->acbk_aci << 5);
		tmp133__ |= (pSrc->unused2 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp133__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp134__ = 0U;
		tmp134__ |= (pSrc->acbk_acwmin << 0);
		tmp134__ |= (pSrc->acbk_acwmax << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp134__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		frameshtons(pCtx, pBuf, pSrc->acbk_txoplimit, 0);
		*pnConsumed += 2;
		pBuf += 2;
		tmp135__ = 0U;
		tmp135__ |= (pSrc->acvi_aifsn << 0);
		tmp135__ |= (pSrc->acvi_acm << 4);
		tmp135__ |= (pSrc->acvi_aci << 5);
		tmp135__ |= (pSrc->unused3 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp135__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp136__ = 0U;
		tmp136__ |= (pSrc->acvi_acwmin << 0);
		tmp136__ |= (pSrc->acvi_acwmax << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp136__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		frameshtons(pCtx, pBuf, pSrc->acvi_txoplimit, 0);
		*pnConsumed += 2;
		pBuf += 2;
		tmp137__ = 0U;
		tmp137__ |= (pSrc->acvo_aifsn << 0);
		tmp137__ |= (pSrc->acvo_acm << 4);
		tmp137__ |= (pSrc->acvo_aci << 5);
		tmp137__ |= (pSrc->unused4 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp137__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp138__ = 0U;
		tmp138__ |= (pSrc->acvo_acwmin << 0);
		tmp138__ |= (pSrc->acvo_acwmax << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp138__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		frameshtons(pCtx, pBuf, pSrc->acvo_txoplimit, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_edca_param_set. */

uint32_t dot11f_pack_ie_erp_info(tpAniSirGlobal pCtx,
				tDot11fIEERPInfo *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp139__;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 42;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp139__ = 0U;
		tmp139__ |= (pSrc->non_erp_present << 0);
		tmp139__ |= (pSrc->use_prot << 1);
		tmp139__ |= (pSrc->barker_preamble << 2);
		tmp139__ |= (pSrc->unused << 3);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp139__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_erp_info. */

uint32_t dot11f_pack_ie_ese_cckm_opaque(tpAniSirGlobal pCtx,
				      tDot11fIEESECckmOpaque *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_data;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 156;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x40;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x96;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->data), pSrc->num_data);
		*pnConsumed += pSrc->num_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ese_cckm_opaque. */

uint32_t dot11f_pack_ie_ese_rad_mgmt_cap(tpAniSirGlobal pCtx,
				      tDot11fIEESERadMgmtCap *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp140__;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x40;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x96;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x1;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->mgmt_state;
		*pnConsumed += 1;
		pBuf += 1;
		tmp140__ = 0U;
		tmp140__ |= (pSrc->mbssid_mask << 0);
		tmp140__ |= (pSrc->reserved << 3);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp140__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ese_rad_mgmt_cap. */

uint32_t dot11f_pack_ie_ese_traf_strm_met(tpAniSirGlobal pCtx,
				       tDot11fIEESETrafStrmMet *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 4;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x40;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x96;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x7;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->tsid;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->state;
		*pnConsumed += 1;
		pBuf += 1;
		frameshtons(pCtx, pBuf, pSrc->msmt_interval, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ese_traf_strm_met. */

uint32_t dot11f_pack_ie_ese_traf_strm_rate_set(tpAniSirGlobal pCtx,
					   tDot11fIEESETrafStrmRateSet *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  (pSrc->num_tsrates + 1);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x40;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x96;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x8;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->tsid;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->tsrates), pSrc->num_tsrates);
		*pnConsumed += pSrc->num_tsrates;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ese_traf_strm_rate_set. */

uint32_t dot11f_pack_ie_ese_txmit_power(tpAniSirGlobal pCtx,
				      tDot11fIEESETxmitPower *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 150;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x40;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x96;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->power_limit;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->reserved;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ese_txmit_power. */

uint32_t dot11f_pack_ie_ese_version(tpAniSirGlobal pCtx,
				   tDot11fIEESEVersion *pSrc,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x40;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x96;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x3;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->version;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ese_version. */

uint32_t dot11f_pack_ie_ext_cap(tpAniSirGlobal pCtx,
			       tDot11fIEExtCap *pSrc,
			       uint8_t *pBuf,
			       uint32_t nBuf,
			       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_bytes;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 127;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->bytes), pSrc->num_bytes);
		*pnConsumed += pSrc->num_bytes;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ext_cap. */

uint32_t dot11f_pack_ie_ext_supp_rates(tpAniSirGlobal pCtx,
				     tDot11fIEExtSuppRates *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_rates;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 50;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->rates), pSrc->num_rates);
		*pnConsumed += pSrc->num_rates;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ext_supp_rates. */

uint32_t dot11f_pack_ie_fh_param_set(tpAniSirGlobal pCtx,
				   tDot11fIEFHParamSet *pSrc,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 5;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 2;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		frameshtons(pCtx, pBuf, pSrc->dwell_time, 0);
		*pnConsumed += 2;
		pBuf += 2;
		*pBuf = pSrc->hop_set;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->hop_pattern;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->hop_index;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fh_param_set. */

uint32_t dot11f_pack_ie_fh_params(tpAniSirGlobal pCtx,
				 tDot11fIEFHParams *pSrc,
				 uint8_t *pBuf,
				 uint32_t nBuf,
				 uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 8;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->radix;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->nchannels;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fh_params. */

uint32_t dot11f_pack_ie_fh_patt_table(tpAniSirGlobal pCtx,
				    tDot11fIEFHPattTable *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  (pSrc->num_randtable + 4);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 9;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->flag;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->nsets;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->modulus;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->offset;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->randtable), pSrc->num_randtable);
		*pnConsumed += pSrc->num_randtable;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fh_patt_table. */

uint32_t dot11f_pack_ie_ft_info(tpAniSirGlobal pCtx,
			       tDot11fIEFTInfo *pSrc,
			       uint8_t *pBuf,
			       uint32_t nBuf,
			       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint16_t tmp141__;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ieft_info(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 55;
		++pBuf; --nBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; --nBuf; ++(*pnConsumed);
		tmp141__ = 0U;
		tmp141__ |= (pSrc->reserved << 0);
		tmp141__ |= (pSrc->IECount << 8);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp141__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->MIC, 16);
		*pnConsumed += 16;
		pBuf += 16;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->Anonce, 32);
		*pnConsumed += 32;
		pBuf += 32;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->Snonce, 32);
		*pnConsumed += 32;
		pBuf += 32;
		status = pack_core(pCtx,
				(uint8_t *)pSrc,
				pBuf,
				nBuf,
				pnConsumed,
				FFS_FTInfo,
				IES_FTInfo);
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_ft_info. */

uint32_t dot11f_pack_ie_ht_caps(tpAniSirGlobal pCtx,
			       tDot11fIEHTCaps *pSrc,
			       uint8_t *pBuf,
			       uint32_t nBuf,
			       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint16_t tmp142__;
	uint8_t tmp143__;
	uint16_t tmp144__;
	uint32_t tmp145__;
	uint8_t tmp146__;
	nNeeded  +=  (pSrc->num_rsvd + 26);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 45;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp142__ = 0U;
		tmp142__ |= (pSrc->advCodingCap << 0);
		tmp142__ |= (pSrc->supportedChannelWidthSet << 1);
		tmp142__ |= (pSrc->mimoPowerSave << 2);
		tmp142__ |= (pSrc->greenField << 4);
		tmp142__ |= (pSrc->shortGI20MHz << 5);
		tmp142__ |= (pSrc->shortGI40MHz << 6);
		tmp142__ |= (pSrc->txSTBC << 7);
		tmp142__ |= (pSrc->rxSTBC << 8);
		tmp142__ |= (pSrc->delayedBA << 10);
		tmp142__ |= (pSrc->maximalAMSDUsize << 11);
		tmp142__ |= (pSrc->dsssCckMode40MHz << 12);
		tmp142__ |= (pSrc->psmp << 13);
		tmp142__ |= (pSrc->stbcControlFrame << 14);
		tmp142__ |= (pSrc->lsigTXOPProtection << 15);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp142__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		tmp143__ = 0U;
		tmp143__ |= (pSrc->maxRxAMPDUFactor << 0);
		tmp143__ |= (pSrc->mpduDensity << 2);
		tmp143__ |= (pSrc->reserved1 << 5);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp143__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->supportedMCSSet, 16);
		*pnConsumed += 16;
		pBuf += 16;
		tmp144__ = 0U;
		tmp144__ |= (pSrc->pco << 0);
		tmp144__ |= (pSrc->transitionTime << 1);
		tmp144__ |= (pSrc->reserved2 << 3);
		tmp144__ |= (pSrc->mcsFeedback << 8);
		tmp144__ |= (pSrc->reserved3 << 10);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp144__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		tmp145__ = 0U;
		tmp145__ |= (pSrc->txBF << 0);
		tmp145__ |= (pSrc->rxStaggeredSounding << 1);
		tmp145__ |= (pSrc->txStaggeredSounding << 2);
		tmp145__ |= (pSrc->rxZLF << 3);
		tmp145__ |= (pSrc->txZLF << 4);
		tmp145__ |= (pSrc->implicitTxBF << 5);
		tmp145__ |= (pSrc->calibration << 6);
		tmp145__ |= (pSrc->explicitCSITxBF << 8);
		tmp145__ |= (pSrc->explicitUncompressedSteeringMatrix << 9);
		tmp145__ |= (pSrc->explicitBFCSIFeedback << 10);
		tmp145__ |= (pSrc->explicitUncompressedSteeringMatrixFeedback << 13);
		tmp145__ |= (pSrc->explicitCompressedSteeringMatrixFeedback << 16);
		tmp145__ |= (pSrc->csiNumBFAntennae << 19);
		tmp145__ |= (pSrc->uncompressedSteeringMatrixBFAntennae << 21);
		tmp145__ |= (pSrc->compressedSteeringMatrixBFAntennae << 23);
		tmp145__ |= (pSrc->reserved4 << 25);
		if (unlikely(nBuf < 4))
			return DOT11F_INCOMPLETE_IE;

		frameshtonl(pCtx, pBuf, tmp145__, 0);
		*pnConsumed += 4;
		pBuf += 4;
		nBuf -=  4 ;
		tmp146__ = 0U;
		tmp146__ |= (pSrc->antennaSelection << 0);
		tmp146__ |= (pSrc->explicitCSIFeedbackTx << 1);
		tmp146__ |= (pSrc->antennaIndicesFeedbackTx << 2);
		tmp146__ |= (pSrc->explicitCSIFeedback << 3);
		tmp146__ |= (pSrc->antennaIndicesFeedback << 4);
		tmp146__ |= (pSrc->rxAS << 5);
		tmp146__ |= (pSrc->txSoundingPPDUs << 6);
		tmp146__ |= (pSrc->reserved5 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp146__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->rsvd), pSrc->num_rsvd);
		*pnConsumed += pSrc->num_rsvd;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ht_caps. */

uint32_t dot11f_pack_ie_ht_info(tpAniSirGlobal pCtx,
			       tDot11fIEHTInfo *pSrc,
			       uint8_t *pBuf,
			       uint32_t nBuf,
			       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp147__;
	uint16_t tmp148__;
	uint16_t tmp149__;
	nNeeded  +=  (pSrc->num_rsvd + 22);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 61;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->primaryChannel;
		*pnConsumed += 1;
		pBuf += 1;
		tmp147__ = 0U;
		tmp147__ |= (pSrc->secondaryChannelOffset << 0);
		tmp147__ |= (pSrc->recommendedTxWidthSet << 2);
		tmp147__ |= (pSrc->rifsMode << 3);
		tmp147__ |= (pSrc->controlledAccessOnly << 4);
		tmp147__ |= (pSrc->serviceIntervalGranularity << 5);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp147__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp148__ = 0U;
		tmp148__ |= (pSrc->opMode << 0);
		tmp148__ |= (pSrc->nonGFDevicesPresent << 2);
		tmp148__ |= (pSrc->transmitBurstLimit << 3);
		tmp148__ |= (pSrc->obssNonHTStaPresent << 4);
		tmp148__ |= (pSrc->chan_center_freq_seg2 << 5);
		tmp148__ |= (pSrc->reserved << 13);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp148__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		tmp149__ = 0U;
		tmp149__ |= (pSrc->basicSTBCMCS << 0);
		tmp149__ |= (pSrc->dualCTSProtection << 7);
		tmp149__ |= (pSrc->secondaryBeacon << 8);
		tmp149__ |= (pSrc->lsigTXOPProtectionFullSupport << 9);
		tmp149__ |= (pSrc->pcoActive << 10);
		tmp149__ |= (pSrc->pcoPhase << 11);
		tmp149__ |= (pSrc->reserved2 << 12);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp149__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->basicMCSSet, 16);
		*pnConsumed += 16;
		pBuf += 16;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->rsvd), pSrc->num_rsvd);
		*pnConsumed += pSrc->num_rsvd;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ht_info. */

uint32_t dot11f_pack_ie_link_identifier(tpAniSirGlobal pCtx,
				       tDot11fIELinkIdentifier *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 18;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 101;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->bssid, 6);
		*pnConsumed += 6;
		pBuf += 6;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->InitStaAddr, 6);
		*pnConsumed += 6;
		pBuf += 6;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->RespStaAddr, 6);
		*pnConsumed += 6;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_link_identifier. */

uint32_t dot11f_pack_ie_MBO_IE(tpAniSirGlobal pCtx,
			       tDot11fIEMBO_IE *pSrc,
			       uint8_t *pBuf,
			       uint32_t nBuf,
			       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_ie_MBO_IE(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x6f;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9a;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x16;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_MBO_IE +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_MBO_IE. */

uint32_t dot11f_pack_ie_measurement_report(tpAniSirGlobal pCtx,
					  tDot11fIEMeasurementReport *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp150__;
	uint8_t tmp151__;
	uint8_t tmp152__;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ie_measurement_report(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 39;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->token;
		*pnConsumed += 1;
		pBuf += 1;
		tmp150__ = 0U;
		tmp150__ |= (pSrc->late << 0);
		tmp150__ |= (pSrc->incapable << 1);
		tmp150__ |= (pSrc->refused << 2);
		tmp150__ |= (pSrc->unused << 3);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp150__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		*pBuf = pSrc->type;
		*pnConsumed += 1;
		pBuf += 1;
		if (pSrc->type) {
			switch (pSrc->type) {
			case 0:
				*pBuf = pSrc->report.Basic.channel;
				*pnConsumed += 1;
				pBuf += 1;
				frameshtonq(pCtx, pBuf, pSrc->report.Basic.meas_start_time, 0);
				*pnConsumed += 8;
				pBuf += 8;
				frameshtons(pCtx, pBuf, pSrc->report.Basic.meas_duration, 0);
				*pnConsumed += 2;
				pBuf += 2;
				tmp151__ = 0U;
				tmp151__ |= (pSrc->report.Basic.bss << 0);
				tmp151__ |= (pSrc->report.Basic.ofdm_preamble << 1);
				tmp151__ |= (pSrc->report.Basic.unid_signal << 2);
				tmp151__ |= (pSrc->report.Basic.rader << 3);
				tmp151__ |= (pSrc->report.Basic.unmeasured << 4);
				tmp151__ |= (pSrc->report.Basic.unused << 5);
				if (unlikely(nBuf < 1))
					return DOT11F_INCOMPLETE_IE;

				*pBuf = tmp151__;
				*pnConsumed += 1;
				/* fieldsEndFlag  = 1 */
				nBuf -=  1 ;
				break;
			case 1:
				*pBuf = pSrc->report.CCA.channel;
				*pnConsumed += 1;
				pBuf += 1;
				frameshtonq(pCtx, pBuf, pSrc->report.CCA.meas_start_time, 0);
				*pnConsumed += 8;
				pBuf += 8;
				frameshtons(pCtx, pBuf, pSrc->report.CCA.meas_duration, 0);
				*pnConsumed += 2;
				pBuf += 2;
				*pBuf = pSrc->report.CCA.cca_busy_fraction;
				*pnConsumed += 1;
				/* fieldsEndFlag = 1 */
				break;
			case 2:
				*pBuf = pSrc->report.RPIHistogram.channel;
				*pnConsumed += 1;
				pBuf += 1;
				frameshtonq(pCtx, pBuf, pSrc->report.RPIHistogram.meas_start_time, 0);
				*pnConsumed += 8;
				pBuf += 8;
				frameshtons(pCtx, pBuf, pSrc->report.RPIHistogram.meas_duration, 0);
				*pnConsumed += 2;
				pBuf += 2;
				*pBuf = pSrc->report.RPIHistogram.rpi0_density;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->report.RPIHistogram.rpi1_density;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->report.RPIHistogram.rpi2_density;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->report.RPIHistogram.rpi3_density;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->report.RPIHistogram.rpi4_density;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->report.RPIHistogram.rpi5_density;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->report.RPIHistogram.rpi6_density;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->report.RPIHistogram.rpi7_density;
				*pnConsumed += 1;
				/* fieldsEndFlag = 1 */
				break;
			case 5:
				*pBuf = pSrc->report.Beacon.regClass;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->report.Beacon.channel;
				*pnConsumed += 1;
				pBuf += 1;
				frameshtonq(pCtx, pBuf, pSrc->report.Beacon.meas_start_time, 0);
				*pnConsumed += 8;
				pBuf += 8;
				frameshtons(pCtx, pBuf, pSrc->report.Beacon.meas_duration, 0);
				*pnConsumed += 2;
				pBuf += 2;
				tmp152__ = 0U;
				tmp152__ |= (pSrc->report.Beacon.condensed_PHY << 0);
				tmp152__ |= (pSrc->report.Beacon.reported_frame_type << 7);
				if (unlikely(nBuf < 1))
					return DOT11F_INCOMPLETE_IE;

				*pBuf = tmp152__;
				*pnConsumed += 1;
				pBuf += 1;
				nBuf -=  1 ;
				*pBuf = pSrc->report.Beacon.RCPI;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->report.Beacon.RSNI;
				*pnConsumed += 1;
				pBuf += 1;
				DOT11F_MEMCPY(pCtx, pBuf, pSrc->report.Beacon.BSSID, 6);
				*pnConsumed += 6;
				pBuf += 6;
				*pBuf = pSrc->report.Beacon.antenna_id;
				*pnConsumed += 1;
				pBuf += 1;
				frameshtonl(pCtx, pBuf, pSrc->report.Beacon.parent_TSF, 0);
				*pnConsumed += 4;
				pBuf += 4;
				status = pack_core(pCtx,
					 (uint8_t *)pSrc,
					 pBuf,
					 nBuf,
					 pnConsumed,
					 FFS_reportBeacon,
					 IES_reportBeacon);
				break;
			}
		} else {
			break;
		}
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_measurement_report. */

uint32_t dot11f_pack_ie_measurement_request(tpAniSirGlobal pCtx,
					   tDot11fIEMeasurementRequest *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp153__;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ie_measurement_request(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 38;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->measurement_token;
		*pnConsumed += 1;
		pBuf += 1;
		tmp153__ = 0U;
		tmp153__ |= (pSrc->parallel << 0);
		tmp153__ |= (pSrc->enable << 1);
		tmp153__ |= (pSrc->request << 2);
		tmp153__ |= (pSrc->report << 3);
		tmp153__ |= (pSrc->durationMandatory << 4);
		tmp153__ |= (pSrc->unused << 5);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp153__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		*pBuf = pSrc->measurement_type;
		*pnConsumed += 1;
		pBuf += 1;
		switch (pSrc->measurement_type) {
		case 0:
			*pBuf = pSrc->measurement_request.Basic.channel_no;
			*pnConsumed += 1;
			pBuf += 1;
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->measurement_request.Basic.meas_start_time, 8);
			*pnConsumed += 8;
			pBuf += 8;
			frameshtons(pCtx, pBuf, pSrc->measurement_request.Basic.meas_duration, 0);
			*pnConsumed += 2;
			/* fieldsEndFlag = 1 */
			break;
		case 1:
			*pBuf = pSrc->measurement_request.CCA.channel_no;
			*pnConsumed += 1;
			pBuf += 1;
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->measurement_request.CCA.meas_start_time, 8);
			*pnConsumed += 8;
			pBuf += 8;
			frameshtons(pCtx, pBuf, pSrc->measurement_request.CCA.meas_duration, 0);
			*pnConsumed += 2;
			/* fieldsEndFlag = 1 */
			break;
		case 2:
			*pBuf = pSrc->measurement_request.RPIHistogram.channel_no;
			*pnConsumed += 1;
			pBuf += 1;
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->measurement_request.RPIHistogram.meas_start_time, 8);
			*pnConsumed += 8;
			pBuf += 8;
			frameshtons(pCtx, pBuf, pSrc->measurement_request.RPIHistogram.meas_duration, 0);
			*pnConsumed += 2;
			/* fieldsEndFlag = 1 */
			break;
		case 5:
			*pBuf = pSrc->measurement_request.Beacon.regClass;
			*pnConsumed += 1;
			pBuf += 1;
			*pBuf = pSrc->measurement_request.Beacon.channel;
			*pnConsumed += 1;
			pBuf += 1;
			frameshtons(pCtx, pBuf, pSrc->measurement_request.Beacon.randomization, 0);
			*pnConsumed += 2;
			pBuf += 2;
			frameshtons(pCtx, pBuf, pSrc->measurement_request.Beacon.meas_duration, 0);
			*pnConsumed += 2;
			pBuf += 2;
			*pBuf = pSrc->measurement_request.Beacon.meas_mode;
			*pnConsumed += 1;
			pBuf += 1;
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->measurement_request.Beacon.BSSID, 6);
			*pnConsumed += 6;
			pBuf += 6;
			status = pack_core(pCtx,
				 (uint8_t *)pSrc,
				 pBuf,
				 nBuf,
				 pnConsumed,
				 FFS_measurement_requestBeacon,
				 IES_measurement_requestBeacon);
			break;
		case 8:
			*pBuf = pSrc->measurement_request.lci.loc_subject;
			*pnConsumed += 1;
			pBuf += 1;
			status = pack_core(pCtx,
				 (uint8_t *)pSrc,
				 pBuf,
				 nBuf,
				 pnConsumed,
				 FFS_measurement_requestlci,
				 IES_measurement_requestlci);
			break;
		case 16:
			frameshtons(pCtx, pBuf, pSrc->measurement_request.ftmrr.random_interval, 0);
			*pnConsumed += 2;
			pBuf += 2;
			*pBuf = pSrc->measurement_request.ftmrr.min_ap_count;
			*pnConsumed += 1;
			pBuf += 1;
			status = pack_core(pCtx,
				 (uint8_t *)pSrc,
				 pBuf,
				 nBuf,
				 pnConsumed,
				 FFS_measurement_requestftmrr,
				 IES_measurement_requestftmrr);
			break;
		}
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_measurement_request. */

uint32_t dot11f_pack_ie_mobility_domain(tpAniSirGlobal pCtx,
				       tDot11fIEMobilityDomain *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp154__;
	nNeeded  += 3;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 54;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		frameshtons(pCtx, pBuf, pSrc->MDID, 0);
		*pnConsumed += 2;
		pBuf += 2;
		tmp154__ = 0U;
		tmp154__ |= (pSrc->overDSCap << 0);
		tmp154__ |= (pSrc->resourceReqCap << 1);
		tmp154__ |= (pSrc->reserved << 2);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp154__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_mobility_domain. */

uint32_t dot11f_pack_ie_neighbor_report(tpAniSirGlobal pCtx,
				       tDot11fIENeighborReport *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp155__;
	uint8_t tmp156__;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ie_neighbor_report(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 52;
		++pBuf; --nBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; --nBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->bssid, 6);
		*pnConsumed += 6;
		pBuf += 6;
		tmp155__ = 0U;
		tmp155__ |= (pSrc->APReachability << 0);
		tmp155__ |= (pSrc->Security << 2);
		tmp155__ |= (pSrc->KeyScope << 3);
		tmp155__ |= (pSrc->SpecMgmtCap << 4);
		tmp155__ |= (pSrc->QosCap << 5);
		tmp155__ |= (pSrc->apsd << 6);
		tmp155__ |= (pSrc->rrm << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp155__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp156__ = 0U;
		tmp156__ |= (pSrc->DelayedBA << 0);
		tmp156__ |= (pSrc->ImmBA << 1);
		tmp156__ |= (pSrc->MobilityDomain << 2);
		tmp156__ |= (pSrc->reserved << 3);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp156__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		frameshtons(pCtx, pBuf, pSrc->reserved1, 0);
		*pnConsumed += 2;
		pBuf += 2;
		*pBuf = pSrc->regulatoryClass;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->channel;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->PhyType;
		*pnConsumed += 1;
		pBuf += 1;
		status = pack_core(pCtx,
				(uint8_t *)pSrc,
				pBuf,
				nBuf,
				pnConsumed,
				FFS_NeighborReport,
				IES_NeighborReport);
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_neighbor_report. */

uint32_t dot11f_pack_ie_obss_scan_parameters(tpAniSirGlobal pCtx,
					   tDot11fIEOBSSScanParameters *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 14;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 74;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		frameshtons(pCtx, pBuf, pSrc->obssScanPassiveDwell, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->obssScanActiveDwell, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->bssChannelWidthTriggerScanInterval, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->obssScanPassiveTotalPerChannel, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->obssScanActiveTotalPerChannel, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->bssWidthChannelTransitionDelayFactor, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->obssScanActivityThreshold, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_obss_scan_parameters. */

uint32_t dot11f_pack_ie_operating_mode(tpAniSirGlobal pCtx,
				      tDot11fIEOperatingMode *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp157__;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 199;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp157__ = 0U;
		tmp157__ |= (pSrc->chanWidth << 0);
		tmp157__ |= (pSrc->vht_160_80p80_supp << 2);
		tmp157__ |= (pSrc->no_ldpc << 3);
		tmp157__ |= (pSrc->rxNSS << 4);
		tmp157__ |= (pSrc->rxNSSType << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp157__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_operating_mode. */

uint32_t dot11f_pack_ie_p2_p_assoc_req(tpAniSirGlobal pCtx,
				    tDot11fIEP2PAssocReq *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_iep2_p_assoc_req(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x6f;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9a;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_P2PAssocReq +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_p2_p_assoc_req. */

uint32_t dot11f_pack_ie_p2_p_assoc_res(tpAniSirGlobal pCtx,
				    tDot11fIEP2PAssocRes *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_iep2_p_assoc_res(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x6f;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9a;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_P2PAssocRes +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_p2_p_assoc_res. */

uint32_t dot11f_pack_ie_p2_p_beacon(tpAniSirGlobal pCtx,
				  tDot11fIEP2PBeacon *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_iep2_p_beacon(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x6f;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9a;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_P2PBeacon +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_p2_p_beacon. */

uint32_t dot11f_pack_ie_p2_p_beacon_probe_res(tpAniSirGlobal pCtx,
					  tDot11fIEP2PBeaconProbeRes *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_iep2_p_beacon_probe_res(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x6f;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9a;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_P2PBeaconProbeRes +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_p2_p_beacon_probe_res. */

uint32_t dot11f_pack_ie_p2_p_de_auth(tpAniSirGlobal pCtx,
				  tDot11fIEP2PDeAuth *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_iep2_p_de_auth(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x6f;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9a;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_P2PDeAuth +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_p2_p_de_auth. */

uint32_t dot11f_pack_ie_p2_p_dis_assoc(tpAniSirGlobal pCtx,
				    tDot11fIEP2PDisAssoc *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_iep2_p_dis_assoc(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x6f;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9a;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_P2PDisAssoc +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_p2_p_dis_assoc. */

uint32_t dot11f_pack_ie_p2_pie_opaque(tpAniSirGlobal pCtx,
				    tDot11fIEP2PIEOpaque *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_data;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x6f;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x9a;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x9;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->data), pSrc->num_data);
		*pnConsumed += pSrc->num_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_p2_pie_opaque. */

uint32_t dot11f_pack_ie_p2_p_probe_req(tpAniSirGlobal pCtx,
				    tDot11fIEP2PProbeReq *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_iep2_p_probe_req(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x6f;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9a;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_P2PProbeReq +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_p2_p_probe_req. */

uint32_t dot11f_pack_ie_p2_p_probe_res(tpAniSirGlobal pCtx,
				    tDot11fIEP2PProbeRes *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_iep2_p_probe_res(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x6f;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9a;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x9;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_P2PProbeRes +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_p2_p_probe_res. */

uint32_t dot11f_pack_ie_pti_control(tpAniSirGlobal pCtx,
				   tDot11fIEPTIControl *pSrc,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 3;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 105;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->tid;
		*pnConsumed += 1;
		pBuf += 1;
		frameshtons(pCtx, pBuf, pSrc->sequence_control, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_pti_control. */

uint32_t dot11f_pack_ie_pu_buffer_status(tpAniSirGlobal pCtx,
				       tDot11fIEPUBufferStatus *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp158__;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 106;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp158__ = 0U;
		tmp158__ |= (pSrc->ac_bk_traffic_aval << 0);
		tmp158__ |= (pSrc->ac_be_traffic_aval << 1);
		tmp158__ |= (pSrc->ac_vi_traffic_aval << 2);
		tmp158__ |= (pSrc->ac_vo_traffic_aval << 3);
		tmp158__ |= (pSrc->reserved << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp158__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_pu_buffer_status. */

uint32_t dot11f_pack_ie_power_caps(tpAniSirGlobal pCtx,
				  tDot11fIEPowerCaps *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 33;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->minTxPower;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->maxTxPower;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_power_caps. */

uint32_t dot11f_pack_ie_power_constraints(tpAniSirGlobal pCtx,
					 tDot11fIEPowerConstraints *pSrc,
					 uint8_t *pBuf,
					 uint32_t nBuf,
					 uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 32;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->localPowerConstraints;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_power_constraints. */

uint32_t dot11f_pack_ie_qbss_load(tpAniSirGlobal pCtx,
				 tDot11fIEQBSSLoad *pSrc,
				 uint8_t *pBuf,
				 uint32_t nBuf,
				 uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 5;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 11;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		frameshtons(pCtx, pBuf, pSrc->stacount, 0);
		*pnConsumed += 2;
		pBuf += 2;
		*pBuf = pSrc->chautil;
		*pnConsumed += 1;
		pBuf += 1;
		frameshtons(pCtx, pBuf, pSrc->avail, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_qbss_load. */

uint32_t dot11f_pack_ie_QComVendorIE(tpAniSirGlobal pCtx,
				     tDot11fIEQComVendorIE *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xa0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xc6;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->type;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->channel;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_QComVendorIE. */

uint32_t dot11f_pack_ie_qos_caps_ap(tpAniSirGlobal pCtx,
				  tDot11fIEQOSCapsAp *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp159__;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 46;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp159__ = 0U;
		tmp159__ |= (pSrc->count << 0);
		tmp159__ |= (pSrc->qack << 4);
		tmp159__ |= (pSrc->qreq << 5);
		tmp159__ |= (pSrc->txopreq << 6);
		tmp159__ |= (pSrc->reserved << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp159__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_qos_caps_ap. */

uint32_t dot11f_pack_ie_qos_caps_station(tpAniSirGlobal pCtx,
				       tDot11fIEQOSCapsStation *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp160__;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 46;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp160__ = 0U;
		tmp160__ |= (pSrc->acvo_uapsd << 0);
		tmp160__ |= (pSrc->acvi_uapsd << 1);
		tmp160__ |= (pSrc->acbk_uapsd << 2);
		tmp160__ |= (pSrc->acbe_uapsd << 3);
		tmp160__ |= (pSrc->qack << 4);
		tmp160__ |= (pSrc->max_sp_length << 5);
		tmp160__ |= (pSrc->more_data_ack << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp160__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_qos_caps_station. */

uint32_t dot11f_pack_ie_qos_map_set(tpAniSirGlobal pCtx,
				  tDot11fIEQosMapSet *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_dscp_exceptions;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 110;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->dscp_exceptions), pSrc->num_dscp_exceptions);
		*pnConsumed += pSrc->num_dscp_exceptions;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_qos_map_set. */

uint32_t dot11f_pack_ie_quiet(tpAniSirGlobal pCtx,
			      tDot11fIEQuiet *pSrc,
			      uint8_t *pBuf,
			      uint32_t nBuf,
			      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 6;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 40;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->count;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->period;
		*pnConsumed += 1;
		pBuf += 1;
		frameshtons(pCtx, pBuf, pSrc->duration, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->offset, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_quiet. */

uint32_t dot11f_pack_ie_rcpiie(tpAniSirGlobal pCtx,
			       tDot11fIERCPIIE *pSrc,
			       uint8_t *pBuf,
			       uint32_t nBuf,
			       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 53;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->rcpi;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_rcpiie. */

uint32_t dot11f_pack_ie_ric_data_desc(tpAniSirGlobal pCtx,
				    tDot11fIERICDataDesc *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint32_t nNeeded = 0U;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ieric_data_desc(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		status = pack_core(pCtx,
				(uint8_t *)pSrc,
				pBuf,
				nBuf,
				pnConsumed,
				FFS_RICDataDesc,
				IES_RICDataDesc);
		break;
	}
	(void)pCtx;
	return status;
} /* End dot11f_pack_ie_ric_data_desc. */

uint32_t dot11f_pack_ie_rsn(tpAniSirGlobal pCtx,
			    tDot11fIERSN *pSrc,
			    uint8_t *pBuf,
			    uint32_t nBuf,
			    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_iersn(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 48;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		frameshtons(pCtx, pBuf, pSrc->version, 0);
		*pnConsumed += 2;
		pBuf += 2;
		if (pSrc->gp_cipher_suite_present) {
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->gp_cipher_suite, 4);
			*pnConsumed += 4;
			pBuf += 4;
		} else {
			break;
		}
		if (pSrc->pwise_cipher_suite_count) {
			frameshtons(pCtx, pBuf, pSrc->pwise_cipher_suite_count, 0);
			*pnConsumed += 2;
			pBuf += 2;
		} else {
			break;
		}
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->pwise_cipher_suites), (pSrc->pwise_cipher_suite_count * 4));
		*pnConsumed += (pSrc->pwise_cipher_suite_count * 4);
		pBuf += (pSrc->pwise_cipher_suite_count * 4);
		if (pSrc->akm_suite_cnt) {
			frameshtons(pCtx, pBuf, pSrc->akm_suite_cnt, 0);
			*pnConsumed += 2;
			pBuf += 2;
		} else {
			break;
		}
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->akm_suite), (pSrc->akm_suite_cnt * 4));
		*pnConsumed += (pSrc->akm_suite_cnt * 4);
		pBuf += (pSrc->akm_suite_cnt * 4);
		if (pSrc->RSN_Cap_present) {
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->RSN_Cap, 2);
			*pnConsumed += 2;
			pBuf += 2;
		} else {
			break;
		}
		if (pSrc->pmkid_count) {
			frameshtons(pCtx, pBuf, pSrc->pmkid_count, 0);
			*pnConsumed += 2;
			pBuf += 2;
		} else {
			if (pSrc->gp_mgmt_cipher_suite_present) {
				frameshtons(pCtx, pBuf, pSrc->pmkid_count, 0);
				*pnConsumed += 2;
				pBuf += 2;
			}
		}
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->pmkid), (pSrc->pmkid_count * 16));
		*pnConsumed += (pSrc->pmkid_count * 16);
		pBuf += (pSrc->pmkid_count * 16);
		if (pSrc->gp_mgmt_cipher_suite_present) {
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->gp_mgmt_cipher_suite, 4);
			*pnConsumed += 4;
			/* fieldsEndFlag = 1 */
		} else {
			break;
		}
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_rsn. */

uint32_t dot11f_pack_ie_rsniie(tpAniSirGlobal pCtx,
			       tDot11fIERSNIIE *pSrc,
			       uint8_t *pBuf,
			       uint32_t nBuf,
			       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 65;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->rsni;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_rsniie. */

uint32_t dot11f_pack_ie_rsn_opaque(tpAniSirGlobal pCtx,
				  tDot11fIERSNOpaque *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_data;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 48;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->data), pSrc->num_data);
		*pnConsumed += pSrc->num_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_rsn_opaque. */

uint32_t dot11f_pack_ie_supp_channels(tpAniSirGlobal pCtx,
				     tDot11fIESuppChannels *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_bands * 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 36;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->bands), (pSrc->num_bands * 2));
		*pnConsumed += (pSrc->num_bands * 2);
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_supp_channels. */

uint32_t dot11f_pack_ie_supp_operating_classes(tpAniSirGlobal pCtx,
					     tDot11fIESuppOperatingClasses *pSrc,
					     uint8_t *pBuf,
					     uint32_t nBuf,
					     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_classes;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 59;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->classes), pSrc->num_classes);
		*pnConsumed += pSrc->num_classes;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_supp_operating_classes. */

uint32_t dot11f_pack_ie_supp_rates(tpAniSirGlobal pCtx,
				  tDot11fIESuppRates *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_rates;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 1;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->rates), pSrc->num_rates);
		*pnConsumed += pSrc->num_rates;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_supp_rates. */

uint32_t dot11f_pack_ie_tim(tpAniSirGlobal pCtx,
			    tDot11fIETIM *pSrc,
			    uint8_t *pBuf,
			    uint32_t nBuf,
			    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  (pSrc->num_vbmp + 3);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 5;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->dtim_count;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->dtim_period;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->bmpctl;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->vbmp), pSrc->num_vbmp);
		*pnConsumed += pSrc->num_vbmp;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_tim. */

uint32_t dot11f_pack_ie_tpc_report(tpAniSirGlobal pCtx,
				  tDot11fIETPCReport *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 35;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->tx_power;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->link_margin;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_tpc_report. */

uint32_t dot11f_pack_ie_tpc_request(tpAniSirGlobal pCtx,
				   tDot11fIETPCRequest *pSrc,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 0;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 34;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_tpc_request. */

uint32_t dot11f_pack_ie_time_advertisement(tpAniSirGlobal pCtx,
					  tDot11fIETimeAdvertisement *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 16;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 69;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->timing_capabilities;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->time_value, 10);
		*pnConsumed += 10;
		pBuf += 10;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->time_error, 5);
		*pnConsumed += 5;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_time_advertisement. */

uint32_t dot11f_pack_ie_timeout_interval(tpAniSirGlobal pCtx,
					tDot11fIETimeoutInterval *pSrc,
					uint8_t *pBuf,
					uint32_t nBuf,
					uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 5;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 56;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->timeoutType;
		*pnConsumed += 1;
		pBuf += 1;
		frameshtonl(pCtx, pBuf, pSrc->timeoutValue, 0);
		*pnConsumed += 4;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_timeout_interval. */

uint32_t dot11f_pack_ie_vht_ext_bss_load(tpAniSirGlobal pCtx,
				      tDot11fIEVHTExtBssLoad *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 5;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 193;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->muMIMOCapStaCount;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->ssUnderUtil;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->FortyMHzUtil;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->EightyMHzUtil;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->OneSixtyMHzUtil;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_vht_ext_bss_load. */

uint32_t dot11f_pack_ie_vendor1_ie(tpAniSirGlobal pCtx,
				  tDot11fIEVendor1IE *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 0;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x10;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x18;
		++pBuf; ++(*pnConsumed);
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_vendor1_ie. */

uint32_t dot11f_pack_ie_vendor3_ie(tpAniSirGlobal pCtx,
				  tDot11fIEVendor3IE *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 0;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x16;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x32;
		++pBuf; ++(*pnConsumed);
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_vendor3_ie. */

uint32_t dot11f_pack_ie_wapi(tpAniSirGlobal pCtx,
			     tDot11fIEWAPI *pSrc,
			     uint8_t *pBuf,
			     uint32_t nBuf,
			     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint16_t tmp161__;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_iewapi(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 68;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		frameshtons(pCtx, pBuf, pSrc->version, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->akm_suite_count, 0);
		*pnConsumed += 2;
		pBuf += 2;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->akm_suites), (pSrc->akm_suite_count * 4));
		*pnConsumed += (pSrc->akm_suite_count * 4);
		pBuf += (pSrc->akm_suite_count * 4);
		frameshtons(pCtx, pBuf, pSrc->unicast_cipher_suite_count, 0);
		*pnConsumed += 2;
		pBuf += 2;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->unicast_cipher_suites), (pSrc->unicast_cipher_suite_count * 4));
		*pnConsumed += (pSrc->unicast_cipher_suite_count * 4);
		pBuf += (pSrc->unicast_cipher_suite_count * 4);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->multicast_cipher_suite, 4);
		*pnConsumed += 4;
		pBuf += 4;
		tmp161__ = 0U;
		tmp161__ |= (pSrc->preauth << 0);
		tmp161__ |= (pSrc->reserved << 1);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp161__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		if (pSrc->bkid_count) {
			frameshtons(pCtx, pBuf, pSrc->bkid_count, 0);
			*pnConsumed += 2;
			pBuf += 2;
		} else {
			break;
		}
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->bkid), (pSrc->bkid_count * 16));
		*pnConsumed += (pSrc->bkid_count * 16);
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_wapi. */

uint32_t dot11f_pack_ie_wapi_opaque(tpAniSirGlobal pCtx,
				   tDot11fIEWAPIOpaque *pSrc,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_data;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 68;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->data), pSrc->num_data);
		*pnConsumed += pSrc->num_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wapi_opaque. */

uint32_t dot11f_pack_ie_wfatpc(tpAniSirGlobal pCtx,
			       tDot11fIEWFATPC *pSrc,
			       uint8_t *pBuf,
			       uint32_t nBuf,
			       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x8;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->txPower;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->linkMargin;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wfatpc. */

uint32_t dot11f_pack_ie_wfdie_opaque(tpAniSirGlobal pCtx,
				    tDot11fIEWFDIEOpaque *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_data;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x6f;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x9a;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xa;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->data), pSrc->num_data);
		*pnConsumed += pSrc->num_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wfdie_opaque. */

uint32_t dot11f_pack_ie_wmm_caps(tpAniSirGlobal pCtx,
				tDot11fIEWMMCaps *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp162__;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x5;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->version;
		*pnConsumed += 1;
		pBuf += 1;
		tmp162__ = 0U;
		tmp162__ |= (pSrc->reserved << 0);
		tmp162__ |= (pSrc->qack << 4);
		tmp162__ |= (pSrc->queue_request << 5);
		tmp162__ |= (pSrc->txop_request << 6);
		tmp162__ |= (pSrc->more_ack << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp162__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wmm_caps. */

uint32_t dot11f_pack_ie_wmm_info_ap(tpAniSirGlobal pCtx,
				  tDot11fIEWMMInfoAp *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp163__;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->version;
		*pnConsumed += 1;
		pBuf += 1;
		tmp163__ = 0U;
		tmp163__ |= (pSrc->param_set_count << 0);
		tmp163__ |= (pSrc->reserved << 4);
		tmp163__ |= (pSrc->uapsd << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp163__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wmm_info_ap. */

uint32_t dot11f_pack_ie_wmm_info_station(tpAniSirGlobal pCtx,
				       tDot11fIEWMMInfoStation *pSrc,
				       uint8_t *pBuf,
				       uint32_t nBuf,
				       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp164__;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->version;
		*pnConsumed += 1;
		pBuf += 1;
		tmp164__ = 0U;
		tmp164__ |= (pSrc->acvo_uapsd << 0);
		tmp164__ |= (pSrc->acvi_uapsd << 1);
		tmp164__ |= (pSrc->acbk_uapsd << 2);
		tmp164__ |= (pSrc->acbe_uapsd << 3);
		tmp164__ |= (pSrc->reserved1 << 4);
		tmp164__ |= (pSrc->max_sp_length << 5);
		tmp164__ |= (pSrc->reserved2 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp164__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wmm_info_station. */

uint32_t dot11f_pack_ie_wmm_params(tpAniSirGlobal pCtx,
				  tDot11fIEWMMParams *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp165__;
	uint8_t tmp166__;
	uint8_t tmp167__;
	uint8_t tmp168__;
	uint8_t tmp169__;
	uint8_t tmp170__;
	uint8_t tmp171__;
	uint8_t tmp172__;
	nNeeded  += 19;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x1;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->version;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->qosInfo;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->reserved2;
		*pnConsumed += 1;
		pBuf += 1;
		tmp165__ = 0U;
		tmp165__ |= (pSrc->acbe_aifsn << 0);
		tmp165__ |= (pSrc->acbe_acm << 4);
		tmp165__ |= (pSrc->acbe_aci << 5);
		tmp165__ |= (pSrc->unused1 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp165__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp166__ = 0U;
		tmp166__ |= (pSrc->acbe_acwmin << 0);
		tmp166__ |= (pSrc->acbe_acwmax << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp166__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		frameshtons(pCtx, pBuf, pSrc->acbe_txoplimit, 0);
		*pnConsumed += 2;
		pBuf += 2;
		tmp167__ = 0U;
		tmp167__ |= (pSrc->acbk_aifsn << 0);
		tmp167__ |= (pSrc->acbk_acm << 4);
		tmp167__ |= (pSrc->acbk_aci << 5);
		tmp167__ |= (pSrc->unused2 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp167__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp168__ = 0U;
		tmp168__ |= (pSrc->acbk_acwmin << 0);
		tmp168__ |= (pSrc->acbk_acwmax << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp168__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		frameshtons(pCtx, pBuf, pSrc->acbk_txoplimit, 0);
		*pnConsumed += 2;
		pBuf += 2;
		tmp169__ = 0U;
		tmp169__ |= (pSrc->acvi_aifsn << 0);
		tmp169__ |= (pSrc->acvi_acm << 4);
		tmp169__ |= (pSrc->acvi_aci << 5);
		tmp169__ |= (pSrc->unused3 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp169__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp170__ = 0U;
		tmp170__ |= (pSrc->acvi_acwmin << 0);
		tmp170__ |= (pSrc->acvi_acwmax << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp170__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		frameshtons(pCtx, pBuf, pSrc->acvi_txoplimit, 0);
		*pnConsumed += 2;
		pBuf += 2;
		tmp171__ = 0U;
		tmp171__ |= (pSrc->acvo_aifsn << 0);
		tmp171__ |= (pSrc->acvo_acm << 4);
		tmp171__ |= (pSrc->acvo_aci << 5);
		tmp171__ |= (pSrc->unused4 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp171__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp172__ = 0U;
		tmp172__ |= (pSrc->acvo_acwmin << 0);
		tmp172__ |= (pSrc->acvo_acwmax << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp172__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		frameshtons(pCtx, pBuf, pSrc->acvo_txoplimit, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wmm_params. */

uint32_t dot11f_pack_ie_wpa(tpAniSirGlobal pCtx,
			    tDot11fIEWPA *pSrc,
			    uint8_t *pBuf,
			    uint32_t nBuf,
			    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_iewpa(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x1;
		++pBuf; ++(*pnConsumed);
		frameshtons(pCtx, pBuf, pSrc->version, 0);
		*pnConsumed += 2;
		pBuf += 2;
		if (pSrc->multicast_cipher_present) {
			DOT11F_MEMCPY(pCtx, pBuf, pSrc->multicast_cipher, 4);
			*pnConsumed += 4;
			pBuf += 4;
		} else {
			break;
		}
		if (pSrc->unicast_cipher_count) {
			frameshtons(pCtx, pBuf, pSrc->unicast_cipher_count, 0);
			*pnConsumed += 2;
			pBuf += 2;
		} else {
			break;
		}
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->unicast_ciphers), (pSrc->unicast_cipher_count * 4));
		*pnConsumed += (pSrc->unicast_cipher_count * 4);
		pBuf += (pSrc->unicast_cipher_count * 4);
		if (pSrc->auth_suite_count) {
			frameshtons(pCtx, pBuf, pSrc->auth_suite_count, 0);
			*pnConsumed += 2;
			pBuf += 2;
		} else {
			break;
		}
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->auth_suites), (pSrc->auth_suite_count * 4));
		*pnConsumed += (pSrc->auth_suite_count * 4);
		pBuf += (pSrc->auth_suite_count * 4);
		if (pSrc->caps) {
			frameshtons(pCtx, pBuf, pSrc->caps, 0);
			*pnConsumed += 2;
			/* fieldsEndFlag = 1 */
		} else {
			break;
		}
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_wpa. */

uint32_t dot11f_pack_ie_wpa_opaque(tpAniSirGlobal pCtx,
				  tDot11fIEWPAOpaque *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_data;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x1;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->data), pSrc->num_data);
		*pnConsumed += pSrc->num_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wpa_opaque. */

uint32_t dot11f_pack_ie_wsc(tpAniSirGlobal pCtx,
			    tDot11fIEWSC *pSrc,
			    uint8_t *pBuf,
			    uint32_t nBuf,
			    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_iewsc(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x0;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0xf2;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x4;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_WSC +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_wsc. */

uint32_t dot11f_pack_ie_wsc_assoc_req(tpAniSirGlobal pCtx,
				    tDot11fIEWscAssocReq *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_ie_wsc_assoc_req(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x0;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0xf2;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x4;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_WscAssocReq +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_wsc_assoc_req. */

uint32_t dot11f_pack_ie_wsc_assoc_res(tpAniSirGlobal pCtx,
				    tDot11fIEWscAssocRes *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_ie_wsc_assoc_res(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x0;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0xf2;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x4;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_WscAssocRes +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_wsc_assoc_res. */

uint32_t dot11f_pack_ie_wsc_beacon(tpAniSirGlobal pCtx,
				  tDot11fIEWscBeacon *pSrc,
				  uint8_t *pBuf,
				  uint32_t nBuf,
				  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_ie_wsc_beacon(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x0;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0xf2;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x4;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_WscBeacon +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_wsc_beacon. */

uint32_t dot11f_pack_ie_wsc_beacon_probe_res(tpAniSirGlobal pCtx,
					  tDot11fIEWscBeaconProbeRes *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_ie_wsc_beacon_probe_res(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x0;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0xf2;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x4;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_WscBeaconProbeRes +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_wsc_beacon_probe_res. */

uint32_t dot11f_pack_ie_wsc_ie_opaque(tpAniSirGlobal pCtx,
				    tDot11fIEWscIEOpaque *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_data;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0xf2;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x4;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->data), pSrc->num_data);
		*pnConsumed += pSrc->num_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_wsc_ie_opaque. */

uint32_t dot11f_pack_ie_wsc_probe_req(tpAniSirGlobal pCtx,
				    tDot11fIEWscProbeReq *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_ie_wsc_probe_req(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x0;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0xf2;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x4;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_WscProbeReq +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_wsc_probe_req. */

uint32_t dot11f_pack_ie_wsc_probe_res(tpAniSirGlobal pCtx,
				    tDot11fIEWscProbeRes *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_ie_wsc_probe_res(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x0;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0xf2;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x4;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_WscProbeRes +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_wsc_probe_res. */

uint32_t dot11f_pack_ie_wsc_reassoc_res(tpAniSirGlobal pCtx,
				      tDot11fIEWscReassocRes *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_ie_wsc_reassoc_res(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x0;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x50;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0xf2;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x4;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_WscReassocRes +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_wsc_reassoc_res. */

uint32_t dot11f_pack_ie_addba_extn_element(tpAniSirGlobal pCtx,
					   tDot11fIEaddba_extn_element *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp173__;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 159;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp173__ = 0U;
		tmp173__ |= (pSrc->no_fragmentation << 0);
		tmp173__ |= (pSrc->he_frag_operation << 1);
		tmp173__ |= (pSrc->reserved << 3);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp173__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_addba_extn_element. */

uint32_t dot11f_pack_ie_bss_color_change(tpAniSirGlobal pCtx,
					 tDot11fIEbss_color_change *pSrc,
					 uint8_t *pBuf,
					 uint32_t nBuf,
					 uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp174__;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 42;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->countdown;
		*pnConsumed += 1;
		pBuf += 1;
		tmp174__ = 0U;
		tmp174__ |= (pSrc->new_color << 0);
		tmp174__ |= (pSrc->reserved << 6);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp174__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_bss_color_change. */

uint32_t dot11f_pack_ie_decriptor_element(tpAniSirGlobal pCtx,
					  tDot11fIEdecriptor_element *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ie_decriptor_element(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; --nBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; --nBuf; ++(*pnConsumed);
		*pBuf = 88;
		++pBuf; --nBuf; ++(*pnConsumed);
		*pBuf = pSrc->request_type;
		*pnConsumed += 1;
		pBuf += 1;
		frameshtons(pCtx, pBuf, pSrc->user_priority_control, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtonl(pCtx, pBuf, pSrc->stream_timeout, 0);
		*pnConsumed += 4;
		pBuf += 4;
		status = pack_core(pCtx,
				(uint8_t *)pSrc,
				pBuf,
				nBuf,
				pnConsumed,
				FFS_decriptor_element,
				IES_decriptor_element);
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_decriptor_element. */

uint32_t dot11f_pack_ie_dh_parameter_element(tpAniSirGlobal pCtx,
					     tDot11fIEdh_parameter_element *pSrc,
					     uint8_t *pBuf,
					     uint32_t nBuf,
					     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  (pSrc->num_public_key + 2);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 32;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->group, 2);
		*pnConsumed += 2;
		pBuf += 2;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->public_key), pSrc->num_public_key);
		*pnConsumed += pSrc->num_public_key;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_dh_parameter_element. */

uint32_t dot11f_pack_ie_esp_information(tpAniSirGlobal pCtx,
					tDot11fIEesp_information *pSrc,
					uint8_t *pBuf,
					uint32_t nBuf,
					uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_data;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 11;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->data), pSrc->num_data);
		*pnConsumed += pSrc->num_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_esp_information. */

uint32_t dot11f_pack_ie_ext_chan_switch_ann(tpAniSirGlobal pCtx,
					    tDot11fIEext_chan_switch_ann *pSrc,
					    uint8_t *pBuf,
					    uint32_t nBuf,
					    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 4;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 60;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->switch_mode;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->new_reg_class;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->new_channel;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->switch_count;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ext_chan_switch_ann. */

uint32_t dot11f_pack_ie_fils_assoc_delay_info(tpAniSirGlobal pCtx,
					      tDot11fIEfils_assoc_delay_info *pSrc,
					      uint8_t *pBuf,
					      uint32_t nBuf,
					      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 1;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->assoc_delay_info;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fils_assoc_delay_info. */

uint32_t dot11f_pack_ie_fils_hlp_container(tpAniSirGlobal pCtx,
					   tDot11fIEfils_hlp_container *pSrc,
					   uint8_t *pBuf,
					   uint32_t nBuf,
					   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  (pSrc->num_hlp_packet + 12);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 5;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->dest_mac, 6);
		*pnConsumed += 6;
		pBuf += 6;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->src_mac, 6);
		*pnConsumed += 6;
		pBuf += 6;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->hlp_packet), pSrc->num_hlp_packet);
		*pnConsumed += pSrc->num_hlp_packet;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fils_hlp_container. */

uint32_t dot11f_pack_ie_fils_indication(tpAniSirGlobal pCtx,
					tDot11fIEfils_indication *pSrc,
					uint8_t *pBuf,
					uint32_t nBuf,
					uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint16_t tmp175__;
	nNeeded  +=  (pSrc->num_variable_data + 2);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 240;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp175__ = 0U;
		tmp175__ |= (pSrc->public_key_identifiers_cnt << 0);
		tmp175__ |= (pSrc->realm_identifiers_cnt << 3);
		tmp175__ |= (pSrc->is_ip_config_supported << 6);
		tmp175__ |= (pSrc->is_cache_id_present << 7);
		tmp175__ |= (pSrc->is_hessid_present << 8);
		tmp175__ |= (pSrc->is_fils_sk_auth_supported << 9);
		tmp175__ |= (pSrc->is_fils_sk_auth_pfs_supported << 10);
		tmp175__ |= (pSrc->is_pk_auth_supported << 11);
		tmp175__ |= (pSrc->reserved << 12);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp175__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->variable_data), pSrc->num_variable_data);
		*pnConsumed += pSrc->num_variable_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fils_indication. */

uint32_t dot11f_pack_ie_fils_kde(tpAniSirGlobal pCtx,
				 tDot11fIEfils_kde *pSrc,
				 uint8_t *pBuf,
				 uint32_t nBuf,
				 uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  (pSrc->num_kde_list + 8);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 7;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->key_rsc, 8);
		*pnConsumed += 8;
		pBuf += 8;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->kde_list), pSrc->num_kde_list);
		*pnConsumed += pSrc->num_kde_list;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fils_kde. */

uint32_t dot11f_pack_ie_fils_key_confirmation(tpAniSirGlobal pCtx,
					      tDot11fIEfils_key_confirmation *pSrc,
					      uint8_t *pBuf,
					      uint32_t nBuf,
					      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_key_auth;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 3;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->key_auth), pSrc->num_key_auth);
		*pnConsumed += pSrc->num_key_auth;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fils_key_confirmation. */

uint32_t dot11f_pack_ie_fils_nonce(tpAniSirGlobal pCtx,
				   tDot11fIEfils_nonce *pSrc,
				   uint8_t *pBuf,
				   uint32_t nBuf,
				   uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 16;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 13;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->nonce, 16);
		*pnConsumed += 16;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fils_nonce. */

uint32_t dot11f_pack_ie_fils_public_key(tpAniSirGlobal pCtx,
					tDot11fIEfils_public_key *pSrc,
					uint8_t *pBuf,
					uint32_t nBuf,
					uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  (pSrc->num_public_key + 1);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 12;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->key_type;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->public_key), pSrc->num_public_key);
		*pnConsumed += pSrc->num_public_key;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fils_public_key. */

uint32_t dot11f_pack_ie_fils_session(tpAniSirGlobal pCtx,
				     tDot11fIEfils_session *pSrc,
				     uint8_t *pBuf,
				     uint32_t nBuf,
				     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 8;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 4;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->session, 8);
		*pnConsumed += 8;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fils_session. */

uint32_t dot11f_pack_ie_fils_wrapped_data(tpAniSirGlobal pCtx,
					  tDot11fIEfils_wrapped_data *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_wrapped_data;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 8;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->wrapped_data), pSrc->num_wrapped_data);
		*pnConsumed += pSrc->num_wrapped_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fils_wrapped_data. */

uint32_t dot11f_pack_ie_fragment_ie(tpAniSirGlobal pCtx,
				    tDot11fIEfragment_ie *pSrc,
				    uint8_t *pBuf,
				    uint32_t nBuf,
				    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_data;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 242;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->data), pSrc->num_data);
		*pnConsumed += pSrc->num_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_fragment_ie. */

uint32_t dot11f_pack_ie_he_6ghz_band_cap(tpAniSirGlobal pCtx,
					 tDot11fIEhe_6ghz_band_cap *pSrc,
					 uint8_t *pBuf,
					 uint32_t nBuf,
					 uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint16_t tmp176__;
	nNeeded  += 2;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 59;
		++pBuf; ++(*pnConsumed);
		tmp176__ = 0U;
		tmp176__ |= (pSrc->min_mpdu_start_spacing << 0);
		tmp176__ |= (pSrc->max_ampdu_len_exp << 3);
		tmp176__ |= (pSrc->max_mpdu_len << 6);
		tmp176__ |= (pSrc->sm_pow_save << 9);
		tmp176__ |= (pSrc->rd_responder << 11);
		tmp176__ |= (pSrc->rx_ant_pattern_consistency << 12);
		tmp176__ |= (pSrc->tx_ant_pattern_consistency << 13);
		tmp176__ |= (pSrc->reserved << 14);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp176__, 0);
		*pnConsumed += 2;
		/* fieldsEndFlag  = 1 */
		nBuf -=  2 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_he_6ghz_band_cap. */

uint32_t dot11f_pack_ie_he_cap(tpAniSirGlobal pCtx,
			       tDot11fIEhe_cap *pSrc,
			       uint8_t *pBuf,
			       uint32_t nBuf,
			       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint32_t tmp177__;
	uint16_t tmp178__;
	uint32_t tmp179__;
	uint32_t tmp180__;
	uint16_t tmp181__;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ie_he_cap(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 35;
		++pBuf; ++(*pnConsumed);
		tmp177__ = 0U;
		tmp177__ |= (pSrc->htc_he << 0);
		tmp177__ |= (pSrc->twt_request << 1);
		tmp177__ |= (pSrc->twt_responder << 2);
		tmp177__ |= (pSrc->fragmentation << 3);
		tmp177__ |= (pSrc->max_num_frag_msdu_amsdu_exp << 5);
		tmp177__ |= (pSrc->min_frag_size << 8);
		tmp177__ |= (pSrc->trigger_frm_mac_pad << 10);
		tmp177__ |= (pSrc->multi_tid_aggr_rx_supp << 12);
		tmp177__ |= (pSrc->he_link_adaptation << 15);
		tmp177__ |= (pSrc->all_ack << 17);
		tmp177__ |= (pSrc->trigd_rsp_sched << 18);
		tmp177__ |= (pSrc->a_bsr << 19);
		tmp177__ |= (pSrc->broadcast_twt << 20);
		tmp177__ |= (pSrc->ba_32bit_bitmap << 21);
		tmp177__ |= (pSrc->mu_cascade << 22);
		tmp177__ |= (pSrc->ack_enabled_multitid << 23);
		tmp177__ |= (pSrc->reserved << 24);
		tmp177__ |= (pSrc->omi_a_ctrl << 25);
		tmp177__ |= (pSrc->ofdma_ra << 26);
		tmp177__ |= (pSrc->max_ampdu_len_exp_ext << 27);
		tmp177__ |= (pSrc->amsdu_frag << 29);
		tmp177__ |= (pSrc->flex_twt_sched << 30);
		tmp177__ |= (pSrc->rx_ctrl_frame << 31);
		if (unlikely(nBuf < 4))
			return DOT11F_INCOMPLETE_IE;

		frameshtonl(pCtx, pBuf, tmp177__, 0);
		*pnConsumed += 4;
		pBuf += 4;
		nBuf -=  4 ;
		tmp178__ = 0U;
		tmp178__ |= (pSrc->bsrp_ampdu_aggr << 0);
		tmp178__ |= (pSrc->qtp << 1);
		tmp178__ |= (pSrc->a_bqr << 2);
		tmp178__ |= (pSrc->spatial_reuse_param_rspder << 3);
		tmp178__ |= (pSrc->ndp_feedback_supp << 4);
		tmp178__ |= (pSrc->ops_supp << 5);
		tmp178__ |= (pSrc->amsdu_in_ampdu << 6);
		tmp178__ |= (pSrc->multi_tid_aggr_tx_supp << 7);
		tmp178__ |= (pSrc->he_sub_ch_sel_tx_supp << 10);
		tmp178__ |= (pSrc->ul_2x996_tone_ru_supp << 11);
		tmp178__ |= (pSrc->om_ctrl_ul_mu_data_dis_rx << 12);
		tmp178__ |= (pSrc->he_dynamic_smps << 13);
		tmp178__ |= (pSrc->punctured_sounding_supp << 14);
		tmp178__ |= (pSrc->ht_vht_trg_frm_rx_supp << 15);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp178__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		tmp179__ = 0U;
		tmp179__ |= (pSrc->reserved2 << 0);
		tmp179__ |= (pSrc->chan_width_0 << 1);
		tmp179__ |= (pSrc->chan_width_1 << 2);
		tmp179__ |= (pSrc->chan_width_2 << 3);
		tmp179__ |= (pSrc->chan_width_3 << 4);
		tmp179__ |= (pSrc->chan_width_4 << 5);
		tmp179__ |= (pSrc->chan_width_5 << 6);
		tmp179__ |= (pSrc->chan_width_6 << 7);
		tmp179__ |= (pSrc->rx_pream_puncturing << 8);
		tmp179__ |= (pSrc->device_class << 12);
		tmp179__ |= (pSrc->ldpc_coding << 13);
		tmp179__ |= (pSrc->he_1x_ltf_800_gi_ppdu << 14);
		tmp179__ |= (pSrc->midamble_tx_rx_max_nsts << 15);
		tmp179__ |= (pSrc->he_4x_ltf_3200_gi_ndp << 17);
		tmp179__ |= (pSrc->tb_ppdu_tx_stbc_lt_80mhz << 18);
		tmp179__ |= (pSrc->rx_stbc_lt_80mhz << 19);
		tmp179__ |= (pSrc->doppler << 20);
		tmp179__ |= (pSrc->ul_mu << 22);
		tmp179__ |= (pSrc->dcm_enc_tx << 24);
		tmp179__ |= (pSrc->dcm_enc_rx << 27);
		tmp179__ |= (pSrc->ul_he_mu << 30);
		tmp179__ |= (pSrc->su_beamformer << 31);
		if (unlikely(nBuf < 4))
			return DOT11F_INCOMPLETE_IE;

		frameshtonl(pCtx, pBuf, tmp179__, 0);
		*pnConsumed += 4;
		pBuf += 4;
		nBuf -=  4 ;
		tmp180__ = 0U;
		tmp180__ |= (pSrc->su_beamformee << 0);
		tmp180__ |= (pSrc->mu_beamformer << 1);
		tmp180__ |= (pSrc->bfee_sts_lt_80 << 2);
		tmp180__ |= (pSrc->bfee_sts_gt_80 << 5);
		tmp180__ |= (pSrc->num_sounding_lt_80 << 8);
		tmp180__ |= (pSrc->num_sounding_gt_80 << 11);
		tmp180__ |= (pSrc->su_feedback_tone16 << 14);
		tmp180__ |= (pSrc->mu_feedback_tone16 << 15);
		tmp180__ |= (pSrc->codebook_su << 16);
		tmp180__ |= (pSrc->codebook_mu << 17);
		tmp180__ |= (pSrc->beamforming_feedback << 18);
		tmp180__ |= (pSrc->he_er_su_ppdu << 21);
		tmp180__ |= (pSrc->dl_mu_mimo_part_bw << 22);
		tmp180__ |= (pSrc->ppet_present << 23);
		tmp180__ |= (pSrc->srp << 24);
		tmp180__ |= (pSrc->power_boost << 25);
		tmp180__ |= (pSrc->he_ltf_800_gi_4x << 26);
		tmp180__ |= (pSrc->max_nc << 27);
		tmp180__ |= (pSrc->tb_ppdu_tx_stbc_gt_80mhz << 30);
		tmp180__ |= (pSrc->rx_stbc_gt_80mhz << 31);
		if (unlikely(nBuf < 4))
			return DOT11F_INCOMPLETE_IE;

		frameshtonl(pCtx, pBuf, tmp180__, 0);
		*pnConsumed += 4;
		pBuf += 4;
		nBuf -=  4 ;
		tmp181__ = 0U;
		tmp181__ |= (pSrc->er_he_ltf_800_gi_4x << 0);
		tmp181__ |= (pSrc->he_ppdu_20_in_40Mhz_2G << 1);
		tmp181__ |= (pSrc->he_ppdu_20_in_160_80p80Mhz << 2);
		tmp181__ |= (pSrc->he_ppdu_80_in_160_80p80Mhz << 3);
		tmp181__ |= (pSrc->er_1x_he_ltf_gi << 4);
		tmp181__ |= (pSrc->midamble_tx_rx_1x_he_ltf << 5);
		tmp181__ |= (pSrc->dcm_max_bw << 6);
		tmp181__ |= (pSrc->longer_than_16_he_sigb_ofdm_sym << 8);
		tmp181__ |= (pSrc->non_trig_cqi_feedback << 9);
		tmp181__ |= (pSrc->tx_1024_qam_lt_242_tone_ru << 10);
		tmp181__ |= (pSrc->rx_1024_qam_lt_242_tone_ru << 11);
		tmp181__ |= (pSrc->rx_full_bw_su_he_mu_compress_sigb << 12);
		tmp181__ |= (pSrc->rx_full_bw_su_he_mu_non_cmpr_sigb << 13);
		tmp181__ |= (pSrc->reserved3 << 14);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp181__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		*pBuf = pSrc->reserved4;
		*pnConsumed += 1;
		pBuf += 1;
		frameshtons(pCtx, pBuf, pSrc->rx_he_mcs_map_lt_80, 0);
		*pnConsumed += 2;
		pBuf += 2;
		frameshtons(pCtx, pBuf, pSrc->tx_he_mcs_map_lt_80, 0);
		*pnConsumed += 2;
		pBuf += 2;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->rx_he_mcs_map_160), (pSrc->chan_width_2 * 2));
		*pnConsumed += (pSrc->chan_width_2 * 2);
		pBuf += (pSrc->chan_width_2 * 2);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->tx_he_mcs_map_160), (pSrc->chan_width_2 * 2));
		*pnConsumed += (pSrc->chan_width_2 * 2);
		pBuf += (pSrc->chan_width_2 * 2);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->rx_he_mcs_map_80_80), (pSrc->chan_width_3 * 2));
		*pnConsumed += (pSrc->chan_width_3 * 2);
		pBuf += (pSrc->chan_width_3 * 2);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->tx_he_mcs_map_80_80), (pSrc->chan_width_3 * 2));
		*pnConsumed += (pSrc->chan_width_3 * 2);
		pBuf += (pSrc->chan_width_3 * 2);
		if (pSrc->ppet_present) {
			switch (pSrc->ppet_present) {
			case 1:
				DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->ppet.ppe_threshold.ppe_th), pSrc->ppet.ppe_threshold.num_ppe_th);
				*pnConsumed += pSrc->ppet.ppe_threshold.num_ppe_th;
				/* fieldsEndFlag = 1 */
				break;
			}
		} else {
			break;
		}
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_he_cap. */

uint32_t dot11f_pack_ie_he_op(tpAniSirGlobal pCtx,
			      tDot11fIEhe_op *pSrc,
			      uint8_t *pBuf,
			      uint32_t nBuf,
			      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint16_t tmp182__;
	uint8_t tmp183__;
	uint8_t tmp184__;
	uint8_t tmp185__;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ie_he_op(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 36;
		++pBuf; ++(*pnConsumed);
		tmp182__ = 0U;
		tmp182__ |= (pSrc->default_pe << 0);
		tmp182__ |= (pSrc->twt_required << 3);
		tmp182__ |= (pSrc->txop_rts_threshold << 4);
		tmp182__ |= (pSrc->vht_oper_present << 14);
		tmp182__ |= (pSrc->co_located_bss << 15);
		if (unlikely(nBuf < 2))
			return DOT11F_INCOMPLETE_IE;

		frameshtons(pCtx, pBuf, tmp182__, 0);
		*pnConsumed += 2;
		pBuf += 2;
		nBuf -=  2 ;
		tmp183__ = 0U;
		tmp183__ |= (pSrc->er_su_disable << 0);
		tmp183__ |= (pSrc->oper_info_6g_present << 1);
		tmp183__ |= (pSrc->reserved2 << 2);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp183__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp184__ = 0U;
		tmp184__ |= (pSrc->bss_color << 0);
		tmp184__ |= (pSrc->partial_bss_col << 6);
		tmp184__ |= (pSrc->bss_col_disabled << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp184__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		DOT11F_MEMCPY(pCtx, pBuf, pSrc->basic_mcs_nss, 2);
		*pnConsumed += 2;
		pBuf += 2;
		if (pSrc->vht_oper_present) {
			switch (pSrc->vht_oper_present) {
			case 1:
				*pBuf = pSrc->vht_oper.info.chan_width;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->vht_oper.info.center_freq_seg0;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->vht_oper.info.center_freq_seg1;
				*pnConsumed += 1;
				pBuf += 1;
				break;
			}
		}
		if (pSrc->co_located_bss) {
			switch (pSrc->co_located_bss) {
			case 1:
				*pBuf = pSrc->maxbssid_ind.info.data;
				*pnConsumed += 1;
				pBuf += 1;
				break;
			}
		}
		if (pSrc->oper_info_6g_present) {
			switch (pSrc->oper_info_6g_present) {
			case 1:
				*pBuf = pSrc->oper_info_6g.info.primary_ch;
				*pnConsumed += 1;
				pBuf += 1;
				tmp185__ = 0U;
				tmp185__ |= (pSrc->oper_info_6g.info.ch_width << 0);
				tmp185__ |= (pSrc->oper_info_6g.info.dup_bcon << 2);
				tmp185__ |= (pSrc->oper_info_6g.info.reg_info << 3);
				tmp185__ |= (pSrc->oper_info_6g.info.reserved << 6);
				if (unlikely(nBuf < 1))
					return DOT11F_INCOMPLETE_IE;

				*pBuf = tmp185__;
				*pnConsumed += 1;
				pBuf += 1;
				nBuf -=  1 ;
				*pBuf = pSrc->oper_info_6g.info.center_freq_seg0;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->oper_info_6g.info.center_freq_seg1;
				*pnConsumed += 1;
				pBuf += 1;
				*pBuf = pSrc->oper_info_6g.info.min_rate;
				*pnConsumed += 1;
				/* fieldsEndFlag = 1 */
				break;
			}
		}
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_he_op. */

uint32_t dot11f_pack_ie_hs20vendor_ie(tpAniSirGlobal pCtx,
				      tDot11fIEhs20vendor_ie *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp186__;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ie_hs20vendor_ie(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x6f;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x9a;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x10;
		++pBuf; ++(*pnConsumed);
		tmp186__ = 0U;
		tmp186__ |= (pSrc->dgaf_dis << 0);
		tmp186__ |= (pSrc->hs_id_present << 1);
		tmp186__ |= (pSrc->reserved << 3);
		tmp186__ |= (pSrc->release_num << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp186__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		if (pSrc->hs_id_present) {
			switch (pSrc->hs_id_present) {
			case 1:
				frameshtons(pCtx, pBuf, pSrc->hs_id.pps_mo.pps_mo_id, 0);
				*pnConsumed += 2;
				/* fieldsEndFlag = 1 */
				break;
			case 2:
				frameshtons(pCtx, pBuf, pSrc->hs_id.anqp_domain.anqp_domain_id, 0);
				*pnConsumed += 2;
				/* fieldsEndFlag = 1 */
				break;
			}
		} else {
			break;
		}
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_hs20vendor_ie. */

uint32_t dot11f_pack_ie_ht2040_bss_coexistence(tpAniSirGlobal pCtx,
					       tDot11fIEht2040_bss_coexistence *pSrc,
					       uint8_t *pBuf,
					       uint32_t nBuf,
					       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp187__;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 72;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		tmp187__ = 0U;
		tmp187__ |= (pSrc->info_request << 0);
		tmp187__ |= (pSrc->forty_mhz_intolerant << 1);
		tmp187__ |= (pSrc->twenty_mhz_bsswidth_req << 2);
		tmp187__ |= (pSrc->obss_scan_exemption_req << 3);
		tmp187__ |= (pSrc->obss_scan_exemption_grant << 4);
		tmp187__ |= (pSrc->unused << 5);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp187__;
		*pnConsumed += 1;
		/* fieldsEndFlag  = 1 */
		nBuf -=  1 ;
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ht2040_bss_coexistence. */

uint32_t dot11f_pack_ie_ht2040_bss_intolerant_report(tpAniSirGlobal pCtx,
						     tDot11fIEht2040_bss_intolerant_report *pSrc,
						     uint8_t *pBuf,
						     uint32_t nBuf,
						     uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  (pSrc->num_channel_list + 1);
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 73;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->operating_class;
		*pnConsumed += 1;
		pBuf += 1;
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->channel_list), pSrc->num_channel_list);
		*pnConsumed += pSrc->num_channel_list;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_ht2040_bss_intolerant_report. */

uint32_t dot11f_pack_ie_mu_edca_param_set(tpAniSirGlobal pCtx,
					  tDot11fIEmu_edca_param_set *pSrc,
					  uint8_t *pBuf,
					  uint32_t nBuf,
					  uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint8_t tmp188__;
	uint8_t tmp189__;
	uint8_t tmp190__;
	uint8_t tmp191__;
	uint8_t tmp192__;
	uint8_t tmp193__;
	uint8_t tmp194__;
	uint8_t tmp195__;
	nNeeded  += 13;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 38;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->qos;
		*pnConsumed += 1;
		pBuf += 1;
		tmp188__ = 0U;
		tmp188__ |= (pSrc->acbe_aifsn << 0);
		tmp188__ |= (pSrc->acbe_acm << 4);
		tmp188__ |= (pSrc->acbe_aci << 5);
		tmp188__ |= (pSrc->unused1 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp188__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp189__ = 0U;
		tmp189__ |= (pSrc->acbe_acwmin << 0);
		tmp189__ |= (pSrc->acbe_acwmax << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp189__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		*pBuf = pSrc->acbe_muedca_timer;
		*pnConsumed += 1;
		pBuf += 1;
		tmp190__ = 0U;
		tmp190__ |= (pSrc->acbk_aifsn << 0);
		tmp190__ |= (pSrc->acbk_acm << 4);
		tmp190__ |= (pSrc->acbk_aci << 5);
		tmp190__ |= (pSrc->unused2 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp190__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp191__ = 0U;
		tmp191__ |= (pSrc->acbk_acwmin << 0);
		tmp191__ |= (pSrc->acbk_acwmax << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp191__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		*pBuf = pSrc->acbk_muedca_timer;
		*pnConsumed += 1;
		pBuf += 1;
		tmp192__ = 0U;
		tmp192__ |= (pSrc->acvi_aifsn << 0);
		tmp192__ |= (pSrc->acvi_acm << 4);
		tmp192__ |= (pSrc->acvi_aci << 5);
		tmp192__ |= (pSrc->unused3 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp192__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp193__ = 0U;
		tmp193__ |= (pSrc->acvi_acwmin << 0);
		tmp193__ |= (pSrc->acvi_acwmax << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp193__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		*pBuf = pSrc->acvi_muedca_timer;
		*pnConsumed += 1;
		pBuf += 1;
		tmp194__ = 0U;
		tmp194__ |= (pSrc->acvo_aifsn << 0);
		tmp194__ |= (pSrc->acvo_acm << 4);
		tmp194__ |= (pSrc->acvo_aci << 5);
		tmp194__ |= (pSrc->unused4 << 7);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp194__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		tmp195__ = 0U;
		tmp195__ |= (pSrc->acvo_acwmin << 0);
		tmp195__ |= (pSrc->acvo_acwmax << 4);
		if (unlikely(nBuf < 1))
			return DOT11F_INCOMPLETE_IE;

		*pBuf = tmp195__;
		*pnConsumed += 1;
		pBuf += 1;
		nBuf -=  1 ;
		*pBuf = pSrc->acvo_muedca_timer;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_mu_edca_param_set. */

uint32_t dot11f_pack_ie_oci(tpAniSirGlobal pCtx,
			    tDot11fIEoci *pSrc,
			    uint8_t *pBuf,
			    uint32_t nBuf,
			    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 3;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 255;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 54;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->op_class;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->prim_ch_num;
		*pnConsumed += 1;
		pBuf += 1;
		*pBuf = pSrc->freq_seg_1_ch_num;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_oci. */

uint32_t dot11f_pack_ie_osen_ie(tpAniSirGlobal pCtx,
				tDot11fIEosen_ie *pSrc,
				uint8_t *pBuf,
				uint32_t nBuf,
				uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_data;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x6f;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x9a;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x12;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->data), pSrc->num_data);
		*pnConsumed += pSrc->num_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_osen_ie. */

uint32_t dot11f_pack_ie_qcn_ie(tpAniSirGlobal pCtx,
			       tDot11fIEqcn_ie *pSrc,
			       uint8_t *pBuf,
			       uint32_t nBuf,
			       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t n, idx = 0, idxlast;
	uint32_t nConsumedSoFar, nConsumedNow;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	uint32_t nNeeded = 0U;
	status = dot11f_get_packed_ie_qcn_ie(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	if (nNeeded > nBuf)
		return DOT11F_BUFFER_OVERFLOW;
	(void)pCtx;
	if (pSrc->present) {
		do {
			nConsumedSoFar = *pnConsumed;
			*pBuf = 221;
			++pBuf; --nBuf; ++(*pnConsumed);
			pIeLen = pBuf;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x8c;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0xfd;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0xf0;
			++pBuf; --nBuf; ++(*pnConsumed);
			*pBuf = 0x1;
			++pBuf; --nBuf; ++(*pnConsumed);
			n = (255 - 4) < nBuf ? (255 - 4) : nBuf;
			nConsumedNow = *pnConsumed;
			idxlast = idx;
			status = pack_tlv_core(pCtx, (uint8_t *)pSrc, pBuf, n,
					       pnConsumed,
					       TLVS_qcn_ie +
					       idx, &idx);
			nConsumedNow = *pnConsumed - nConsumedNow;
			*pIeLen = *pnConsumed - nConsumedSoFar - 2;
			pBuf += nConsumedNow;
			nBuf -= nConsumedNow;
		} while (DOT11F_BUFFER_OVERFLOW == status && idxlast != idx);
	}
	return status;
} /* End dot11f_pack_ie_qcn_ie. */

uint32_t dot11f_pack_ie_roaming_consortium_sel(tpAniSirGlobal pCtx,
					       tDot11fIEroaming_consortium_sel *pSrc,
					       uint8_t *pBuf,
					       uint32_t nBuf,
					       uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  +=  pSrc->num_data;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x50;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x6f;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x9a;
		++pBuf; ++(*pnConsumed);
		*pBuf = 0x1d;
		++pBuf; ++(*pnConsumed);
		DOT11F_MEMCPY(pCtx, pBuf, &(pSrc->data), pSrc->num_data);
		*pnConsumed += pSrc->num_data;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_roaming_consortium_sel. */

uint32_t dot11f_pack_ie_sec_chan_offset_ele(tpAniSirGlobal pCtx,
					    tDot11fIEsec_chan_offset_ele *pSrc,
					    uint8_t *pBuf,
					    uint32_t nBuf,
					    uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	nNeeded  += 1;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 62;
		++pBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; ++(*pnConsumed);
		*pBuf = pSrc->secondaryChannelOffset;
		*pnConsumed += 1;
		/* fieldsEndFlag = 1 */
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return DOT11F_PARSE_SUCCESS;
} /* End dot11f_pack_ie_sec_chan_offset_ele. */

uint32_t dot11f_pack_ie_vendor_vht_ie(tpAniSirGlobal pCtx,
				      tDot11fIEvendor_vht_ie *pSrc,
				      uint8_t *pBuf,
				      uint32_t nBuf,
				      uint32_t *pnConsumed)
{
	uint8_t *pIeLen = 0;
	uint32_t nConsumedOnEntry = *pnConsumed;
	uint32_t nNeeded = 0U;
	uint32_t status = DOT11F_PARSE_SUCCESS;
	status = dot11f_get_packed_ie_vendor_vht_ie(pCtx, pSrc, &nNeeded);
	if (!DOT11F_SUCCEEDED(status))
		return status;
	while (pSrc->present) {
		if (nNeeded > nBuf)
			return DOT11F_BUFFER_OVERFLOW;
		*pBuf = 221;
		++pBuf; --nBuf; ++(*pnConsumed);
		pIeLen = pBuf;
		++pBuf; --nBuf; ++(*pnConsumed);
		*pBuf = 0x0;
		++pBuf; --nBuf; ++(*pnConsumed);
		*pBuf = 0x90;
		++pBuf; --nBuf; ++(*pnConsumed);
		*pBuf = 0x4c;
		++pBuf; --nBuf; ++(*pnConsumed);
		*pBuf = 0x4;
		++pBuf; --nBuf; ++(*pnConsumed);
		*pBuf = pSrc->sub_type;
		*pnConsumed += 1;
		pBuf += 1;
		status = pack_core(pCtx,
				(uint8_t *)pSrc,
				pBuf,
				nBuf,
				pnConsumed,
				FFS_vendor_vht_ie,
				IES_vendor_vht_ie);
		break;
	}
	(void)pCtx;
	if (pIeLen) {
		*pIeLen = *pnConsumed - nConsumedOnEntry - 2;
	}
	return status;
} /* End dot11f_pack_ie_vendor_vht_ie. */

uint32_t dot11f_pack_add_ts_request(tpAniSirGlobal pCtx,
	tDot11fAddTSRequest *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_AddTSRequest, IES_AddTSRequest);

	return status;

} /* End dot11f_unpack_add_ts_request. */

uint32_t dot11f_pack_add_ts_response(tpAniSirGlobal pCtx,
	tDot11fAddTSResponse *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_AddTSResponse, IES_AddTSResponse);

	return status;

} /* End dot11f_unpack_add_ts_response. */

uint32_t dot11f_pack_assoc_request(tpAniSirGlobal pCtx,
	tDot11fAssocRequest *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_AssocRequest, IES_AssocRequest);

	return status;

} /* End dot11f_unpack_assoc_request. */

uint32_t dot11f_pack_assoc_response(tpAniSirGlobal pCtx,
	tDot11fAssocResponse *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_AssocResponse, IES_AssocResponse);

	return status;

} /* End dot11f_unpack_assoc_response. */

uint32_t dot11f_pack_authentication(tpAniSirGlobal pCtx,
	tDot11fAuthentication *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_Authentication, IES_Authentication);

	return status;

} /* End dot11f_unpack_authentication. */

uint32_t dot11f_pack_beacon(tpAniSirGlobal pCtx,
	tDot11fBeacon *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_Beacon, IES_Beacon);

	return status;

} /* End dot11f_unpack_beacon. */

uint32_t dot11f_pack_beacon1(tpAniSirGlobal pCtx,
	tDot11fBeacon1 *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_Beacon1, IES_Beacon1);

	return status;

} /* End dot11f_unpack_beacon1. */

uint32_t dot11f_pack_beacon2(tpAniSirGlobal pCtx,
	tDot11fBeacon2 *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_Beacon2, IES_Beacon2);

	return status;

} /* End dot11f_unpack_beacon2. */

uint32_t dot11f_pack_beacon_i_es(tpAniSirGlobal pCtx,
	tDot11fBeaconIEs *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_BeaconIEs, IES_BeaconIEs);

	return status;

} /* End dot11f_unpack_beacon_i_es. */

uint32_t dot11f_pack_channel_switch(tpAniSirGlobal pCtx,
	tDot11fChannelSwitch *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_ChannelSwitch, IES_ChannelSwitch);

	return status;

} /* End dot11f_unpack_channel_switch. */

uint32_t dot11f_pack_de_auth(tpAniSirGlobal pCtx,
	tDot11fDeAuth *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_DeAuth, IES_DeAuth);

	return status;

} /* End dot11f_unpack_de_auth. */

uint32_t dot11f_pack_del_ts(tpAniSirGlobal pCtx,
	tDot11fDelTS *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_DelTS, IES_DelTS);

	return status;

} /* End dot11f_unpack_del_ts. */

uint32_t dot11f_pack_disassociation(tpAniSirGlobal pCtx,
	tDot11fDisassociation *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_Disassociation, IES_Disassociation);

	return status;

} /* End dot11f_unpack_disassociation. */

uint32_t dot11f_pack_link_measurement_report(tpAniSirGlobal pCtx,
	tDot11fLinkMeasurementReport *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_LinkMeasurementReport, IES_LinkMeasurementReport);

	return status;

} /* End dot11f_unpack_link_measurement_report. */

uint32_t dot11f_pack_link_measurement_request(tpAniSirGlobal pCtx,
	tDot11fLinkMeasurementRequest *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_LinkMeasurementRequest, IES_LinkMeasurementRequest);

	return status;

} /* End dot11f_unpack_link_measurement_request. */

uint32_t dot11f_pack_measurement_report(tpAniSirGlobal pCtx,
	tDot11fMeasurementReport *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_MeasurementReport, IES_MeasurementReport);

	return status;

} /* End dot11f_unpack_measurement_report. */

uint32_t dot11f_pack_measurement_request(tpAniSirGlobal pCtx,
	tDot11fMeasurementRequest *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_MeasurementRequest, IES_MeasurementRequest);

	return status;

} /* End dot11f_unpack_measurement_request. */

uint32_t dot11f_pack_neighbor_report_request(tpAniSirGlobal pCtx,
	tDot11fNeighborReportRequest *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_NeighborReportRequest, IES_NeighborReportRequest);

	return status;

} /* End dot11f_unpack_neighbor_report_request. */

uint32_t dot11f_pack_neighbor_report_response(tpAniSirGlobal pCtx,
	tDot11fNeighborReportResponse *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_NeighborReportResponse, IES_NeighborReportResponse);

	return status;

} /* End dot11f_unpack_neighbor_report_response. */

uint32_t dot11f_pack_operating_mode(tpAniSirGlobal pCtx,
	tDot11fOperatingMode *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_OperatingMode, IES_OperatingMode);

	return status;

} /* End dot11f_unpack_operating_mode. */

uint32_t dot11f_pack_probe_request(tpAniSirGlobal pCtx,
	tDot11fProbeRequest *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_ProbeRequest, IES_ProbeRequest);

	return status;

} /* End dot11f_unpack_probe_request. */

uint32_t dot11f_pack_probe_response(tpAniSirGlobal pCtx,
	tDot11fProbeResponse *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_ProbeResponse, IES_ProbeResponse);

	return status;

} /* End dot11f_unpack_probe_response. */

uint32_t dot11f_pack_qos_map_configure(tpAniSirGlobal pCtx,
	tDot11fQosMapConfigure *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_QosMapConfigure, IES_QosMapConfigure);

	return status;

} /* End dot11f_unpack_qos_map_configure. */

uint32_t dot11f_pack_radio_measurement_report(tpAniSirGlobal pCtx,
	tDot11fRadioMeasurementReport *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_RadioMeasurementReport, IES_RadioMeasurementReport);

	return status;

} /* End dot11f_unpack_radio_measurement_report. */

uint32_t dot11f_pack_radio_measurement_request(tpAniSirGlobal pCtx,
	tDot11fRadioMeasurementRequest *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_RadioMeasurementRequest, IES_RadioMeasurementRequest);

	return status;

} /* End dot11f_unpack_radio_measurement_request. */

uint32_t dot11f_pack_re_assoc_request(tpAniSirGlobal pCtx,
	tDot11fReAssocRequest *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_ReAssocRequest, IES_ReAssocRequest);

	return status;

} /* End dot11f_unpack_re_assoc_request. */

uint32_t dot11f_pack_re_assoc_response(tpAniSirGlobal pCtx,
	tDot11fReAssocResponse *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_ReAssocResponse, IES_ReAssocResponse);

	return status;

} /* End dot11f_unpack_re_assoc_response. */

uint32_t dot11f_pack_sm_power_save(tpAniSirGlobal pCtx,
	tDot11fSMPowerSave *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_SMPowerSave, IES_SMPowerSave);

	return status;

} /* End dot11f_unpack_sm_power_save. */

uint32_t dot11f_pack_sa_query_req(tpAniSirGlobal pCtx,
	tDot11fSaQueryReq *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_SaQueryReq, IES_SaQueryReq);

	return status;

} /* End dot11f_unpack_sa_query_req. */

uint32_t dot11f_pack_sa_query_rsp(tpAniSirGlobal pCtx,
	tDot11fSaQueryRsp *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_SaQueryRsp, IES_SaQueryRsp);

	return status;

} /* End dot11f_unpack_sa_query_rsp. */

uint32_t dot11f_pack_tdls_dis_req(tpAniSirGlobal pCtx,
	tDot11fTDLSDisReq *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_TDLSDisReq, IES_TDLSDisReq);

	return status;

} /* End dot11f_unpack_tdls_dis_req. */

uint32_t dot11f_pack_tdls_dis_rsp(tpAniSirGlobal pCtx,
	tDot11fTDLSDisRsp *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_TDLSDisRsp, IES_TDLSDisRsp);

	return status;

} /* End dot11f_unpack_tdls_dis_rsp. */

uint32_t dot11f_pack_tdls_peer_traffic_ind(tpAniSirGlobal pCtx,
	tDot11fTDLSPeerTrafficInd *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_TDLSPeerTrafficInd, IES_TDLSPeerTrafficInd);

	return status;

} /* End dot11f_unpack_tdls_peer_traffic_ind. */

uint32_t dot11f_pack_tdls_peer_traffic_rsp(tpAniSirGlobal pCtx,
	tDot11fTDLSPeerTrafficRsp *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_TDLSPeerTrafficRsp, IES_TDLSPeerTrafficRsp);

	return status;

} /* End dot11f_unpack_tdls_peer_traffic_rsp. */

uint32_t dot11f_pack_tdls_setup_cnf(tpAniSirGlobal pCtx,
	tDot11fTDLSSetupCnf *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_TDLSSetupCnf, IES_TDLSSetupCnf);

	return status;

} /* End dot11f_unpack_tdls_setup_cnf. */

uint32_t dot11f_pack_tdls_setup_req(tpAniSirGlobal pCtx,
	tDot11fTDLSSetupReq *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_TDLSSetupReq, IES_TDLSSetupReq);

	return status;

} /* End dot11f_unpack_tdls_setup_req. */

uint32_t dot11f_pack_tdls_setup_rsp(tpAniSirGlobal pCtx,
	tDot11fTDLSSetupRsp *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_TDLSSetupRsp, IES_TDLSSetupRsp);

	return status;

} /* End dot11f_unpack_tdls_setup_rsp. */

uint32_t dot11f_pack_tdls_teardown(tpAniSirGlobal pCtx,
	tDot11fTDLSTeardown *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_TDLSTeardown, IES_TDLSTeardown);

	return status;

} /* End dot11f_unpack_tdls_teardown. */

uint32_t dot11f_pack_tpc_report(tpAniSirGlobal pCtx,
	tDot11fTPCReport *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_TPCReport, IES_TPCReport);

	return status;

} /* End dot11f_unpack_tpc_report. */

uint32_t dot11f_pack_tpc_request(tpAniSirGlobal pCtx,
	tDot11fTPCRequest *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_TPCRequest, IES_TPCRequest);

	return status;

} /* End dot11f_unpack_tpc_request. */

uint32_t dot11f_pack_timing_advertisement_frame(tpAniSirGlobal pCtx,
	tDot11fTimingAdvertisementFrame *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_TimingAdvertisementFrame, IES_TimingAdvertisementFrame);

	return status;

} /* End dot11f_unpack_timing_advertisement_frame. */

uint32_t dot11f_pack_vht_gid_management_action_frame(tpAniSirGlobal pCtx,
	tDot11fVHTGidManagementActionFrame *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_VHTGidManagementActionFrame, IES_VHTGidManagementActionFrame);

	return status;

} /* End dot11f_unpack_vht_gid_management_action_frame. */

uint32_t dot11f_pack_wmm_add_ts_request(tpAniSirGlobal pCtx,
	tDot11fWMMAddTSRequest *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_WMMAddTSRequest, IES_WMMAddTSRequest);

	return status;

} /* End dot11f_unpack_wmm_add_ts_request. */

uint32_t dot11f_pack_wmm_add_ts_response(tpAniSirGlobal pCtx,
	tDot11fWMMAddTSResponse *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_WMMAddTSResponse, IES_WMMAddTSResponse);

	return status;

} /* End dot11f_unpack_wmm_add_ts_response. */

uint32_t dot11f_pack_wmm_del_ts(tpAniSirGlobal pCtx,
	tDot11fWMMDelTS *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_WMMDelTS, IES_WMMDelTS);

	return status;

} /* End dot11f_unpack_wmm_del_ts. */

uint32_t dot11f_pack_addba_req(tpAniSirGlobal pCtx,
	tDot11faddba_req *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_addba_req, IES_addba_req);

	return status;

} /* End dot11f_unpack_addba_req. */

uint32_t dot11f_pack_addba_rsp(tpAniSirGlobal pCtx,
	tDot11faddba_rsp *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_addba_rsp, IES_addba_rsp);

	return status;

} /* End dot11f_unpack_addba_rsp. */

uint32_t dot11f_pack_delba_req(tpAniSirGlobal pCtx,
	tDot11fdelba_req *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_delba_req, IES_delba_req);

	return status;

} /* End dot11f_unpack_delba_req. */

uint32_t dot11f_pack_ext_channel_switch_action_frame(tpAniSirGlobal pCtx,
	tDot11fext_channel_switch_action_frame *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_ext_channel_switch_action_frame, IES_ext_channel_switch_action_frame);

	return status;

} /* End dot11f_unpack_ext_channel_switch_action_frame. */

uint32_t dot11f_pack_ht2040_bss_coexistence_mgmt_action_frame(tpAniSirGlobal pCtx,
	tDot11fht2040_bss_coexistence_mgmt_action_frame *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_ht2040_bss_coexistence_mgmt_action_frame, IES_ht2040_bss_coexistence_mgmt_action_frame);

	return status;

} /* End dot11f_unpack_ht2040_bss_coexistence_mgmt_action_frame. */

uint32_t dot11f_pack_mscs_request_action_frame(tpAniSirGlobal pCtx,
	tDot11fmscs_request_action_frame *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_mscs_request_action_frame, IES_mscs_request_action_frame);

	return status;

} /* End dot11f_unpack_mscs_request_action_frame. */

uint32_t dot11f_pack_p2p_oper_chan_change_confirm(tpAniSirGlobal pCtx,
	tDot11fp2p_oper_chan_change_confirm *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_p2p_oper_chan_change_confirm, IES_p2p_oper_chan_change_confirm);

	return status;

} /* End dot11f_unpack_p2p_oper_chan_change_confirm. */

uint32_t dot11f_pack_vendor_action_frame(tpAniSirGlobal pCtx,
	tDot11fvendor_action_frame *pFrm,
	uint8_t *pBuf, uint32_t nBuf, uint32_t *pnConsumed)
{
	uint32_t i = 0;
	uint32_t status = 0;
	(void)i;
	*pnConsumed = 0U;
	status = pack_core(pCtx, (uint8_t *)pFrm, pBuf, nBuf, pnConsumed,
			   FFS_vendor_action_frame, IES_vendor_action_frame);

	return status;

} /* End dot11f_unpack_vendor_action_frame. */

static uint32_t pack_core(tpAniSirGlobal pCtx,
			   uint8_t *pSrc,
			   uint8_t *pBuf,
			   uint32_t  nBuf,
			   uint32_t *pnConsumed,
			   const tFFDefn  FFs[],
			   const tIEDefn  IEs[])
{
	const tFFDefn *pFf;
	const tIEDefn *pIe;
	tFRAMES_BOOL  *pfFound;
	uint8_t   *pBufRemaining;
	uint16_t  i;
	uint32_t  nBufRemaining, status, len;
	uint32_t  countOffset = 0;

	(void)pCtx; /* Shutup the compiler if we have no FFs nor IEs... */
	i = 0;

	DOT11F_PARAMETER_CHECK2(pSrc, pBuf, nBuf, pnConsumed);

	status = DOT11F_PARSE_SUCCESS;
	pBufRemaining = pBuf;
	nBufRemaining = nBuf;

	pFf = &(FFs[0]);
	while (pFf->size) {
		if (pFf->size > nBufRemaining) {
			FRAMES_LOG3(pCtx, FRLOGE, FRFL("The Fixed Field %s req"
				"uires %d bytes, but there are only %d remaining.\n"),
				pFf->name, pFf->size, nBufRemaining);
			return DOT11F_BUFFER_OVERFLOW;
		}

		switch (pFf->sig) {
		case SigFfAID:
			dot11f_pack_ff_aid(
				pCtx, (tDot11fFfAID *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfAction:
			dot11f_pack_ff_action(
				pCtx, (tDot11fFfAction *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfAuthAlgo:
			dot11f_pack_ff_auth_algo(
				pCtx, (tDot11fFfAuthAlgo *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfAuthSeqNo:
			dot11f_pack_ff_auth_seq_no(
				pCtx, (tDot11fFfAuthSeqNo *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfBeaconInterval:
			dot11f_pack_ff_beacon_interval(
				pCtx, (tDot11fFfBeaconInterval *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfCapabilities:
			dot11f_pack_ff_capabilities(
				pCtx, (tDot11fFfCapabilities *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfCategory:
			dot11f_pack_ff_category(
				pCtx, (tDot11fFfCategory *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfCurrentAPAddress:
			dot11f_pack_ff_current_ap_address(
				pCtx, (tDot11fFfCurrentAPAddress *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfDialogToken:
			dot11f_pack_ff_dialog_token(
				pCtx, (tDot11fFfDialogToken *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfLinkMargin:
			dot11f_pack_ff_link_margin(
				pCtx, (tDot11fFfLinkMargin *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfListenInterval:
			dot11f_pack_ff_listen_interval(
				pCtx, (tDot11fFfListenInterval *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfMaxTxPower:
			dot11f_pack_ff_max_tx_power(
				pCtx, (tDot11fFfMaxTxPower *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfNumOfRepetitions:
			dot11f_pack_ff_num_of_repetitions(
				pCtx, (tDot11fFfNumOfRepetitions *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfOperatingMode:
			dot11f_pack_ff_operating_mode(
				pCtx, (tDot11fFfOperatingMode *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfRCPI:
			dot11f_pack_ff_rcpi(
				pCtx, (tDot11fFfRCPI *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfRSNI:
			dot11f_pack_ff_rsni(
				pCtx, (tDot11fFfRSNI *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfReason:
			dot11f_pack_ff_reason(
				pCtx, (tDot11fFfReason *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfRxAntennaId:
			dot11f_pack_ff_rx_antenna_id(
				pCtx, (tDot11fFfRxAntennaId *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfSMPowerModeSet:
			dot11f_pack_ff_sm_power_mode_set(
				pCtx, (tDot11fFfSMPowerModeSet *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfStatus:
			dot11f_pack_ff_status(
				pCtx, (tDot11fFfStatus *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfStatusCode:
			dot11f_pack_ff_status_code(
				pCtx, (tDot11fFfStatusCode *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfTPCEleID:
			dot11f_pack_ff_tpc_ele_id(
				pCtx, (tDot11fFfTPCEleID *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfTPCEleLen:
			dot11f_pack_ff_tpc_ele_len(
				pCtx, (tDot11fFfTPCEleLen *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfTSInfo:
			dot11f_pack_ff_ts_info(
				pCtx, (tDot11fFfTSInfo *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfTimeStamp:
			dot11f_pack_ff_time_stamp(
				pCtx, (tDot11fFfTimeStamp *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfTransactionId:
			dot11f_pack_ff_transaction_id(
				pCtx, (tDot11fFfTransactionId *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfTxAntennaId:
			dot11f_pack_ff_tx_antenna_id(
				pCtx, (tDot11fFfTxAntennaId *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfTxPower:
			dot11f_pack_ff_tx_power(
				pCtx, (tDot11fFfTxPower *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfVhtMembershipStatusArray:
			dot11f_pack_ff_vht_membership_status_array(
				pCtx, (tDot11fFfVhtMembershipStatusArray *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfVhtUserPositionArray:
			dot11f_pack_ff_vht_user_position_array(
				pCtx, (tDot11fFfVhtUserPositionArray *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfaddba_param_set:
			dot11f_pack_ff_addba_param_set(
				pCtx, (tDot11fFfaddba_param_set *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfba_start_seq_ctrl:
			dot11f_pack_ff_ba_start_seq_ctrl(
				pCtx, (tDot11fFfba_start_seq_ctrl *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfba_timeout:
			dot11f_pack_ff_ba_timeout(
				pCtx, (tDot11fFfba_timeout *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfdelba_param_set:
			dot11f_pack_ff_delba_param_set(
				pCtx, (tDot11fFfdelba_param_set *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfext_chan_switch_ann_action:
			dot11f_pack_ff_ext_chan_switch_ann_action(
				pCtx, (tDot11fFfext_chan_switch_ann_action *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfp2p_action_oui:
			dot11f_pack_ff_p2p_action_oui(
				pCtx, (tDot11fFfp2p_action_oui *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfp2p_action_subtype:
			dot11f_pack_ff_p2p_action_subtype(
				pCtx, (tDot11fFfp2p_action_subtype *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfvendor_action_subtype:
			dot11f_pack_ff_vendor_action_subtype(
				pCtx, (tDot11fFfvendor_action_subtype *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		case SigFfvendor_oui:
			dot11f_pack_ff_vendor_oui(
				pCtx, (tDot11fFfvendor_oui *)
				(pSrc + pFf->offset), pBufRemaining);
			break;
		default:
			FRAMES_LOG1(pCtx, FRLOGE, FRFL("INTERNAL ERROR-- I don"
				"'t know about the Fixed Field %d; this is most l"
				"ikely a bug in 'framesg'.\n"), pFf->sig);
			return DOT11F_INTERNAL_ERROR;
		}

		pBufRemaining += pFf->size;
		nBufRemaining -= pFf->size;
		*pnConsumed   += pFf->size;
		++pFf;

	}

	pIe = &(IEs[0]);
	while (0xff != pIe->eid || pIe->extn_eid) {
		pfFound = (tFRAMES_BOOL *)(pSrc + pIe->offset +
				pIe->presenceOffset);
		if (*pfFound && pIe->minSize > nBufRemaining) {
			FRAMES_LOG3(pCtx, FRLOGE, FRFL("The IE %s takes at le"
				"ast %d bytes, but there are only %d left in the b"
				"uffer.\n"), pIe->name, pIe->minSize, nBufRemaining);
			return DOT11F_BUFFER_OVERFLOW;
		}


		countOffset = ((0 == pIe->arraybound) ?  1 : *(uint16_t *)(pSrc + pIe->countOffset));
		for (i = 0; i < countOffset; ++i) {
			len = 0U;
			switch (pIe->sig) {
			case SigIeGTK:
			status |=
				dot11f_pack_ie_gtk(
				pCtx, (tDot11fIEGTK *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEGTK) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeIGTK:
			status |=
				dot11f_pack_ie_igtk(
				pCtx, (tDot11fIEIGTK *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEIGTK) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeR0KH_ID:
			status |=
				dot11f_pack_ie_r0_kh_id(
				pCtx, (tDot11fIER0KH_ID *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIER0KH_ID) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeR1KH_ID:
			status |=
				dot11f_pack_ie_r1_kh_id(
				pCtx, (tDot11fIER1KH_ID *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIER1KH_ID) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeAPChannelReport:
			status |=
				dot11f_pack_ie_ap_channel_report(
				pCtx, (tDot11fIEAPChannelReport *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEAPChannelReport) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeBcnReportingDetail:
			status |=
				dot11f_pack_ie_bcn_reporting_detail(
				pCtx, (tDot11fIEBcnReportingDetail *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEBcnReportingDetail) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeBeaconReportFrmBody:
			status |=
				dot11f_pack_ie_beacon_report_frm_body(
				pCtx, (tDot11fIEBeaconReportFrmBody *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEBeaconReportFrmBody) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeBeaconReporting:
			status |=
				dot11f_pack_ie_beacon_reporting(
				pCtx, (tDot11fIEBeaconReporting *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEBeaconReporting) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeCondensedCountryStr:
			status |=
				dot11f_pack_ie_condensed_country_str(
				pCtx, (tDot11fIECondensedCountryStr *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIECondensedCountryStr) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeMeasurementPilot:
			status |=
				dot11f_pack_ie_measurement_pilot(
				pCtx, (tDot11fIEMeasurementPilot *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEMeasurementPilot) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeMultiBssid:
			status |=
				dot11f_pack_ie_multi_bssid(
				pCtx, (tDot11fIEMultiBssid *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEMultiBssid) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeRICData:
			status |=
				dot11f_pack_ie_ric_data(
				pCtx, (tDot11fIERICData *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIERICData) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeRICDescriptor:
			status |=
				dot11f_pack_ie_ric_descriptor(
				pCtx, (tDot11fIERICDescriptor *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIERICDescriptor) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeRRMEnabledCap:
			status |=
				dot11f_pack_ie_rrm_enabled_cap(
				pCtx, (tDot11fIERRMEnabledCap *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIERRMEnabledCap) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeRequestedInfo:
			status |=
				dot11f_pack_ie_requested_info(
				pCtx, (tDot11fIERequestedInfo *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIERequestedInfo) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeSSID:
			status |=
				dot11f_pack_ie_ssid(
				pCtx, (tDot11fIESSID *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIESSID) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeSchedule:
			status |=
				dot11f_pack_ie_schedule(
				pCtx, (tDot11fIESchedule *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIESchedule) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeTCLAS:
			status |=
				dot11f_pack_ie_tclas(
				pCtx, (tDot11fIETCLAS *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIETCLAS) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeTCLASSPROC:
			status |=
				dot11f_pack_ie_tclassproc(
				pCtx, (tDot11fIETCLASSPROC *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIETCLASSPROC) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeTSDelay:
			status |=
				dot11f_pack_ie_ts_delay(
				pCtx, (tDot11fIETSDelay *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIETSDelay) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeTSFInfo:
			status |=
				dot11f_pack_ie_tsf_info(
				pCtx, (tDot11fIETSFInfo *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIETSFInfo) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeTSPEC:
			status |=
				dot11f_pack_ie_tspec(
				pCtx, (tDot11fIETSPEC *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIETSPEC) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeVHTCaps:
			status |=
				dot11f_pack_ie_vht_caps(
				pCtx, (tDot11fIEVHTCaps *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEVHTCaps) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeVHTOperation:
			status |=
				dot11f_pack_ie_vht_operation(
				pCtx, (tDot11fIEVHTOperation *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEVHTOperation) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWMMSchedule:
			status |=
				dot11f_pack_ie_wmm_schedule(
				pCtx, (tDot11fIEWMMSchedule *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWMMSchedule) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWMMTCLAS:
			status |=
				dot11f_pack_ie_wmmtclas(
				pCtx, (tDot11fIEWMMTCLAS *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWMMTCLAS) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWMMTCLASPROC:
			status |=
				dot11f_pack_ie_wmmtclasproc(
				pCtx, (tDot11fIEWMMTCLASPROC *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWMMTCLASPROC) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWMMTSDelay:
			status |=
				dot11f_pack_ie_wmmts_delay(
				pCtx, (tDot11fIEWMMTSDelay *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWMMTSDelay) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWMMTSPEC:
			status |=
				dot11f_pack_ie_wmmtspec(
				pCtx, (tDot11fIEWMMTSPEC *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWMMTSPEC) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWiderBWChanSwitchAnn:
			status |=
				dot11f_pack_ie_wider_bw_chan_switch_ann(
				pCtx, (tDot11fIEWiderBWChanSwitchAnn *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWiderBWChanSwitchAnn) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeazimuth_req:
			status |=
				dot11f_pack_ie_azimuth_req(
				pCtx, (tDot11fIEazimuth_req *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEazimuth_req) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIebeacon_report_frm_body_fragment_id:
			status |=
				dot11f_pack_ie_beacon_report_frm_body_fragment_id(
				pCtx, (tDot11fIEbeacon_report_frm_body_fragment_id *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEbeacon_report_frm_body_fragment_id) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIelast_beacon_report_indication:
			status |=
				dot11f_pack_ie_last_beacon_report_indication(
				pCtx, (tDot11fIElast_beacon_report_indication *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIElast_beacon_report_indication) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIemax_age:
			status |=
				dot11f_pack_ie_max_age(
				pCtx, (tDot11fIEmax_age *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEmax_age) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIemscs_status:
			status |=
				dot11f_pack_ie_mscs_status(
				pCtx, (tDot11fIEmscs_status *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEmscs_status) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeneighbor_rpt:
			status |=
				dot11f_pack_ie_neighbor_rpt(
				pCtx, (tDot11fIEneighbor_rpt *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEneighbor_rpt) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIereq_mac_addr:
			status |=
				dot11f_pack_ie_req_mac_addr(
				pCtx, (tDot11fIEreq_mac_addr *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEreq_mac_addr) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIetclas_mask:
			status |=
				dot11f_pack_ie_tclas_mask(
				pCtx, (tDot11fIEtclas_mask *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEtclas_mask) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIetgt_mac_addr:
			status |=
				dot11f_pack_ie_tgt_mac_addr(
				pCtx, (tDot11fIEtgt_mac_addr *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEtgt_mac_addr) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIetransmit_power_env:
			status |=
				dot11f_pack_ie_transmit_power_env(
				pCtx, (tDot11fIEtransmit_power_env *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEtransmit_power_env) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeAID:
			status |=
				dot11f_pack_ie_aid(
				pCtx, (tDot11fIEAID *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEAID) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeCFParams:
			status |=
				dot11f_pack_ie_cf_params(
				pCtx, (tDot11fIECFParams *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIECFParams) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeChallengeText:
			status |=
				dot11f_pack_ie_challenge_text(
				pCtx, (tDot11fIEChallengeText *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEChallengeText) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeChanSwitchAnn:
			status |=
				dot11f_pack_ie_chan_switch_ann(
				pCtx, (tDot11fIEChanSwitchAnn *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEChanSwitchAnn) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeChannelSwitchWrapper:
			status |=
				dot11f_pack_ie_channel_switch_wrapper(
				pCtx, (tDot11fIEChannelSwitchWrapper *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEChannelSwitchWrapper) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeCountry:
			status |=
				dot11f_pack_ie_country(
				pCtx, (tDot11fIECountry *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIECountry) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeDSParams:
			status |=
				dot11f_pack_ie_ds_params(
				pCtx, (tDot11fIEDSParams *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEDSParams) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeEDCAParamSet:
			status |=
				dot11f_pack_ie_edca_param_set(
				pCtx, (tDot11fIEEDCAParamSet *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEEDCAParamSet) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeERPInfo:
			status |=
				dot11f_pack_ie_erp_info(
				pCtx, (tDot11fIEERPInfo *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEERPInfo) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeESECckmOpaque:
			status |=
				dot11f_pack_ie_ese_cckm_opaque(
				pCtx, (tDot11fIEESECckmOpaque *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEESECckmOpaque) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeESERadMgmtCap:
			status |=
				dot11f_pack_ie_ese_rad_mgmt_cap(
				pCtx, (tDot11fIEESERadMgmtCap *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEESERadMgmtCap) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeESETrafStrmMet:
			status |=
				dot11f_pack_ie_ese_traf_strm_met(
				pCtx, (tDot11fIEESETrafStrmMet *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEESETrafStrmMet) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeESETrafStrmRateSet:
			status |=
				dot11f_pack_ie_ese_traf_strm_rate_set(
				pCtx, (tDot11fIEESETrafStrmRateSet *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEESETrafStrmRateSet) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeESETxmitPower:
			status |=
				dot11f_pack_ie_ese_txmit_power(
				pCtx, (tDot11fIEESETxmitPower *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEESETxmitPower) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeESEVersion:
			status |=
				dot11f_pack_ie_ese_version(
				pCtx, (tDot11fIEESEVersion *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEESEVersion) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeExtCap:
			status |=
				dot11f_pack_ie_ext_cap(
				pCtx, (tDot11fIEExtCap *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEExtCap) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeExtSuppRates:
			status |=
				dot11f_pack_ie_ext_supp_rates(
				pCtx, (tDot11fIEExtSuppRates *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEExtSuppRates) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeFHParamSet:
			status |=
				dot11f_pack_ie_fh_param_set(
				pCtx, (tDot11fIEFHParamSet *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEFHParamSet) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeFHParams:
			status |=
				dot11f_pack_ie_fh_params(
				pCtx, (tDot11fIEFHParams *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEFHParams) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeFHPattTable:
			status |=
				dot11f_pack_ie_fh_patt_table(
				pCtx, (tDot11fIEFHPattTable *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEFHPattTable) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeFTInfo:
			status |=
				dot11f_pack_ie_ft_info(
				pCtx, (tDot11fIEFTInfo *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEFTInfo) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeHTCaps:
			status |=
				dot11f_pack_ie_ht_caps(
				pCtx, (tDot11fIEHTCaps *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEHTCaps) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeHTInfo:
			status |=
				dot11f_pack_ie_ht_info(
				pCtx, (tDot11fIEHTInfo *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEHTInfo) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeLinkIdentifier:
			status |=
				dot11f_pack_ie_link_identifier(
				pCtx, (tDot11fIELinkIdentifier *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIELinkIdentifier) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeMBO_IE:
			status |=
				dot11f_pack_ie_MBO_IE(
				pCtx, (tDot11fIEMBO_IE *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEMBO_IE) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeMeasurementReport:
			status |=
				dot11f_pack_ie_measurement_report(
				pCtx, (tDot11fIEMeasurementReport *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEMeasurementReport) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeMeasurementRequest:
			status |=
				dot11f_pack_ie_measurement_request(
				pCtx, (tDot11fIEMeasurementRequest *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEMeasurementRequest) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeMobilityDomain:
			status |=
				dot11f_pack_ie_mobility_domain(
				pCtx, (tDot11fIEMobilityDomain *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEMobilityDomain) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeNeighborReport:
			status |=
				dot11f_pack_ie_neighbor_report(
				pCtx, (tDot11fIENeighborReport *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIENeighborReport) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeOBSSScanParameters:
			status |=
				dot11f_pack_ie_obss_scan_parameters(
				pCtx, (tDot11fIEOBSSScanParameters *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEOBSSScanParameters) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeOperatingMode:
			status |=
				dot11f_pack_ie_operating_mode(
				pCtx, (tDot11fIEOperatingMode *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEOperatingMode) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeP2PAssocReq:
			status |=
				dot11f_pack_ie_p2_p_assoc_req(
				pCtx, (tDot11fIEP2PAssocReq *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEP2PAssocReq) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeP2PAssocRes:
			status |=
				dot11f_pack_ie_p2_p_assoc_res(
				pCtx, (tDot11fIEP2PAssocRes *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEP2PAssocRes) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeP2PBeacon:
			status |=
				dot11f_pack_ie_p2_p_beacon(
				pCtx, (tDot11fIEP2PBeacon *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEP2PBeacon) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeP2PBeaconProbeRes:
			status |=
				dot11f_pack_ie_p2_p_beacon_probe_res(
				pCtx, (tDot11fIEP2PBeaconProbeRes *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEP2PBeaconProbeRes) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeP2PDeAuth:
			status |=
				dot11f_pack_ie_p2_p_de_auth(
				pCtx, (tDot11fIEP2PDeAuth *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEP2PDeAuth) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeP2PDisAssoc:
			status |=
				dot11f_pack_ie_p2_p_dis_assoc(
				pCtx, (tDot11fIEP2PDisAssoc *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEP2PDisAssoc) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeP2PIEOpaque:
			status |=
				dot11f_pack_ie_p2_pie_opaque(
				pCtx, (tDot11fIEP2PIEOpaque *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEP2PIEOpaque) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeP2PProbeReq:
			status |=
				dot11f_pack_ie_p2_p_probe_req(
				pCtx, (tDot11fIEP2PProbeReq *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEP2PProbeReq) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeP2PProbeRes:
			status |=
				dot11f_pack_ie_p2_p_probe_res(
				pCtx, (tDot11fIEP2PProbeRes *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEP2PProbeRes) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIePTIControl:
			status |=
				dot11f_pack_ie_pti_control(
				pCtx, (tDot11fIEPTIControl *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEPTIControl) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIePUBufferStatus:
			status |=
				dot11f_pack_ie_pu_buffer_status(
				pCtx, (tDot11fIEPUBufferStatus *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEPUBufferStatus) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIePowerCaps:
			status |=
				dot11f_pack_ie_power_caps(
				pCtx, (tDot11fIEPowerCaps *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEPowerCaps) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIePowerConstraints:
			status |=
				dot11f_pack_ie_power_constraints(
				pCtx, (tDot11fIEPowerConstraints *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEPowerConstraints) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeQBSSLoad:
			status |=
				dot11f_pack_ie_qbss_load(
				pCtx, (tDot11fIEQBSSLoad *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEQBSSLoad) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeQComVendorIE:
			status |=
				dot11f_pack_ie_QComVendorIE(
				pCtx, (tDot11fIEQComVendorIE *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEQComVendorIE) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeQOSCapsAp:
			status |=
				dot11f_pack_ie_qos_caps_ap(
				pCtx, (tDot11fIEQOSCapsAp *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEQOSCapsAp) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeQOSCapsStation:
			status |=
				dot11f_pack_ie_qos_caps_station(
				pCtx, (tDot11fIEQOSCapsStation *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEQOSCapsStation) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeQosMapSet:
			status |=
				dot11f_pack_ie_qos_map_set(
				pCtx, (tDot11fIEQosMapSet *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEQosMapSet) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeQuiet:
			status |=
				dot11f_pack_ie_quiet(
				pCtx, (tDot11fIEQuiet *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEQuiet) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeRCPIIE:
			status |=
				dot11f_pack_ie_rcpiie(
				pCtx, (tDot11fIERCPIIE *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIERCPIIE) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeRICDataDesc:
			status |=
				dot11f_pack_ie_ric_data_desc(
				pCtx, (tDot11fIERICDataDesc *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIERICDataDesc) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeRSN:
			status |=
				dot11f_pack_ie_rsn(
				pCtx, (tDot11fIERSN *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIERSN) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeRSNIIE:
			status |=
				dot11f_pack_ie_rsniie(
				pCtx, (tDot11fIERSNIIE *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIERSNIIE) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeRSNOpaque:
			status |=
				dot11f_pack_ie_rsn_opaque(
				pCtx, (tDot11fIERSNOpaque *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIERSNOpaque) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeSuppChannels:
			status |=
				dot11f_pack_ie_supp_channels(
				pCtx, (tDot11fIESuppChannels *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIESuppChannels) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeSuppOperatingClasses:
			status |=
				dot11f_pack_ie_supp_operating_classes(
				pCtx, (tDot11fIESuppOperatingClasses *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIESuppOperatingClasses) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeSuppRates:
			status |=
				dot11f_pack_ie_supp_rates(
				pCtx, (tDot11fIESuppRates *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIESuppRates) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeTIM:
			status |=
				dot11f_pack_ie_tim(
				pCtx, (tDot11fIETIM *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIETIM) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeTPCReport:
			status |=
				dot11f_pack_ie_tpc_report(
				pCtx, (tDot11fIETPCReport *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIETPCReport) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeTPCRequest:
			status |=
				dot11f_pack_ie_tpc_request(
				pCtx, (tDot11fIETPCRequest *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIETPCRequest) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeTimeAdvertisement:
			status |=
				dot11f_pack_ie_time_advertisement(
				pCtx, (tDot11fIETimeAdvertisement *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIETimeAdvertisement) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeTimeoutInterval:
			status |=
				dot11f_pack_ie_timeout_interval(
				pCtx, (tDot11fIETimeoutInterval *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIETimeoutInterval) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeVHTExtBssLoad:
			status |=
				dot11f_pack_ie_vht_ext_bss_load(
				pCtx, (tDot11fIEVHTExtBssLoad *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEVHTExtBssLoad) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeVendor1IE:
			status |=
				dot11f_pack_ie_vendor1_ie(
				pCtx, (tDot11fIEVendor1IE *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEVendor1IE) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeVendor3IE:
			status |=
				dot11f_pack_ie_vendor3_ie(
				pCtx, (tDot11fIEVendor3IE *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEVendor3IE) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWAPI:
			status |=
				dot11f_pack_ie_wapi(
				pCtx, (tDot11fIEWAPI *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWAPI) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWAPIOpaque:
			status |=
				dot11f_pack_ie_wapi_opaque(
				pCtx, (tDot11fIEWAPIOpaque *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWAPIOpaque) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWFATPC:
			status |=
				dot11f_pack_ie_wfatpc(
				pCtx, (tDot11fIEWFATPC *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWFATPC) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWFDIEOpaque:
			status |=
				dot11f_pack_ie_wfdie_opaque(
				pCtx, (tDot11fIEWFDIEOpaque *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWFDIEOpaque) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWMMCaps:
			status |=
				dot11f_pack_ie_wmm_caps(
				pCtx, (tDot11fIEWMMCaps *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWMMCaps) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWMMInfoAp:
			status |=
				dot11f_pack_ie_wmm_info_ap(
				pCtx, (tDot11fIEWMMInfoAp *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWMMInfoAp) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWMMInfoStation:
			status |=
				dot11f_pack_ie_wmm_info_station(
				pCtx, (tDot11fIEWMMInfoStation *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWMMInfoStation) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWMMParams:
			status |=
				dot11f_pack_ie_wmm_params(
				pCtx, (tDot11fIEWMMParams *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWMMParams) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWPA:
			status |=
				dot11f_pack_ie_wpa(
				pCtx, (tDot11fIEWPA *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWPA) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWPAOpaque:
			status |=
				dot11f_pack_ie_wpa_opaque(
				pCtx, (tDot11fIEWPAOpaque *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWPAOpaque) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWSC:
			status |=
				dot11f_pack_ie_wsc(
				pCtx, (tDot11fIEWSC *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWSC) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWscAssocReq:
			status |=
				dot11f_pack_ie_wsc_assoc_req(
				pCtx, (tDot11fIEWscAssocReq *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWscAssocReq) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWscAssocRes:
			status |=
				dot11f_pack_ie_wsc_assoc_res(
				pCtx, (tDot11fIEWscAssocRes *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWscAssocRes) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWscBeacon:
			status |=
				dot11f_pack_ie_wsc_beacon(
				pCtx, (tDot11fIEWscBeacon *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWscBeacon) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWscBeaconProbeRes:
			status |=
				dot11f_pack_ie_wsc_beacon_probe_res(
				pCtx, (tDot11fIEWscBeaconProbeRes *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWscBeaconProbeRes) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWscIEOpaque:
			status |=
				dot11f_pack_ie_wsc_ie_opaque(
				pCtx, (tDot11fIEWscIEOpaque *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWscIEOpaque) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWscProbeReq:
			status |=
				dot11f_pack_ie_wsc_probe_req(
				pCtx, (tDot11fIEWscProbeReq *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWscProbeReq) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWscProbeRes:
			status |=
				dot11f_pack_ie_wsc_probe_res(
				pCtx, (tDot11fIEWscProbeRes *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWscProbeRes) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeWscReassocRes:
			status |=
				dot11f_pack_ie_wsc_reassoc_res(
				pCtx, (tDot11fIEWscReassocRes *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEWscReassocRes) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeaddba_extn_element:
			status |=
				dot11f_pack_ie_addba_extn_element(
				pCtx, (tDot11fIEaddba_extn_element *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEaddba_extn_element) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIebss_color_change:
			status |=
				dot11f_pack_ie_bss_color_change(
				pCtx, (tDot11fIEbss_color_change *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEbss_color_change) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIedecriptor_element:
			status |=
				dot11f_pack_ie_decriptor_element(
				pCtx, (tDot11fIEdecriptor_element *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEdecriptor_element) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIedh_parameter_element:
			status |=
				dot11f_pack_ie_dh_parameter_element(
				pCtx, (tDot11fIEdh_parameter_element *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEdh_parameter_element) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeesp_information:
			status |=
				dot11f_pack_ie_esp_information(
				pCtx, (tDot11fIEesp_information *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEesp_information) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeext_chan_switch_ann:
			status |=
				dot11f_pack_ie_ext_chan_switch_ann(
				pCtx, (tDot11fIEext_chan_switch_ann *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEext_chan_switch_ann) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIefils_assoc_delay_info:
			status |=
				dot11f_pack_ie_fils_assoc_delay_info(
				pCtx, (tDot11fIEfils_assoc_delay_info *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEfils_assoc_delay_info) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIefils_hlp_container:
			status |=
				dot11f_pack_ie_fils_hlp_container(
				pCtx, (tDot11fIEfils_hlp_container *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEfils_hlp_container) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIefils_indication:
			status |=
				dot11f_pack_ie_fils_indication(
				pCtx, (tDot11fIEfils_indication *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEfils_indication) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIefils_kde:
			status |=
				dot11f_pack_ie_fils_kde(
				pCtx, (tDot11fIEfils_kde *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEfils_kde) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIefils_key_confirmation:
			status |=
				dot11f_pack_ie_fils_key_confirmation(
				pCtx, (tDot11fIEfils_key_confirmation *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEfils_key_confirmation) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIefils_nonce:
			status |=
				dot11f_pack_ie_fils_nonce(
				pCtx, (tDot11fIEfils_nonce *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEfils_nonce) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIefils_public_key:
			status |=
				dot11f_pack_ie_fils_public_key(
				pCtx, (tDot11fIEfils_public_key *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEfils_public_key) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIefils_session:
			status |=
				dot11f_pack_ie_fils_session(
				pCtx, (tDot11fIEfils_session *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEfils_session) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIefils_wrapped_data:
			status |=
				dot11f_pack_ie_fils_wrapped_data(
				pCtx, (tDot11fIEfils_wrapped_data *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEfils_wrapped_data) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIefragment_ie:
			status |=
				dot11f_pack_ie_fragment_ie(
				pCtx, (tDot11fIEfragment_ie *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEfragment_ie) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIehe_6ghz_band_cap:
			status |=
				dot11f_pack_ie_he_6ghz_band_cap(
				pCtx, (tDot11fIEhe_6ghz_band_cap *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEhe_6ghz_band_cap) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIehe_cap:
			status |=
				dot11f_pack_ie_he_cap(
				pCtx, (tDot11fIEhe_cap *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEhe_cap) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIehe_op:
			status |=
				dot11f_pack_ie_he_op(
				pCtx, (tDot11fIEhe_op *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEhe_op) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIehs20vendor_ie:
			status |=
				dot11f_pack_ie_hs20vendor_ie(
				pCtx, (tDot11fIEhs20vendor_ie *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEhs20vendor_ie) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeht2040_bss_coexistence:
			status |=
				dot11f_pack_ie_ht2040_bss_coexistence(
				pCtx, (tDot11fIEht2040_bss_coexistence *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEht2040_bss_coexistence) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeht2040_bss_intolerant_report:
			status |=
				dot11f_pack_ie_ht2040_bss_intolerant_report(
				pCtx, (tDot11fIEht2040_bss_intolerant_report *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEht2040_bss_intolerant_report) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIemu_edca_param_set:
			status |=
				dot11f_pack_ie_mu_edca_param_set(
				pCtx, (tDot11fIEmu_edca_param_set *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEmu_edca_param_set) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeoci:
			status |=
				dot11f_pack_ie_oci(
				pCtx, (tDot11fIEoci *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEoci) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeosen_ie:
			status |=
				dot11f_pack_ie_osen_ie(
				pCtx, (tDot11fIEosen_ie *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEosen_ie) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeqcn_ie:
			status |=
				dot11f_pack_ie_qcn_ie(
				pCtx, (tDot11fIEqcn_ie *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEqcn_ie) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIeroaming_consortium_sel:
			status |=
				dot11f_pack_ie_roaming_consortium_sel(
				pCtx, (tDot11fIEroaming_consortium_sel *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEroaming_consortium_sel) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIesec_chan_offset_ele:
			status |=
				dot11f_pack_ie_sec_chan_offset_ele(
				pCtx, (tDot11fIEsec_chan_offset_ele *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEsec_chan_offset_ele) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			case SigIevendor_vht_ie:
			status |=
				dot11f_pack_ie_vendor_vht_ie(
				pCtx, (tDot11fIEvendor_vht_ie *)
				(pSrc + pIe->offset +
				sizeof(tDot11fIEvendor_vht_ie) * i),
				pBufRemaining, nBufRemaining, &len);
			break;
			default:
				FRAMES_LOG1(pCtx, FRLOGE, FRFL("INTERNAL ERROR-- I don"
				"'t know about the IE %d; this is most likely a b"
				"ug in 'framesc'.\n"), pFf->sig);
				return DOT11F_INTERNAL_ERROR;
			}

			pBufRemaining += len;
			nBufRemaining -= len;
			*pnConsumed   += len;
		}

		++pIe;

	}

	return status;

}

static uint32_t pack_tlv_core(tpAniSirGlobal pCtx,
				uint8_t *pSrc,
				uint8_t *pBuf,
				uint32_t  nBuf,
				uint32_t *pnConsumed,
				const tTLVDefn  TLVs[],
				uint32_t *pidx)
{
	const tTLVDefn *pTlv;
	tFRAMES_BOOL   *pfFound;
	uint8_t    *pBufRemaining;
	uint32_t   nBufRemaining, status, len;

	DOT11F_PARAMETER_CHECK2(pSrc, pBuf, nBuf, pnConsumed);

	(void)pCtx;
	status = DOT11F_PARSE_SUCCESS;
	pBufRemaining = pBuf;
	nBufRemaining = nBuf;

	pTlv = &(TLVs[0]);
	while (0xffff != pTlv->id) {
		pfFound = (tFRAMES_BOOL *)(pSrc + pTlv->offset +
					pTlv->presenceOffset);
		if (*pfFound && pTlv->minSize > nBufRemaining) {
			FRAMES_LOG3(pCtx, FRLOGE, FRFL("The TLV %s takes at least"
			    " %d bytes, but there are only %d left in the buffer."
			    "\n"), pTlv->name, pTlv->minSize, nBufRemaining);
			return DOT11F_BUFFER_OVERFLOW;
		}

		len = 0U;

		if (*pfFound) {
			switch (pTlv->sig) {
			case SigTlvAuthorizedMACs:
				status |=
					dot11f_pack_tlv_authorized_ma_cs(
					pCtx, (tDot11fTLVAuthorizedMACs *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvRequestToEnroll:
				status |=
					dot11f_pack_tlv_request_to_enroll(
					pCtx, (tDot11fTLVRequestToEnroll *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvVersion2:
				status |=
					dot11f_pack_tlv_version2(
					pCtx, (tDot11fTLVVersion2 *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvAPSetupLocked:
				status |=
					dot11f_pack_tlv_ap_setup_locked(
					pCtx, (tDot11fTLVAPSetupLocked *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvAssociationState:
				status |=
					dot11f_pack_tlv_association_state(
					pCtx, (tDot11fTLVAssociationState *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvConfigMethods:
				status |=
					dot11f_pack_tlv_config_methods(
					pCtx, (tDot11fTLVConfigMethods *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvConfigurationError:
				status |=
					dot11f_pack_tlv_configuration_error(
					pCtx, (tDot11fTLVConfigurationError *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvDeviceName:
				status |=
					dot11f_pack_tlv_device_name(
					pCtx, (tDot11fTLVDeviceName *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvDevicePasswordID:
				status |=
					dot11f_pack_tlv_device_password_id(
					pCtx, (tDot11fTLVDevicePasswordID *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvExtendedListenTiming:
				status |=
					dot11f_pack_tlv_extended_listen_timing(
					pCtx, (tDot11fTLVExtendedListenTiming *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvListenChannel:
				status |=
					dot11f_pack_tlv_listen_channel(
					pCtx, (tDot11fTLVListenChannel *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvManufacturer:
				status |=
					dot11f_pack_tlv_manufacturer(
					pCtx, (tDot11fTLVManufacturer *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvMinorReasonCode:
				status |=
					dot11f_pack_tlv_minor_reason_code(
					pCtx, (tDot11fTLVMinorReasonCode *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvModelName:
				status |=
					dot11f_pack_tlv_model_name(
					pCtx, (tDot11fTLVModelName *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvModelNumber:
				status |=
					dot11f_pack_tlv_model_number(
					pCtx, (tDot11fTLVModelNumber *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvNoticeOfAbsence:
				status |=
					dot11f_pack_tlv_notice_of_absence(
					pCtx, (tDot11fTLVNoticeOfAbsence *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvOperatingChannel:
				status |=
					dot11f_pack_tlv_operating_channel(
					pCtx, (tDot11fTLVOperatingChannel *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvP2PCapability:
				status |=
					dot11f_pack_tlv_p2_p_capability(
					pCtx, (tDot11fTLVP2PCapability *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvP2PDeviceId:
				status |=
					dot11f_pack_tlv_p2_p_device_id(
					pCtx, (tDot11fTLVP2PDeviceId *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvP2PDeviceInfo:
				status |=
					dot11f_pack_tlv_p2_p_device_info(
					pCtx, (tDot11fTLVP2PDeviceInfo *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvP2PGroupInfo:
				status |=
					dot11f_pack_tlv_p2_p_group_info(
					pCtx, (tDot11fTLVP2PGroupInfo *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvP2PStatus:
				status |=
					dot11f_pack_tlv_p2_p_status(
					pCtx, (tDot11fTLVP2PStatus *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvPrimaryDeviceType:
				status |=
					dot11f_pack_tlv_primary_device_type(
					pCtx, (tDot11fTLVPrimaryDeviceType *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvRFBands:
				status |=
					dot11f_pack_tlv_rf_bands(
					pCtx, (tDot11fTLVRFBands *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvRequestDeviceType:
				status |=
					dot11f_pack_tlv_request_device_type(
					pCtx, (tDot11fTLVRequestDeviceType *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvRequestType:
				status |=
					dot11f_pack_tlv_request_type(
					pCtx, (tDot11fTLVRequestType *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvResponseType:
				status |=
					dot11f_pack_tlv_response_type(
					pCtx, (tDot11fTLVResponseType *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvSelectedRegistrar:
				status |=
					dot11f_pack_tlv_selected_registrar(
					pCtx, (tDot11fTLVSelectedRegistrar *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvSelectedRegistrarConfigMethods:
				status |=
					dot11f_pack_tlv_selected_registrar_config_methods(
					pCtx, (tDot11fTLVSelectedRegistrarConfigMethods *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvSerialNumber:
				status |=
					dot11f_pack_tlv_serial_number(
					pCtx, (tDot11fTLVSerialNumber *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvUUID_E:
				status |=
					dot11f_pack_tlv_uuid_e(
					pCtx, (tDot11fTLVUUID_E *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvUUID_R:
				status |=
					dot11f_pack_tlv_uuid_r(
					pCtx, (tDot11fTLVUUID_R *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvVendorExtension:
				status |=
					dot11f_pack_tlv_vendor_extension(
					pCtx, (tDot11fTLVVendorExtension *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvVersion:
				status |=
					dot11f_pack_tlv_version(
					pCtx, (tDot11fTLVVersion *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvWPSState:
				status |=
					dot11f_pack_tlv_wps_state(
					pCtx, (tDot11fTLVWPSState *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvassoc_disallowed:
				status |=
					dot11f_pack_tlv_assoc_disallowed(
					pCtx, (tDot11fTLVassoc_disallowed *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvassoc_retry_delay:
				status |=
					dot11f_pack_tlv_assoc_retry_delay(
					pCtx, (tDot11fTLVassoc_retry_delay *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvcellular_data_cap:
				status |=
					dot11f_pack_tlv_cellular_data_cap(
					pCtx, (tDot11fTLVcellular_data_cap *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvcellular_data_con_pref:
				status |=
					dot11f_pack_tlv_cellular_data_con_pref(
					pCtx, (tDot11fTLVcellular_data_con_pref *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvhe_2xltf_160mhz_supp:
				status |=
					dot11f_pack_tlv_he_2xltf_160mhz_supp(
					pCtx, (tDot11fTLVhe_2xltf_160mhz_supp *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvhe_400ns_sgi_attr:
				status |=
					dot11f_pack_tlv_he_400ns_sgi_attr(
					pCtx, (tDot11fTLVhe_400ns_sgi_attr *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvhe_dl_mumimo_attr:
				status |=
					dot11f_pack_tlv_he_dl_mumimo_attr(
					pCtx, (tDot11fTLVhe_dl_mumimo_attr *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvhe_dl_ofdma_attr:
				status |=
					dot11f_pack_tlv_he_dl_ofdma_attr(
					pCtx, (tDot11fTLVhe_dl_ofdma_attr *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvhe_mcs13_attr:
				status |=
					dot11f_pack_tlv_he_mcs13_attr(
					pCtx, (tDot11fTLVhe_mcs13_attr *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvmbo_ap_cap:
				status |=
					dot11f_pack_tlv_mbo_ap_cap(
					pCtx, (tDot11fTLVmbo_ap_cap *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvnon_prefferd_chan_rep:
				status |=
					dot11f_pack_tlv_non_prefferd_chan_rep(
					pCtx, (tDot11fTLVnon_prefferd_chan_rep *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvoce_cap:
				status |=
					dot11f_pack_tlv_oce_cap(
					pCtx, (tDot11fTLVoce_cap *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvqcn_version:
				status |=
					dot11f_pack_tlv_qcn_version(
					pCtx, (tDot11fTLVqcn_version *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvreduced_wan_metrics:
				status |=
					dot11f_pack_tlv_reduced_wan_metrics(
					pCtx, (tDot11fTLVreduced_wan_metrics *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvrssi_assoc_rej:
				status |=
					dot11f_pack_tlv_rssi_assoc_rej(
					pCtx, (tDot11fTLVrssi_assoc_rej *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvtrans_reasonp_attr:
				status |=
					dot11f_pack_tlv_trans_reasonp_attr(
					pCtx, (tDot11fTLVtrans_reasonp_attr *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvtrans_rejectp_attr:
				status |=
					dot11f_pack_tlv_trans_rejectp_attr(
					pCtx, (tDot11fTLVtrans_rejectp_attr *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvtransition_reason:
				status |=
					dot11f_pack_tlv_transition_reason(
					pCtx, (tDot11fTLVtransition_reason *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvtransition_reject_reason:
				status |=
					dot11f_pack_tlv_transition_reject_reason(
					pCtx, (tDot11fTLVtransition_reject_reason *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvvht_mcs11_attr:
				status |=
					dot11f_pack_tlv_vht_mcs11_attr(
					pCtx, (tDot11fTLVvht_mcs11_attr *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvP2PInterface:
				status |=
					dot11f_pack_tlv_p2_p_interface(
					pCtx, (tDot11fTLVP2PInterface *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			case SigTlvP2PManageability:
				status |=
					dot11f_pack_tlv_p2_p_manageability(
					pCtx, (tDot11fTLVP2PManageability *)
					(pSrc + pTlv->offset), pBufRemaining,
					nBufRemaining, &len);
				break;
			default:
				FRAMES_LOG1(pCtx, FRLOGE, FRFL("INTERNAL ERROR-- I don't "
				    "know about the TLV %d; this is most likely a bug in "
				    "'framesc'.\n"), pTlv->sig);
				return DOT11F_INTERNAL_ERROR;
			}

		} /* End if on *pfFound */
		pBufRemaining += len;
		nBufRemaining -= len;
		*pnConsumed   += len;
		++pTlv;
		if (len)
			++*pidx;
	}

	return status;

}
